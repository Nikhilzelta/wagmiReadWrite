{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.withCache = exports.getCache = exports.responseCache = exports.promiseCache = void 0;\nexports.promiseCache = new Map();\nexports.responseCache = new Map();\nfunction getCache(cacheKey) {\n  const buildCache = (cacheKey, cache) => ({\n    clear: () => cache.delete(cacheKey),\n    get: () => cache.get(cacheKey),\n    set: data => cache.set(cacheKey, data)\n  });\n  const promise = buildCache(cacheKey, exports.promiseCache);\n  const response = buildCache(cacheKey, exports.responseCache);\n  return {\n    clear: () => {\n      promise.clear();\n      response.clear();\n    },\n    promise,\n    response\n  };\n}\nexports.getCache = getCache;\nasync function withCache(fn, {\n  cacheKey,\n  cacheTime = Infinity\n}) {\n  const cache = getCache(cacheKey);\n  const response = cache.response.get();\n  if (response && cacheTime > 0) {\n    const age = new Date().getTime() - response.created.getTime();\n    if (age < cacheTime) return response.data;\n  }\n  let promise = cache.promise.get();\n  if (!promise) {\n    promise = fn();\n    cache.promise.set(promise);\n  }\n  try {\n    const data = await promise;\n    cache.response.set({\n      created: new Date(),\n      data\n    });\n    return data;\n  } finally {\n    cache.promise.clear();\n  }\n}\nexports.withCache = withCache;","map":{"version":3,"names":["exports","promiseCache","Map","responseCache","getCache","cacheKey","buildCache","cache","clear","delete","get","set","data","promise","response","withCache","fn","cacheTime","Infinity","age","Date","getTime","created"],"sources":["/Users/nikhilbhatia/NIkhil/ZT-Prejects/wagmi-react-app/node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/promise/withCache.ts"],"sourcesContent":["import type { ErrorType } from '../../errors/utils.js'\n\nexport const promiseCache = /*#__PURE__*/ new Map()\nexport const responseCache = /*#__PURE__*/ new Map()\n\nexport type GetCacheErrorType = ErrorType\n\nexport function getCache<TData>(cacheKey: string) {\n  const buildCache = <TData>(cacheKey: string, cache: Map<string, TData>) => ({\n    clear: () => cache.delete(cacheKey),\n    get: () => cache.get(cacheKey),\n    set: (data: TData) => cache.set(cacheKey, data),\n  })\n\n  const promise = buildCache<Promise<TData>>(cacheKey, promiseCache)\n  const response = buildCache<{ created: Date; data: TData }>(\n    cacheKey,\n    responseCache,\n  )\n\n  return {\n    clear: () => {\n      promise.clear()\n      response.clear()\n    },\n    promise,\n    response,\n  }\n}\n\nexport type WithCacheParameters = {\n  /** The key to cache the data against. */\n  cacheKey: string\n  /** The time that cached data will remain in memory. Default: Infinity (no expiry) */\n  cacheTime?: number\n}\n\n/**\n * @description Returns the result of a given promise, and caches the result for\n * subsequent invocations against a provided cache key.\n */\nexport async function withCache<TData>(\n  fn: () => Promise<TData>,\n  { cacheKey, cacheTime = Infinity }: WithCacheParameters,\n) {\n  const cache = getCache<TData>(cacheKey)\n\n  // If a response exists in the cache, and it's not expired, return it\n  // and do not invoke the promise.\n  // If the max age is 0, the cache is disabled.\n  const response = cache.response.get()\n  if (response && cacheTime > 0) {\n    const age = new Date().getTime() - response.created.getTime()\n    if (age < cacheTime) return response.data\n  }\n\n  let promise = cache.promise.get()\n  if (!promise) {\n    promise = fn()\n\n    // Store the promise in the cache so that subsequent invocations\n    // will wait for the same promise to resolve (deduping).\n    cache.promise.set(promise)\n  }\n\n  try {\n    const data = await promise\n\n    // Store the response in the cache so that subsequent invocations\n    // will return the same response.\n    cache.response.set({ created: new Date(), data })\n\n    return data\n  } finally {\n    // Clear the promise cache so that subsequent invocations will\n    // invoke the promise again.\n    cache.promise.clear()\n  }\n}\n"],"mappings":";;;;;;AAEaA,OAAA,CAAAC,YAAY,GAAiB,IAAIC,GAAG,EAAE;AACtCF,OAAA,CAAAG,aAAa,GAAiB,IAAID,GAAG,EAAE;AAIpD,SAAgBE,QAAQA,CAAQC,QAAgB;EAC9C,MAAMC,UAAU,GAAGA,CAAQD,QAAgB,EAAEE,KAAyB,MAAM;IAC1EC,KAAK,EAAEA,CAAA,KAAMD,KAAK,CAACE,MAAM,CAACJ,QAAQ,CAAC;IACnCK,GAAG,EAAEA,CAAA,KAAMH,KAAK,CAACG,GAAG,CAACL,QAAQ,CAAC;IAC9BM,GAAG,EAAGC,IAAW,IAAKL,KAAK,CAACI,GAAG,CAACN,QAAQ,EAAEO,IAAI;GAC/C,CAAC;EAEF,MAAMC,OAAO,GAAGP,UAAU,CAAiBD,QAAQ,EAAEL,OAAA,CAAAC,YAAY,CAAC;EAClE,MAAMa,QAAQ,GAAGR,UAAU,CACzBD,QAAQ,EACRL,OAAA,CAAAG,aAAa,CACd;EAED,OAAO;IACLK,KAAK,EAAEA,CAAA,KAAK;MACVK,OAAO,CAACL,KAAK,EAAE;MACfM,QAAQ,CAACN,KAAK,EAAE;IAClB,CAAC;IACDK,OAAO;IACPC;GACD;AACH;AArBAd,OAAA,CAAAI,QAAA,GAAAA,QAAA;AAkCO,eAAeW,SAASA,CAC7BC,EAAwB,EACxB;EAAEX,QAAQ;EAAEY,SAAS,GAAGC;AAAQ,CAAuB;EAEvD,MAAMX,KAAK,GAAGH,QAAQ,CAAQC,QAAQ,CAAC;EAKvC,MAAMS,QAAQ,GAAGP,KAAK,CAACO,QAAQ,CAACJ,GAAG,EAAE;EACrC,IAAII,QAAQ,IAAIG,SAAS,GAAG,CAAC,EAAE;IAC7B,MAAME,GAAG,GAAG,IAAIC,IAAI,EAAE,CAACC,OAAO,EAAE,GAAGP,QAAQ,CAACQ,OAAO,CAACD,OAAO,EAAE;IAC7D,IAAIF,GAAG,GAAGF,SAAS,EAAE,OAAOH,QAAQ,CAACF,IAAI;;EAG3C,IAAIC,OAAO,GAAGN,KAAK,CAACM,OAAO,CAACH,GAAG,EAAE;EACjC,IAAI,CAACG,OAAO,EAAE;IACZA,OAAO,GAAGG,EAAE,EAAE;IAIdT,KAAK,CAACM,OAAO,CAACF,GAAG,CAACE,OAAO,CAAC;;EAG5B,IAAI;IACF,MAAMD,IAAI,GAAG,MAAMC,OAAO;IAI1BN,KAAK,CAACO,QAAQ,CAACH,GAAG,CAAC;MAAEW,OAAO,EAAE,IAAIF,IAAI,EAAE;MAAER;IAAI,CAAE,CAAC;IAEjD,OAAOA,IAAI;GACZ,SAAS;IAGRL,KAAK,CAACM,OAAO,CAACL,KAAK,EAAE;;AAEzB;AArCAR,OAAA,CAAAe,SAAA,GAAAA,SAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}