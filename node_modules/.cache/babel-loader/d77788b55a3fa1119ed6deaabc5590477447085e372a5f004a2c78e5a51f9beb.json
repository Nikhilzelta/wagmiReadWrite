{"ast":null,"code":"import { reconnect } from './actions/reconnect.js';\nexport function hydrate(config, parameters) {\n  const {\n    initialState,\n    reconnectOnMount\n  } = parameters;\n  if (initialState && !config._internal.store.persist.hasHydrated()) config.setState({\n    ...initialState,\n    connections: reconnectOnMount ? initialState.connections : new Map(),\n    status: reconnectOnMount ? 'reconnecting' : 'disconnected'\n  });\n  return {\n    async onMount() {\n      if (config._internal.ssr) {\n        await config._internal.store.persist.rehydrate();\n        const mipdConnectors = config._internal.mipd?.getProviders().map(config._internal.connectors.providerDetailToConnector).map(config._internal.connectors.setup);\n        config._internal.connectors.setState(connectors => [...connectors, ...(mipdConnectors ?? [])]);\n      }\n      if (reconnectOnMount) reconnect(config);else if (config.storage)\n        // Reset connections that may have been hydrated from storage.\n        config.setState(x => ({\n          ...x,\n          connections: new Map()\n        }));\n    }\n  };\n}","map":{"version":3,"names":["reconnect","hydrate","config","parameters","initialState","reconnectOnMount","_internal","store","persist","hasHydrated","setState","connections","Map","status","onMount","ssr","rehydrate","mipdConnectors","mipd","getProviders","map","connectors","providerDetailToConnector","setup","storage","x"],"sources":["/Users/nikhilbhatia/NIkhil/ZT-Prejects/wagmi-react-app/node_modules/@wagmi/core/src/hydrate.ts"],"sourcesContent":["import { reconnect } from './actions/reconnect.js'\nimport type { Config, State } from './createConfig.js'\n\ntype HydrateParameters = {\n  initialState?: State | undefined\n  reconnectOnMount?: boolean | undefined\n}\n\nexport function hydrate(config: Config, parameters: HydrateParameters) {\n  const { initialState, reconnectOnMount } = parameters\n\n  if (initialState && !config._internal.store.persist.hasHydrated())\n    config.setState({\n      ...initialState,\n      connections: reconnectOnMount ? initialState.connections : new Map(),\n      status: reconnectOnMount ? 'reconnecting' : 'disconnected',\n    })\n\n  return {\n    async onMount() {\n      if (config._internal.ssr) {\n        await config._internal.store.persist.rehydrate()\n        const mipdConnectors = config._internal.mipd\n          ?.getProviders()\n          .map(config._internal.connectors.providerDetailToConnector)\n          .map(config._internal.connectors.setup)\n        config._internal.connectors.setState((connectors) => [\n          ...connectors,\n          ...(mipdConnectors ?? []),\n        ])\n      }\n\n      if (reconnectOnMount) reconnect(config)\n      else if (config.storage)\n        // Reset connections that may have been hydrated from storage.\n        config.setState((x) => ({\n          ...x,\n          connections: new Map(),\n        }))\n    },\n  }\n}\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,wBAAwB;AAQlD,OAAM,SAAUC,OAAOA,CAACC,MAAc,EAAEC,UAA6B;EACnE,MAAM;IAAEC,YAAY;IAAEC;EAAgB,CAAE,GAAGF,UAAU;EAErD,IAAIC,YAAY,IAAI,CAACF,MAAM,CAACI,SAAS,CAACC,KAAK,CAACC,OAAO,CAACC,WAAW,EAAE,EAC/DP,MAAM,CAACQ,QAAQ,CAAC;IACd,GAAGN,YAAY;IACfO,WAAW,EAAEN,gBAAgB,GAAGD,YAAY,CAACO,WAAW,GAAG,IAAIC,GAAG,EAAE;IACpEC,MAAM,EAAER,gBAAgB,GAAG,cAAc,GAAG;GAC7C,CAAC;EAEJ,OAAO;IACL,MAAMS,OAAOA,CAAA;MACX,IAAIZ,MAAM,CAACI,SAAS,CAACS,GAAG,EAAE;QACxB,MAAMb,MAAM,CAACI,SAAS,CAACC,KAAK,CAACC,OAAO,CAACQ,SAAS,EAAE;QAChD,MAAMC,cAAc,GAAGf,MAAM,CAACI,SAAS,CAACY,IAAI,EACxCC,YAAY,EAAE,CACfC,GAAG,CAAClB,MAAM,CAACI,SAAS,CAACe,UAAU,CAACC,yBAAyB,CAAC,CAC1DF,GAAG,CAAClB,MAAM,CAACI,SAAS,CAACe,UAAU,CAACE,KAAK,CAAC;QACzCrB,MAAM,CAACI,SAAS,CAACe,UAAU,CAACX,QAAQ,CAAEW,UAAU,IAAK,CACnD,GAAGA,UAAU,EACb,IAAIJ,cAAc,IAAI,EAAE,CAAC,CAC1B,CAAC;MACJ;MAEA,IAAIZ,gBAAgB,EAAEL,SAAS,CAACE,MAAM,CAAC,MAClC,IAAIA,MAAM,CAACsB,OAAO;QACrB;QACAtB,MAAM,CAACQ,QAAQ,CAAEe,CAAC,KAAM;UACtB,GAAGA,CAAC;UACJd,WAAW,EAAE,IAAIC,GAAG;SACrB,CAAC,CAAC;IACP;GACD;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}