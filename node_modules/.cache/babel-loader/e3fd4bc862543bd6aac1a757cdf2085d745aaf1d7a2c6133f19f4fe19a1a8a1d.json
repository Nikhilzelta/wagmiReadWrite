{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseAccessList = exports.toTransactionArray = exports.parseTransaction = void 0;\nconst address_js_1 = require(\"../../errors/address.js\");\nconst transaction_js_1 = require(\"../../errors/transaction.js\");\nconst isAddress_js_1 = require(\"../address/isAddress.js\");\nconst isHex_js_1 = require(\"../data/isHex.js\");\nconst pad_js_1 = require(\"../data/pad.js\");\nconst trim_js_1 = require(\"../data/trim.js\");\nconst fromHex_js_1 = require(\"../encoding/fromHex.js\");\nconst fromRlp_js_1 = require(\"../encoding/fromRlp.js\");\nconst isHash_js_1 = require(\"../hash/isHash.js\");\nconst assertTransaction_js_1 = require(\"./assertTransaction.js\");\nconst getSerializedTransactionType_js_1 = require(\"./getSerializedTransactionType.js\");\nfunction parseTransaction(serializedTransaction) {\n  const type = (0, getSerializedTransactionType_js_1.getSerializedTransactionType)(serializedTransaction);\n  if (type === 'eip1559') return parseTransactionEIP1559(serializedTransaction);\n  if (type === 'eip2930') return parseTransactionEIP2930(serializedTransaction);\n  return parseTransactionLegacy(serializedTransaction);\n}\nexports.parseTransaction = parseTransaction;\nfunction parseTransactionEIP1559(serializedTransaction) {\n  const transactionArray = toTransactionArray(serializedTransaction);\n  const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, v, r, s] = transactionArray;\n  if (!(transactionArray.length === 9 || transactionArray.length === 12)) throw new transaction_js_1.InvalidSerializedTransactionError({\n    attributes: {\n      chainId,\n      nonce,\n      maxPriorityFeePerGas,\n      maxFeePerGas,\n      gas,\n      to,\n      value,\n      data,\n      accessList,\n      ...(transactionArray.length > 9 ? {\n        v,\n        r,\n        s\n      } : {})\n    },\n    serializedTransaction,\n    type: 'eip1559'\n  });\n  const transaction = {\n    chainId: (0, fromHex_js_1.hexToNumber)(chainId),\n    type: 'eip1559'\n  };\n  if ((0, isHex_js_1.isHex)(to) && to !== '0x') transaction.to = to;\n  if ((0, isHex_js_1.isHex)(gas) && gas !== '0x') transaction.gas = (0, fromHex_js_1.hexToBigInt)(gas);\n  if ((0, isHex_js_1.isHex)(data) && data !== '0x') transaction.data = data;\n  if ((0, isHex_js_1.isHex)(nonce) && nonce !== '0x') transaction.nonce = (0, fromHex_js_1.hexToNumber)(nonce);\n  if ((0, isHex_js_1.isHex)(value) && value !== '0x') transaction.value = (0, fromHex_js_1.hexToBigInt)(value);\n  if ((0, isHex_js_1.isHex)(maxFeePerGas) && maxFeePerGas !== '0x') transaction.maxFeePerGas = (0, fromHex_js_1.hexToBigInt)(maxFeePerGas);\n  if ((0, isHex_js_1.isHex)(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x') transaction.maxPriorityFeePerGas = (0, fromHex_js_1.hexToBigInt)(maxPriorityFeePerGas);\n  if (accessList.length !== 0 && accessList !== '0x') transaction.accessList = parseAccessList(accessList);\n  (0, assertTransaction_js_1.assertTransactionEIP1559)(transaction);\n  const signature = transactionArray.length === 12 ? parseEIP155Signature(transactionArray) : undefined;\n  return {\n    ...signature,\n    ...transaction\n  };\n}\nfunction parseTransactionEIP2930(serializedTransaction) {\n  const transactionArray = toTransactionArray(serializedTransaction);\n  const [chainId, nonce, gasPrice, gas, to, value, data, accessList, v, r, s] = transactionArray;\n  if (!(transactionArray.length === 8 || transactionArray.length === 11)) throw new transaction_js_1.InvalidSerializedTransactionError({\n    attributes: {\n      chainId,\n      nonce,\n      gasPrice,\n      gas,\n      to,\n      value,\n      data,\n      accessList,\n      ...(transactionArray.length > 8 ? {\n        v,\n        r,\n        s\n      } : {})\n    },\n    serializedTransaction,\n    type: 'eip2930'\n  });\n  const transaction = {\n    chainId: (0, fromHex_js_1.hexToNumber)(chainId),\n    type: 'eip2930'\n  };\n  if ((0, isHex_js_1.isHex)(to) && to !== '0x') transaction.to = to;\n  if ((0, isHex_js_1.isHex)(gas) && gas !== '0x') transaction.gas = (0, fromHex_js_1.hexToBigInt)(gas);\n  if ((0, isHex_js_1.isHex)(data) && data !== '0x') transaction.data = data;\n  if ((0, isHex_js_1.isHex)(nonce) && nonce !== '0x') transaction.nonce = (0, fromHex_js_1.hexToNumber)(nonce);\n  if ((0, isHex_js_1.isHex)(value) && value !== '0x') transaction.value = (0, fromHex_js_1.hexToBigInt)(value);\n  if ((0, isHex_js_1.isHex)(gasPrice) && gasPrice !== '0x') transaction.gasPrice = (0, fromHex_js_1.hexToBigInt)(gasPrice);\n  if (accessList.length !== 0 && accessList !== '0x') transaction.accessList = parseAccessList(accessList);\n  (0, assertTransaction_js_1.assertTransactionEIP2930)(transaction);\n  const signature = transactionArray.length === 11 ? parseEIP155Signature(transactionArray) : undefined;\n  return {\n    ...signature,\n    ...transaction\n  };\n}\nfunction parseTransactionLegacy(serializedTransaction) {\n  const transactionArray = (0, fromRlp_js_1.fromRlp)(serializedTransaction, 'hex');\n  const [nonce, gasPrice, gas, to, value, data, chainIdOrV_, r, s] = transactionArray;\n  if (!(transactionArray.length === 6 || transactionArray.length === 9)) throw new transaction_js_1.InvalidSerializedTransactionError({\n    attributes: {\n      nonce,\n      gasPrice,\n      gas,\n      to,\n      value,\n      data,\n      ...(transactionArray.length > 6 ? {\n        v: chainIdOrV_,\n        r,\n        s\n      } : {})\n    },\n    serializedTransaction,\n    type: 'legacy'\n  });\n  const transaction = {\n    type: 'legacy'\n  };\n  if ((0, isHex_js_1.isHex)(to) && to !== '0x') transaction.to = to;\n  if ((0, isHex_js_1.isHex)(gas) && gas !== '0x') transaction.gas = (0, fromHex_js_1.hexToBigInt)(gas);\n  if ((0, isHex_js_1.isHex)(data) && data !== '0x') transaction.data = data;\n  if ((0, isHex_js_1.isHex)(nonce) && nonce !== '0x') transaction.nonce = (0, fromHex_js_1.hexToNumber)(nonce);\n  if ((0, isHex_js_1.isHex)(value) && value !== '0x') transaction.value = (0, fromHex_js_1.hexToBigInt)(value);\n  if ((0, isHex_js_1.isHex)(gasPrice) && gasPrice !== '0x') transaction.gasPrice = (0, fromHex_js_1.hexToBigInt)(gasPrice);\n  (0, assertTransaction_js_1.assertTransactionLegacy)(transaction);\n  if (transactionArray.length === 6) return transaction;\n  const chainIdOrV = (0, isHex_js_1.isHex)(chainIdOrV_) && chainIdOrV_ !== '0x' ? (0, fromHex_js_1.hexToBigInt)(chainIdOrV_) : 0n;\n  if (s === '0x' && r === '0x') {\n    if (chainIdOrV > 0) transaction.chainId = Number(chainIdOrV);\n    return transaction;\n  }\n  const v = chainIdOrV;\n  const chainId = Number((v - 35n) / 2n);\n  if (chainId > 0) transaction.chainId = chainId;else if (v !== 27n && v !== 28n) throw new transaction_js_1.InvalidLegacyVError({\n    v\n  });\n  transaction.v = v;\n  transaction.s = s;\n  transaction.r = r;\n  return transaction;\n}\nfunction toTransactionArray(serializedTransaction) {\n  return (0, fromRlp_js_1.fromRlp)(`0x${serializedTransaction.slice(4)}`, 'hex');\n}\nexports.toTransactionArray = toTransactionArray;\nfunction parseAccessList(accessList_) {\n  const accessList = [];\n  for (let i = 0; i < accessList_.length; i++) {\n    const [address, storageKeys] = accessList_[i];\n    if (!(0, isAddress_js_1.isAddress)(address)) throw new address_js_1.InvalidAddressError({\n      address\n    });\n    accessList.push({\n      address: address,\n      storageKeys: storageKeys.map(key => (0, isHash_js_1.isHash)(key) ? key : (0, trim_js_1.trim)(key))\n    });\n  }\n  return accessList;\n}\nexports.parseAccessList = parseAccessList;\nfunction parseEIP155Signature(transactionArray) {\n  const signature = transactionArray.slice(-3);\n  const v = signature[0] === '0x' || (0, fromHex_js_1.hexToBigInt)(signature[0]) === 0n ? 27n : 28n;\n  return {\n    r: (0, pad_js_1.padHex)(signature[1], {\n      size: 32\n    }),\n    s: (0, pad_js_1.padHex)(signature[2], {\n      size: 32\n    }),\n    v,\n    yParity: v === 27n ? 0 : 1\n  };\n}","map":{"version":3,"names":["address_js_1","require","transaction_js_1","isAddress_js_1","isHex_js_1","pad_js_1","trim_js_1","fromHex_js_1","fromRlp_js_1","isHash_js_1","assertTransaction_js_1","getSerializedTransactionType_js_1","parseTransaction","serializedTransaction","type","getSerializedTransactionType","parseTransactionEIP1559","parseTransactionEIP2930","parseTransactionLegacy","exports","transactionArray","toTransactionArray","chainId","nonce","maxPriorityFeePerGas","maxFeePerGas","gas","to","value","data","accessList","v","r","s","length","InvalidSerializedTransactionError","attributes","transaction","hexToNumber","isHex","hexToBigInt","parseAccessList","assertTransactionEIP1559","signature","parseEIP155Signature","undefined","gasPrice","assertTransactionEIP2930","fromRlp","chainIdOrV_","assertTransactionLegacy","chainIdOrV","Number","InvalidLegacyVError","slice","accessList_","i","address","storageKeys","isAddress","InvalidAddressError","push","map","key","isHash","trim","padHex","size","yParity"],"sources":["/Users/nikhilbhatia/NIkhil/ZT-Prejects/wagmi-react-app/node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/transaction/parseTransaction.ts"],"sourcesContent":["import {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport {\n  InvalidLegacyVError,\n  type InvalidLegacyVErrorType,\n  InvalidSerializedTransactionError,\n  type InvalidSerializedTransactionErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex, Signature } from '../../types/misc.js'\nimport type {\n  AccessList,\n  TransactionRequestEIP2930,\n  TransactionRequestLegacy,\n  TransactionSerializableEIP1559,\n  TransactionSerializableEIP2930,\n  TransactionSerializableLegacy,\n  TransactionSerialized,\n  TransactionSerializedEIP1559,\n  TransactionSerializedEIP2930,\n  TransactionType,\n} from '../../types/transaction.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type PadHexErrorType, padHex } from '../data/pad.js'\nimport { trim } from '../data/trim.js'\nimport {\n  type HexToBigIntErrorType,\n  type HexToNumberErrorType,\n  hexToBigInt,\n  hexToNumber,\n} from '../encoding/fromHex.js'\nimport { type FromRlpErrorType, fromRlp } from '../encoding/fromRlp.js'\nimport type { RecursiveArray } from '../encoding/toRlp.js'\nimport { isHash } from '../hash/isHash.js'\n\nimport {\n  type AssertTransactionEIP1559ErrorType,\n  type AssertTransactionEIP2930ErrorType,\n  type AssertTransactionLegacyErrorType,\n  assertTransactionEIP1559,\n  assertTransactionEIP2930,\n  assertTransactionLegacy,\n} from './assertTransaction.js'\nimport {\n  type GetSerializedTransactionType,\n  type GetSerializedTransactionTypeErrorType,\n  getSerializedTransactionType,\n} from './getSerializedTransactionType.js'\n\nexport type ParseTransactionReturnType<\n  TSerialized extends TransactionSerialized = TransactionSerialized,\n  TType extends TransactionType = GetSerializedTransactionType<TSerialized>,\n> =\n  | (TType extends 'eip1559' ? TransactionSerializableEIP1559 : never)\n  | (TType extends 'eip2930' ? TransactionSerializableEIP2930 : never)\n  | (TType extends 'legacy' ? TransactionSerializableLegacy : never)\n\nexport type ParseTransactionErrorType =\n  | GetSerializedTransactionTypeErrorType\n  | ParseTransactionEIP1559ErrorType\n  | ParseTransactionEIP2930ErrorType\n  | ParseTransactionLegacyErrorType\n\nexport function parseTransaction<TSerialized extends TransactionSerialized>(\n  serializedTransaction: TSerialized,\n): ParseTransactionReturnType<TSerialized> {\n  const type = getSerializedTransactionType(serializedTransaction)\n\n  if (type === 'eip1559')\n    return parseTransactionEIP1559(\n      serializedTransaction as TransactionSerializedEIP1559,\n    ) as ParseTransactionReturnType<TSerialized>\n\n  if (type === 'eip2930')\n    return parseTransactionEIP2930(\n      serializedTransaction as TransactionSerializedEIP2930,\n    ) as ParseTransactionReturnType<TSerialized>\n\n  return parseTransactionLegacy(\n    serializedTransaction,\n  ) as ParseTransactionReturnType<TSerialized>\n}\n\ntype ParseTransactionEIP1559ErrorType =\n  | AssertTransactionEIP1559ErrorType\n  | ToTransactionArrayErrorType\n  | HexToBigIntErrorType\n  | HexToNumberErrorType\n  | InvalidLegacyVErrorType\n  | InvalidSerializedTransactionErrorType\n  | IsHexErrorType\n  | ParseEIP155SignatureErrorType\n  | ErrorType\n\nfunction parseTransactionEIP1559(\n  serializedTransaction: TransactionSerializedEIP1559,\n): TransactionSerializableEIP1559 {\n  const transactionArray = toTransactionArray(serializedTransaction)\n\n  const [\n    chainId,\n    nonce,\n    maxPriorityFeePerGas,\n    maxFeePerGas,\n    gas,\n    to,\n    value,\n    data,\n    accessList,\n    v,\n    r,\n    s,\n  ] = transactionArray\n\n  if (!(transactionArray.length === 9 || transactionArray.length === 12))\n    throw new InvalidSerializedTransactionError({\n      attributes: {\n        chainId,\n        nonce,\n        maxPriorityFeePerGas,\n        maxFeePerGas,\n        gas,\n        to,\n        value,\n        data,\n        accessList,\n        ...(transactionArray.length > 9\n          ? {\n              v,\n              r,\n              s,\n            }\n          : {}),\n      },\n      serializedTransaction,\n      type: 'eip1559',\n    })\n\n  const transaction: TransactionSerializableEIP1559 = {\n    chainId: hexToNumber(chainId as Hex),\n    type: 'eip1559',\n  }\n  if (isHex(to) && to !== '0x') transaction.to = to\n  if (isHex(gas) && gas !== '0x') transaction.gas = hexToBigInt(gas)\n  if (isHex(data) && data !== '0x') transaction.data = data\n  if (isHex(nonce) && nonce !== '0x') transaction.nonce = hexToNumber(nonce)\n  if (isHex(value) && value !== '0x') transaction.value = hexToBigInt(value)\n  if (isHex(maxFeePerGas) && maxFeePerGas !== '0x')\n    transaction.maxFeePerGas = hexToBigInt(maxFeePerGas)\n  if (isHex(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x')\n    transaction.maxPriorityFeePerGas = hexToBigInt(maxPriorityFeePerGas)\n  if (accessList.length !== 0 && accessList !== '0x')\n    transaction.accessList = parseAccessList(accessList as RecursiveArray<Hex>)\n\n  assertTransactionEIP1559(transaction)\n\n  const signature =\n    transactionArray.length === 12\n      ? parseEIP155Signature(transactionArray)\n      : undefined\n\n  return { ...signature, ...transaction }\n}\n\ntype ParseTransactionEIP2930ErrorType =\n  | AssertTransactionEIP2930ErrorType\n  | ToTransactionArrayErrorType\n  | HexToBigIntErrorType\n  | HexToNumberErrorType\n  | InvalidLegacyVErrorType\n  | InvalidSerializedTransactionErrorType\n  | IsHexErrorType\n  | ParseEIP155SignatureErrorType\n  | ErrorType\n\nfunction parseTransactionEIP2930(\n  serializedTransaction: TransactionSerializedEIP2930,\n): Omit<TransactionRequestEIP2930, 'from'> &\n  ({ chainId: number } | ({ chainId: number } & Signature)) {\n  const transactionArray = toTransactionArray(serializedTransaction)\n\n  const [chainId, nonce, gasPrice, gas, to, value, data, accessList, v, r, s] =\n    transactionArray\n\n  if (!(transactionArray.length === 8 || transactionArray.length === 11))\n    throw new InvalidSerializedTransactionError({\n      attributes: {\n        chainId,\n        nonce,\n        gasPrice,\n        gas,\n        to,\n        value,\n        data,\n        accessList,\n        ...(transactionArray.length > 8\n          ? {\n              v,\n              r,\n              s,\n            }\n          : {}),\n      },\n      serializedTransaction,\n      type: 'eip2930',\n    })\n\n  const transaction: TransactionSerializableEIP2930 = {\n    chainId: hexToNumber(chainId as Hex),\n    type: 'eip2930',\n  }\n  if (isHex(to) && to !== '0x') transaction.to = to\n  if (isHex(gas) && gas !== '0x') transaction.gas = hexToBigInt(gas)\n  if (isHex(data) && data !== '0x') transaction.data = data\n  if (isHex(nonce) && nonce !== '0x') transaction.nonce = hexToNumber(nonce)\n  if (isHex(value) && value !== '0x') transaction.value = hexToBigInt(value)\n  if (isHex(gasPrice) && gasPrice !== '0x')\n    transaction.gasPrice = hexToBigInt(gasPrice)\n  if (accessList.length !== 0 && accessList !== '0x')\n    transaction.accessList = parseAccessList(accessList as RecursiveArray<Hex>)\n\n  assertTransactionEIP2930(transaction)\n\n  const signature =\n    transactionArray.length === 11\n      ? parseEIP155Signature(transactionArray)\n      : undefined\n\n  return { ...signature, ...transaction }\n}\n\ntype ParseTransactionLegacyErrorType =\n  | AssertTransactionLegacyErrorType\n  | FromRlpErrorType\n  | HexToBigIntErrorType\n  | HexToNumberErrorType\n  | InvalidLegacyVErrorType\n  | InvalidSerializedTransactionErrorType\n  | IsHexErrorType\n  | ErrorType\n\nfunction parseTransactionLegacy(\n  serializedTransaction: Hex,\n): Omit<TransactionRequestLegacy, 'from'> &\n  ({ chainId?: number } | ({ chainId: number } & Signature)) {\n  const transactionArray = fromRlp(serializedTransaction, 'hex')\n\n  const [nonce, gasPrice, gas, to, value, data, chainIdOrV_, r, s] =\n    transactionArray\n\n  if (!(transactionArray.length === 6 || transactionArray.length === 9))\n    throw new InvalidSerializedTransactionError({\n      attributes: {\n        nonce,\n        gasPrice,\n        gas,\n        to,\n        value,\n        data,\n        ...(transactionArray.length > 6\n          ? {\n              v: chainIdOrV_,\n              r,\n              s,\n            }\n          : {}),\n      },\n      serializedTransaction,\n      type: 'legacy',\n    })\n\n  const transaction: TransactionSerializableLegacy = {\n    type: 'legacy',\n  }\n  if (isHex(to) && to !== '0x') transaction.to = to\n  if (isHex(gas) && gas !== '0x') transaction.gas = hexToBigInt(gas)\n  if (isHex(data) && data !== '0x') transaction.data = data\n  if (isHex(nonce) && nonce !== '0x') transaction.nonce = hexToNumber(nonce)\n  if (isHex(value) && value !== '0x') transaction.value = hexToBigInt(value)\n  if (isHex(gasPrice) && gasPrice !== '0x')\n    transaction.gasPrice = hexToBigInt(gasPrice)\n\n  assertTransactionLegacy(transaction)\n\n  if (transactionArray.length === 6) return transaction\n\n  const chainIdOrV =\n    isHex(chainIdOrV_) && chainIdOrV_ !== '0x'\n      ? hexToBigInt(chainIdOrV_ as Hex)\n      : 0n\n\n  if (s === '0x' && r === '0x') {\n    if (chainIdOrV > 0) transaction.chainId = Number(chainIdOrV)\n    return transaction\n  }\n\n  const v = chainIdOrV\n\n  const chainId: number | undefined = Number((v - 35n) / 2n)\n  if (chainId > 0) transaction.chainId = chainId\n  else if (v !== 27n && v !== 28n) throw new InvalidLegacyVError({ v })\n\n  transaction.v = v\n  transaction.s = s as Hex\n  transaction.r = r as Hex\n\n  return transaction\n}\n\nexport type ToTransactionArrayErrorType = FromRlpErrorType | ErrorType\n\nexport function toTransactionArray(serializedTransaction: string) {\n  return fromRlp(`0x${serializedTransaction.slice(4)}` as Hex, 'hex')\n}\n\nexport type ParseAccessListErrorType =\n  | InvalidAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\nexport function parseAccessList(accessList_: RecursiveArray<Hex>): AccessList {\n  const accessList: AccessList = []\n  for (let i = 0; i < accessList_.length; i++) {\n    const [address, storageKeys] = accessList_[i] as [Hex, Hex[]]\n\n    if (!isAddress(address)) throw new InvalidAddressError({ address })\n\n    accessList.push({\n      address: address,\n      storageKeys: storageKeys.map((key) => (isHash(key) ? key : trim(key))),\n    })\n  }\n  return accessList\n}\n\ntype ParseEIP155SignatureErrorType =\n  | HexToBigIntErrorType\n  | PadHexErrorType\n  | ErrorType\n\nfunction parseEIP155Signature(\n  transactionArray: RecursiveArray<Hex>,\n): Signature & { yParity: number } {\n  const signature = transactionArray.slice(-3)\n  const v =\n    signature[0] === '0x' || hexToBigInt(signature[0] as Hex) === 0n ? 27n : 28n\n  return {\n    r: padHex(signature[1] as Hex, { size: 32 }),\n    s: padHex(signature[2] as Hex, { size: 32 }),\n    v,\n    yParity: v === 27n ? 0 : 1,\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}