{"ast":null,"code":"import 'viem';\nimport '../connectors/createConnector.js';\nimport '../types/utils.js';\nlet isReconnecting = false;\n/** https://wagmi.sh/core/api/actions/reconnect */\nexport async function reconnect(config, parameters = {}) {\n  // If already reconnecting, do nothing\n  if (isReconnecting) return [];\n  isReconnecting = true;\n  config.setState(x => ({\n    ...x,\n    status: x.current ? 'reconnecting' : 'connecting'\n  }));\n  const connectors = [];\n  if (parameters.connectors?.length) {\n    for (const connector_ of parameters.connectors) {\n      let connector;\n      // \"Register\" connector if not already created\n      if (typeof connector_ === 'function') connector = config._internal.connectors.setup(connector_);else connector = connector_;\n      connectors.push(connector);\n    }\n  } else connectors.push(...config.connectors);\n  // Try recently-used connectors first\n  let recentConnectorId;\n  try {\n    recentConnectorId = await config.storage?.getItem('recentConnectorId');\n  } catch {}\n  const scores = {};\n  for (const [, connection] of config.state.connections) {\n    scores[connection.connector.id] = 1;\n  }\n  if (recentConnectorId) scores[recentConnectorId] = 0;\n  const sorted = Object.keys(scores).length > 0 ?\n  // .toSorted()\n  [...connectors].sort((a, b) => (scores[a.id] ?? 10) - (scores[b.id] ?? 10)) : connectors;\n  // Iterate through each connector and try to connect\n  let connected = false;\n  const connections = [];\n  const providers = [];\n  for (const connector of sorted) {\n    const provider_ = await connector.getProvider();\n    if (!provider_) continue;\n    // If we already have an instance of this connector's provider,\n    // then we have already checked it (ie. injected connectors can\n    // share the same `window.ethereum` instance, so we don't want to\n    // connect to it again).\n    if (providers.some(provider => provider === provider_)) continue;\n    const isAuthorized = await connector.isAuthorized();\n    if (!isAuthorized) continue;\n    const data = await connector.connect({\n      isReconnecting: true\n    }).catch(() => null);\n    if (!data) continue;\n    connector.emitter.off('connect', config._internal.events.connect);\n    connector.emitter.on('change', config._internal.events.change);\n    connector.emitter.on('disconnect', config._internal.events.disconnect);\n    config.setState(x => {\n      const connections = new Map(connected ? x.connections : new Map()).set(connector.uid, {\n        accounts: data.accounts,\n        chainId: data.chainId,\n        connector\n      });\n      return {\n        ...x,\n        current: connected ? x.current : connector.uid,\n        connections\n      };\n    });\n    connections.push({\n      accounts: data.accounts,\n      chainId: data.chainId,\n      connector\n    });\n    providers.push(provider_);\n    connected = true;\n  }\n  // Prevent overwriting connected status from race condition\n  if (config.state.status === 'reconnecting' || config.state.status === 'connecting') {\n    // If connecting didn't succeed, set to disconnected\n    if (!connected) config.setState(x => ({\n      ...x,\n      connections: new Map(),\n      current: undefined,\n      status: 'disconnected'\n    }));else config.setState(x => ({\n      ...x,\n      status: 'connected'\n    }));\n  }\n  isReconnecting = false;\n  return connections;\n}","map":{"version":3,"names":["isReconnecting","reconnect","config","parameters","setState","x","status","current","connectors","length","connector_","connector","_internal","setup","push","recentConnectorId","storage","getItem","scores","connection","state","connections","id","sorted","Object","keys","sort","a","b","connected","providers","provider_","getProvider","some","provider","isAuthorized","data","connect","catch","emitter","off","events","on","change","disconnect","Map","set","uid","accounts","chainId","undefined"],"sources":["/Users/nikhilbhatia/NIkhil/ZT-Prejects/wagmi-react-app/node_modules/@wagmi/core/src/actions/reconnect.ts"],"sourcesContent":["import { type Address } from 'viem'\n\nimport { type CreateConnectorFn } from '../connectors/createConnector.js'\nimport type { Config, Connection, Connector } from '../createConfig.js'\nimport type { ErrorType } from '../errors/base.js'\nimport { type Evaluate } from '../types/utils.js'\n\nexport type ReconnectParameters = {\n  /** Connectors to attempt reconnect with */\n  connectors?: readonly (CreateConnectorFn | Connector)[] | undefined\n}\n\nexport type ReconnectReturnType = Evaluate<Connection>[]\n\nexport type ReconnectErrorType = ErrorType\n\nlet isReconnecting = false\n\n/** https://wagmi.sh/core/api/actions/reconnect */\nexport async function reconnect(\n  config: Config,\n  parameters: ReconnectParameters = {},\n): Promise<ReconnectReturnType> {\n  // If already reconnecting, do nothing\n  if (isReconnecting) return []\n  isReconnecting = true\n\n  config.setState((x) => ({\n    ...x,\n    status: x.current ? 'reconnecting' : 'connecting',\n  }))\n\n  const connectors: Connector[] = []\n  if (parameters.connectors?.length) {\n    for (const connector_ of parameters.connectors) {\n      let connector: Connector\n      // \"Register\" connector if not already created\n      if (typeof connector_ === 'function')\n        connector = config._internal.connectors.setup(connector_)\n      else connector = connector_\n      connectors.push(connector)\n    }\n  } else connectors.push(...config.connectors)\n\n  // Try recently-used connectors first\n  let recentConnectorId\n  try {\n    recentConnectorId = await config.storage?.getItem('recentConnectorId')\n  } catch {}\n  const scores: Record<string, number> = {}\n  for (const [, connection] of config.state.connections) {\n    scores[connection.connector.id] = 1\n  }\n  if (recentConnectorId) scores[recentConnectorId] = 0\n  const sorted =\n    Object.keys(scores).length > 0\n      ? // .toSorted()\n        [...connectors].sort(\n          (a, b) => (scores[a.id] ?? 10) - (scores[b.id] ?? 10),\n        )\n      : connectors\n\n  // Iterate through each connector and try to connect\n  let connected = false\n  const connections: Connection[] = []\n  const providers: unknown[] = []\n  for (const connector of sorted) {\n    const provider_ = await connector.getProvider()\n    if (!provider_) continue\n\n    // If we already have an instance of this connector's provider,\n    // then we have already checked it (ie. injected connectors can\n    // share the same `window.ethereum` instance, so we don't want to\n    // connect to it again).\n    if (providers.some((provider) => provider === provider_)) continue\n\n    const isAuthorized = await connector.isAuthorized()\n    if (!isAuthorized) continue\n\n    const data = await connector\n      .connect({ isReconnecting: true })\n      .catch(() => null)\n    if (!data) continue\n\n    connector.emitter.off('connect', config._internal.events.connect)\n    connector.emitter.on('change', config._internal.events.change)\n    connector.emitter.on('disconnect', config._internal.events.disconnect)\n\n    config.setState((x) => {\n      const connections = new Map(connected ? x.connections : new Map()).set(\n        connector.uid,\n        { accounts: data.accounts, chainId: data.chainId, connector },\n      )\n      return {\n        ...x,\n        current: connected ? x.current : connector.uid,\n        connections,\n      }\n    })\n    connections.push({\n      accounts: data.accounts as readonly [Address, ...Address[]],\n      chainId: data.chainId,\n      connector,\n    })\n    providers.push(provider_)\n    connected = true\n  }\n\n  // Prevent overwriting connected status from race condition\n  if (\n    config.state.status === 'reconnecting' ||\n    config.state.status === 'connecting'\n  ) {\n    // If connecting didn't succeed, set to disconnected\n    if (!connected)\n      config.setState((x) => ({\n        ...x,\n        connections: new Map(),\n        current: undefined,\n        status: 'disconnected',\n      }))\n    else config.setState((x) => ({ ...x, status: 'connected' }))\n  }\n\n  isReconnecting = false\n  return connections\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}