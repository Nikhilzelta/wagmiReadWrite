{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.recoverPublicKey = void 0;\nconst isHex_js_1 = require(\"../data/isHex.js\");\nconst fromHex_js_1 = require(\"../encoding/fromHex.js\");\nconst toHex_js_1 = require(\"../encoding/toHex.js\");\nasync function recoverPublicKey({\n  hash,\n  signature\n}) {\n  const signatureHex = (0, isHex_js_1.isHex)(signature) ? signature : (0, toHex_js_1.toHex)(signature);\n  const hashHex = (0, isHex_js_1.isHex)(hash) ? hash : (0, toHex_js_1.toHex)(hash);\n  let v = (0, fromHex_js_1.hexToNumber)(`0x${signatureHex.slice(130)}`);\n  if (v === 0 || v === 1) v += 27;\n  const {\n    secp256k1\n  } = await Promise.resolve().then(() => require('@noble/curves/secp256k1'));\n  const publicKey = secp256k1.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(v - 27).recoverPublicKey(hashHex.substring(2)).toHex(false);\n  return `0x${publicKey}`;\n}\nexports.recoverPublicKey = recoverPublicKey;","map":{"version":3,"names":["isHex_js_1","require","fromHex_js_1","toHex_js_1","recoverPublicKey","hash","signature","signatureHex","isHex","toHex","hashHex","v","hexToNumber","slice","secp256k1","Promise","resolve","then","publicKey","Signature","fromCompact","substring","addRecoveryBit","exports"],"sources":["/Users/nikhilbhatia/NIkhil/ZT-Prejects/wagmi-react-app/node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/signature/recoverPublicKey.ts"],"sourcesContent":["import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type HexToNumberErrorType, hexToNumber } from '../encoding/fromHex.js'\nimport { toHex } from '../encoding/toHex.js'\n\nexport type RecoverPublicKeyParameters = {\n  hash: Hex | ByteArray\n  signature: Hex | ByteArray\n}\n\nexport type RecoverPublicKeyReturnType = Hex\n\nexport type RecoverPublicKeyErrorType =\n  | HexToNumberErrorType\n  | IsHexErrorType\n  | ErrorType\n\nexport async function recoverPublicKey({\n  hash,\n  signature,\n}: RecoverPublicKeyParameters): Promise<RecoverPublicKeyReturnType> {\n  const signatureHex = isHex(signature) ? signature : toHex(signature)\n  const hashHex = isHex(hash) ? hash : toHex(hash)\n\n  // Derive v = recoveryId + 27 from end of the signature (27 is added when signing the message)\n  // The recoveryId represents the y-coordinate on the secp256k1 elliptic curve and can have a value [0, 1].\n  let v = hexToNumber(`0x${signatureHex.slice(130)}`)\n  if (v === 0 || v === 1) v += 27\n\n  const { secp256k1 } = await import('@noble/curves/secp256k1')\n  const publicKey = secp256k1.Signature.fromCompact(\n    signatureHex.substring(2, 130),\n  )\n    .addRecoveryBit(v - 27)\n    .recoverPublicKey(hashHex.substring(2))\n    .toHex(false)\n  return `0x${publicKey}`\n}\n"],"mappings":";;;;;;AAEA,MAAAA,UAAA,GAAAC,OAAA;AACA,MAAAC,YAAA,GAAAD,OAAA;AACA,MAAAE,UAAA,GAAAF,OAAA;AAcO,eAAeG,gBAAgBA,CAAC;EACrCC,IAAI;EACJC;AAAS,CACkB;EAC3B,MAAMC,YAAY,GAAG,IAAAP,UAAA,CAAAQ,KAAK,EAACF,SAAS,CAAC,GAAGA,SAAS,GAAG,IAAAH,UAAA,CAAAM,KAAK,EAACH,SAAS,CAAC;EACpE,MAAMI,OAAO,GAAG,IAAAV,UAAA,CAAAQ,KAAK,EAACH,IAAI,CAAC,GAAGA,IAAI,GAAG,IAAAF,UAAA,CAAAM,KAAK,EAACJ,IAAI,CAAC;EAIhD,IAAIM,CAAC,GAAG,IAAAT,YAAA,CAAAU,WAAW,EAAC,KAAKL,YAAY,CAACM,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC;EACnD,IAAIF,CAAC,KAAK,CAAC,IAAIA,CAAC,KAAK,CAAC,EAAEA,CAAC,IAAI,EAAE;EAE/B,MAAM;IAAEG;EAAS,CAAE,GAAG,MAAAC,OAAA,CAAAC,OAAA,GAAAC,IAAA,OAAAhB,OAAA,CAAa,yBAAyB,EAAC;EAC7D,MAAMiB,SAAS,GAAGJ,SAAS,CAACK,SAAS,CAACC,WAAW,CAC/Cb,YAAY,CAACc,SAAS,CAAC,CAAC,EAAE,GAAG,CAAC,CAC/B,CACEC,cAAc,CAACX,CAAC,GAAG,EAAE,CAAC,CACtBP,gBAAgB,CAACM,OAAO,CAACW,SAAS,CAAC,CAAC,CAAC,CAAC,CACtCZ,KAAK,CAAC,KAAK,CAAC;EACf,OAAO,KAAKS,SAAS,EAAE;AACzB;AApBAK,OAAA,CAAAnB,gBAAA,GAAAA,gBAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}