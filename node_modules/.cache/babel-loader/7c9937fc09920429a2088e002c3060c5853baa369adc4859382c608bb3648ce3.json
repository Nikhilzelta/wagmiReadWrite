{"ast":null,"code":"import { ChainNotConfiguredError, ProviderNotFoundError, createConnector } from '@wagmi/core';\nimport '@wagmi/core/internal';\nimport '@walletconnect/ethereum-provider';\nimport { SwitchChainError, UserRejectedRequestError, getAddress, numberToHex } from 'viem';\nwalletConnect.type = 'walletConnect';\nexport function walletConnect(parameters) {\n  const isNewChainsStale = parameters.isNewChainsStale ?? true;\n  let provider_;\n  let providerPromise;\n  const NAMESPACE = 'eip155';\n  return createConnector(config => ({\n    id: 'walletConnect',\n    name: 'WalletConnect',\n    type: walletConnect.type,\n    async setup() {\n      const provider = await this.getProvider().catch(() => null);\n      if (!provider) return;\n      provider.on('connect', this.onConnect.bind(this));\n      provider.on('session_delete', this.onSessionDelete.bind(this));\n    },\n    async connect({\n      chainId,\n      ...rest\n    } = {}) {\n      try {\n        const provider = await this.getProvider();\n        if (!provider) throw new ProviderNotFoundError();\n        provider.on('display_uri', this.onDisplayUri);\n        let targetChainId = chainId;\n        if (!targetChainId) {\n          const state = (await config.storage?.getItem('state')) ?? {};\n          const isChainSupported = config.chains.some(x => x.id === state.chainId);\n          if (isChainSupported) targetChainId = state.chainId;else targetChainId = config.chains[0]?.id;\n        }\n        if (!targetChainId) throw new Error('No chains found on connector.');\n        const isChainsStale = await this.isChainsStale();\n        // If there is an active session with stale chains, disconnect current session.\n        if (provider.session && isChainsStale) await provider.disconnect();\n        // If there isn't an active session or chains are stale, connect.\n        if (!provider.session || isChainsStale) {\n          const optionalChains = config.chains.filter(chain => chain.id !== targetChainId).map(optionalChain => optionalChain.id);\n          await provider.connect({\n            optionalChains: [targetChainId, ...optionalChains],\n            ...('pairingTopic' in rest ? {\n              pairingTopic: rest.pairingTopic\n            } : {})\n          });\n          this.setRequestedChainsIds(config.chains.map(x => x.id));\n        }\n        // If session exists and chains are authorized, enable provider for required chain\n        const accounts = (await provider.enable()).map(x => getAddress(x));\n        const currentChainId = await this.getChainId();\n        provider.removeListener('display_uri', this.onDisplayUri);\n        provider.removeListener('connect', this.onConnect.bind(this));\n        provider.on('accountsChanged', this.onAccountsChanged.bind(this));\n        provider.on('chainChanged', this.onChainChanged);\n        provider.on('disconnect', this.onDisconnect.bind(this));\n        provider.on('session_delete', this.onSessionDelete.bind(this));\n        return {\n          accounts,\n          chainId: currentChainId\n        };\n      } catch (error) {\n        if (/(user rejected|connection request reset)/i.test(error?.message)) {\n          throw new UserRejectedRequestError(error);\n        }\n        throw error;\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider();\n      try {\n        await provider?.disconnect();\n      } catch (error) {\n        if (!/No matching key/i.test(error.message)) throw error;\n      } finally {\n        provider?.removeListener('accountsChanged', this.onAccountsChanged.bind(this));\n        provider?.removeListener('chainChanged', this.onChainChanged);\n        provider?.removeListener('disconnect', this.onDisconnect.bind(this));\n        provider?.removeListener('session_delete', this.onSessionDelete.bind(this));\n        provider?.on('connect', this.onConnect.bind(this));\n        this.setRequestedChainsIds([]);\n      }\n    },\n    async getAccounts() {\n      const provider = await this.getProvider();\n      return provider.accounts.map(x => getAddress(x));\n    },\n    async getProvider({\n      chainId\n    } = {}) {\n      async function initProvider() {\n        const optionalChains = config.chains.map(x => x.id);\n        if (!optionalChains.length) return;\n        const {\n          EthereumProvider\n        } = await import('@walletconnect/ethereum-provider');\n        return await EthereumProvider.init({\n          ...parameters,\n          disableProviderPing: true,\n          optionalChains,\n          projectId: parameters.projectId,\n          rpcMap: Object.fromEntries(config.chains.map(chain => [chain.id, chain.rpcUrls.default.http[0]])),\n          showQrModal: parameters.showQrModal ?? true\n        });\n      }\n      if (!provider_) {\n        if (!providerPromise) providerPromise = initProvider();\n        provider_ = await providerPromise;\n        provider_?.events.setMaxListeners(Infinity);\n      }\n      if (chainId) await this.switchChain?.({\n        chainId\n      });\n      return provider_;\n    },\n    async getChainId() {\n      const provider = await this.getProvider();\n      return provider.chainId;\n    },\n    async isAuthorized() {\n      try {\n        const [accounts, provider] = await Promise.all([this.getAccounts(), this.getProvider()]);\n        // If an account does not exist on the session, then the connector is unauthorized.\n        if (!accounts.length) return false;\n        // If the chains are stale on the session, then the connector is unauthorized.\n        const isChainsStale = await this.isChainsStale();\n        if (isChainsStale && provider.session) {\n          await provider.disconnect().catch(() => {});\n          return false;\n        }\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    async switchChain({\n      chainId\n    }) {\n      const chain = config.chains.find(chain => chain.id === chainId);\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError());\n      try {\n        const provider = await this.getProvider();\n        const namespaceChains = this.getNamespaceChainsIds();\n        const namespaceMethods = this.getNamespaceMethods();\n        const isChainApproved = namespaceChains.includes(chainId);\n        if (!isChainApproved && namespaceMethods.includes('wallet_addEthereumChain')) {\n          await provider.request({\n            method: 'wallet_addEthereumChain',\n            params: [{\n              chainId: numberToHex(chain.id),\n              blockExplorerUrls: [chain.blockExplorers?.default.url],\n              chainName: chain.name,\n              nativeCurrency: chain.nativeCurrency,\n              rpcUrls: [...chain.rpcUrls.default.http]\n            }]\n          });\n          const requestedChains = await this.getRequestedChainsIds();\n          this.setRequestedChainsIds([...requestedChains, chainId]);\n        }\n        await provider.request({\n          method: 'wallet_switchEthereumChain',\n          params: [{\n            chainId: numberToHex(chainId)\n          }]\n        });\n        return chain;\n      } catch (error) {\n        const message = typeof error === 'string' ? error : error?.message;\n        if (/user rejected request/i.test(message)) throw new UserRejectedRequestError(error);\n        throw new SwitchChainError(error);\n      }\n    },\n    onAccountsChanged(accounts) {\n      if (accounts.length === 0) this.onDisconnect();else config.emitter.emit('change', {\n        accounts: accounts.map(x => getAddress(x))\n      });\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain);\n      config.emitter.emit('change', {\n        chainId\n      });\n    },\n    async onConnect(connectInfo) {\n      const chainId = Number(connectInfo.chainId);\n      const accounts = await this.getAccounts();\n      config.emitter.emit('connect', {\n        accounts,\n        chainId\n      });\n    },\n    async onDisconnect(_error) {\n      this.setRequestedChainsIds([]);\n      config.emitter.emit('disconnect');\n      const provider = await this.getProvider();\n      provider.removeListener('accountsChanged', this.onAccountsChanged.bind(this));\n      provider.removeListener('chainChanged', this.onChainChanged);\n      provider.removeListener('disconnect', this.onDisconnect.bind(this));\n      provider.removeListener('session_delete', this.onSessionDelete.bind(this));\n      provider.on('connect', this.onConnect.bind(this));\n    },\n    onDisplayUri(uri) {\n      config.emitter.emit('message', {\n        type: 'display_uri',\n        data: uri\n      });\n    },\n    onSessionDelete() {\n      this.onDisconnect();\n    },\n    getNamespaceChainsIds() {\n      if (!provider_) return [];\n      const chainIds = provider_.session?.namespaces[NAMESPACE]?.chains?.map(chain => parseInt(chain.split(':')[1] || ''));\n      return chainIds ?? [];\n    },\n    getNamespaceMethods() {\n      if (!provider_) return [];\n      const methods = provider_.session?.namespaces[NAMESPACE]?.methods;\n      return methods ?? [];\n    },\n    async getRequestedChainsIds() {\n      return (await config.storage?.getItem(this.requestedChainsStorageKey)) ?? [];\n    },\n    /**\n     * Checks if the target chains match the chains that were\n     * initially requested by the connector for the WalletConnect session.\n     * If there is a mismatch, this means that the chains on the connector\n     * are considered stale, and need to be revalidated at a later point (via\n     * connection).\n     *\n     * There may be a scenario where a dapp adds a chain to the\n     * connector later on, however, this chain will not have been approved or rejected\n     * by the wallet. In this case, the chain is considered stale.\n     *\n     * There are exceptions however:\n     * -  If the wallet supports dynamic chain addition via `eth_addEthereumChain`,\n     *    then the chain is not considered stale.\n     * -  If the `isNewChainsStale` flag is falsy on the connector, then the chain is\n     *    not considered stale.\n     *\n     * For the above cases, chain validation occurs dynamically when the user\n     * attempts to switch chain.\n     *\n     * Also check that dapp supports at least 1 chain from previously approved session.\n     */\n    async isChainsStale() {\n      const namespaceMethods = this.getNamespaceMethods();\n      if (namespaceMethods.includes('wallet_addEthereumChain')) return false;\n      if (!isNewChainsStale) return false;\n      const connectorChains = config.chains.map(x => x.id);\n      const namespaceChains = this.getNamespaceChainsIds();\n      if (namespaceChains.length && !namespaceChains.some(id => connectorChains.includes(id))) return false;\n      const requestedChains = await this.getRequestedChainsIds();\n      return !connectorChains.every(id => requestedChains.includes(id));\n    },\n    async setRequestedChainsIds(chains) {\n      await config.storage?.setItem(this.requestedChainsStorageKey, chains);\n    },\n    get requestedChainsStorageKey() {\n      return `${this.id}.requestedChains`;\n    }\n  }));\n}","map":{"version":3,"names":["ChainNotConfiguredError","ProviderNotFoundError","createConnector","SwitchChainError","UserRejectedRequestError","getAddress","numberToHex","walletConnect","type","parameters","isNewChainsStale","provider_","providerPromise","NAMESPACE","config","id","name","setup","provider","getProvider","catch","on","onConnect","bind","onSessionDelete","connect","chainId","rest","onDisplayUri","targetChainId","state","storage","getItem","isChainSupported","chains","some","x","Error","isChainsStale","session","disconnect","optionalChains","filter","chain","map","optionalChain","pairingTopic","setRequestedChainsIds","accounts","enable","currentChainId","getChainId","removeListener","onAccountsChanged","onChainChanged","onDisconnect","error","test","message","getAccounts","initProvider","length","EthereumProvider","init","disableProviderPing","projectId","rpcMap","Object","fromEntries","rpcUrls","default","http","showQrModal","events","setMaxListeners","Infinity","switchChain","isAuthorized","Promise","all","find","namespaceChains","getNamespaceChainsIds","namespaceMethods","getNamespaceMethods","isChainApproved","includes","request","method","params","blockExplorerUrls","blockExplorers","url","chainName","nativeCurrency","requestedChains","getRequestedChainsIds","emitter","emit","Number","connectInfo","_error","uri","data","chainIds","namespaces","parseInt","split","methods","requestedChainsStorageKey","connectorChains","every","setItem"],"sources":["/Users/nikhilbhatia/NIkhil/ZT-Prejects/wagmi-react-app/node_modules/wagmi/node_modules/@wagmi/connectors/src/walletConnect.ts"],"sourcesContent":["import {\n  ChainNotConfiguredError,\n  ProviderNotFoundError,\n  createConnector,\n} from '@wagmi/core'\nimport {\n  type Evaluate,\n  type ExactPartial,\n  type Omit,\n} from '@wagmi/core/internal'\nimport { type EthereumProvider } from '@walletconnect/ethereum-provider'\nimport {\n  type Address,\n  type ProviderConnectInfo,\n  type ProviderRpcError,\n  SwitchChainError,\n  UserRejectedRequestError,\n  getAddress,\n  numberToHex,\n} from 'viem'\n\ntype EthereumProviderOptions = Parameters<typeof EthereumProvider['init']>[0]\n\nexport type WalletConnectParameters = Evaluate<\n  {\n    /**\n     * If a new chain is added to a previously existing configured connector `chains`, this flag\n     * will determine if that chain should be considered as stale. A stale chain is a chain that\n     * WalletConnect has yet to establish a relationship with (e.g. the user has not approved or\n     * rejected the chain).\n     *\n     * Preface: Whereas WalletConnect v1 supported dynamic chain switching, WalletConnect v2 requires\n     * the user to pre-approve a set of chains up-front. This comes with consequent UX nuances (see below) when\n     * a user tries to switch to a chain that they have not approved.\n     *\n     * This flag mainly affects the behavior when a wallet does not support dynamic chain authorization\n     * with WalletConnect v2.\n     *\n     * If `true` (default), the new chain will be treated as a stale chain. If the user\n     * has yet to establish a relationship (approved/rejected) with this chain in their WalletConnect\n     * session, the connector will disconnect upon the dapp auto-connecting, and the user will have to\n     * reconnect to the dapp (revalidate the chain) in order to approve the newly added chain.\n     * This is the default behavior to avoid an unexpected error upon switching chains which may\n     * be a confusing user experience (e.g. the user will not know they have to reconnect\n     * unless the dapp handles these types of errors).\n     *\n     * If `false`, the new chain will be treated as a validated chain. This means that if the user\n     * has yet to establish a relationship with the chain in their WalletConnect session, wagmi will successfully\n     * auto-connect the user. This comes with the trade-off that the connector will throw an error\n     * when attempting to switch to the unapproved chain. This may be useful in cases where a dapp constantly\n     * modifies their configured chains, and they do not want to disconnect the user upon\n     * auto-connecting. If the user decides to switch to the unapproved chain, it is important that the\n     * dapp handles this error and prompts the user to reconnect to the dapp in order to approve\n     * the newly added chain.\n     *\n     * @default true\n     */\n    isNewChainsStale?: boolean\n  } & Omit<\n    EthereumProviderOptions,\n    | 'chains'\n    | 'events'\n    | 'optionalChains'\n    | 'optionalEvents'\n    | 'optionalMethods'\n    | 'methods'\n    | 'rpcMap'\n    | 'showQrModal'\n  > &\n    ExactPartial<Pick<EthereumProviderOptions, 'showQrModal'>>\n>\n\nwalletConnect.type = 'walletConnect' as const\nexport function walletConnect(parameters: WalletConnectParameters) {\n  const isNewChainsStale = parameters.isNewChainsStale ?? true\n\n  type Provider = Awaited<ReturnType<typeof EthereumProvider['init']>>\n  type NamespaceMethods =\n    | 'wallet_addEthereumChain'\n    | 'wallet_switchEthereumChain'\n  type Properties = {\n    connect(parameters?: { chainId?: number; pairingTopic?: string }): Promise<{\n      accounts: readonly Address[]\n      chainId: number\n    }>\n    getNamespaceChainsIds(): number[]\n    getNamespaceMethods(): NamespaceMethods[]\n    getRequestedChainsIds(): Promise<number[]>\n    isChainsStale(): Promise<boolean>\n    onConnect(connectInfo: ProviderConnectInfo): void\n    onDisplayUri(uri: string): void\n    onSessionDelete(data: { topic: string }): void\n    setRequestedChainsIds(chains: number[]): void\n    requestedChainsStorageKey: `${string}.requestedChains`\n  }\n  type StorageItem = {\n    [_ in Properties['requestedChainsStorageKey']]: number[]\n  }\n\n  let provider_: Provider | undefined\n  let providerPromise: Promise<typeof provider_>\n  const NAMESPACE = 'eip155'\n\n  return createConnector<Provider, Properties, StorageItem>((config) => ({\n    id: 'walletConnect',\n    name: 'WalletConnect',\n    type: walletConnect.type,\n    async setup() {\n      const provider = await this.getProvider().catch(() => null)\n      if (!provider) return\n      provider.on('connect', this.onConnect.bind(this))\n      provider.on('session_delete', this.onSessionDelete.bind(this))\n    },\n    async connect({ chainId, ...rest } = {}) {\n      try {\n        const provider = await this.getProvider()\n        if (!provider) throw new ProviderNotFoundError()\n        provider.on('display_uri', this.onDisplayUri)\n\n        let targetChainId = chainId\n        if (!targetChainId) {\n          const state = (await config.storage?.getItem('state')) ?? {}\n          const isChainSupported = config.chains.some(\n            (x) => x.id === state.chainId,\n          )\n          if (isChainSupported) targetChainId = state.chainId\n          else targetChainId = config.chains[0]?.id\n        }\n        if (!targetChainId) throw new Error('No chains found on connector.')\n\n        const isChainsStale = await this.isChainsStale()\n        // If there is an active session with stale chains, disconnect current session.\n        if (provider.session && isChainsStale) await provider.disconnect()\n\n        // If there isn't an active session or chains are stale, connect.\n        if (!provider.session || isChainsStale) {\n          const optionalChains = config.chains\n            .filter((chain) => chain.id !== targetChainId)\n            .map((optionalChain) => optionalChain.id)\n          await provider.connect({\n            optionalChains: [targetChainId, ...optionalChains],\n            ...('pairingTopic' in rest\n              ? { pairingTopic: rest.pairingTopic }\n              : {}),\n          })\n\n          this.setRequestedChainsIds(config.chains.map((x) => x.id))\n        }\n\n        // If session exists and chains are authorized, enable provider for required chain\n        const accounts = (await provider.enable()).map((x) => getAddress(x))\n        const currentChainId = await this.getChainId()\n\n        provider.removeListener('display_uri', this.onDisplayUri)\n        provider.removeListener('connect', this.onConnect.bind(this))\n        provider.on('accountsChanged', this.onAccountsChanged.bind(this))\n        provider.on('chainChanged', this.onChainChanged)\n        provider.on('disconnect', this.onDisconnect.bind(this))\n        provider.on('session_delete', this.onSessionDelete.bind(this))\n\n        return { accounts, chainId: currentChainId }\n      } catch (error) {\n        if (\n          /(user rejected|connection request reset)/i.test(\n            (error as ProviderRpcError)?.message,\n          )\n        ) {\n          throw new UserRejectedRequestError(error as Error)\n        }\n        throw error\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider()\n      try {\n        await provider?.disconnect()\n      } catch (error) {\n        if (!/No matching key/i.test((error as Error).message)) throw error\n      } finally {\n        provider?.removeListener(\n          'accountsChanged',\n          this.onAccountsChanged.bind(this),\n        )\n        provider?.removeListener('chainChanged', this.onChainChanged)\n        provider?.removeListener('disconnect', this.onDisconnect.bind(this))\n        provider?.removeListener(\n          'session_delete',\n          this.onSessionDelete.bind(this),\n        )\n        provider?.on('connect', this.onConnect.bind(this))\n\n        this.setRequestedChainsIds([])\n      }\n    },\n    async getAccounts() {\n      const provider = await this.getProvider()\n      return provider.accounts.map((x) => getAddress(x))\n    },\n    async getProvider({ chainId } = {}) {\n      async function initProvider() {\n        const optionalChains = config.chains.map((x) => x.id) as [number]\n        if (!optionalChains.length) return\n        const { EthereumProvider } = await import(\n          '@walletconnect/ethereum-provider'\n        )\n        return await EthereumProvider.init({\n          ...parameters,\n          disableProviderPing: true,\n          optionalChains,\n          projectId: parameters.projectId,\n          rpcMap: Object.fromEntries(\n            config.chains.map((chain) => [\n              chain.id,\n              chain.rpcUrls.default.http[0]!,\n            ]),\n          ),\n          showQrModal: parameters.showQrModal ?? true,\n        })\n      }\n\n      if (!provider_) {\n        if (!providerPromise) providerPromise = initProvider()\n        provider_ = await providerPromise\n        provider_?.events.setMaxListeners(Infinity)\n      }\n      if (chainId) await this.switchChain?.({ chainId })\n      return provider_!\n    },\n    async getChainId() {\n      const provider = await this.getProvider()\n      return provider.chainId\n    },\n    async isAuthorized() {\n      try {\n        const [accounts, provider] = await Promise.all([\n          this.getAccounts(),\n          this.getProvider(),\n        ])\n\n        // If an account does not exist on the session, then the connector is unauthorized.\n        if (!accounts.length) return false\n\n        // If the chains are stale on the session, then the connector is unauthorized.\n        const isChainsStale = await this.isChainsStale()\n        if (isChainsStale && provider.session) {\n          await provider.disconnect().catch(() => {})\n          return false\n        }\n        return true\n      } catch {\n        return false\n      }\n    },\n    async switchChain({ chainId }) {\n      const chain = config.chains.find((chain) => chain.id === chainId)\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())\n\n      try {\n        const provider = await this.getProvider()\n        const namespaceChains = this.getNamespaceChainsIds()\n        const namespaceMethods = this.getNamespaceMethods()\n        const isChainApproved = namespaceChains.includes(chainId)\n\n        if (\n          !isChainApproved &&\n          namespaceMethods.includes('wallet_addEthereumChain')\n        ) {\n          await provider.request({\n            method: 'wallet_addEthereumChain',\n            params: [\n              {\n                chainId: numberToHex(chain.id),\n                blockExplorerUrls: [chain.blockExplorers?.default.url],\n                chainName: chain.name,\n                nativeCurrency: chain.nativeCurrency,\n                rpcUrls: [...chain.rpcUrls.default.http],\n              },\n            ],\n          })\n          const requestedChains = await this.getRequestedChainsIds()\n          this.setRequestedChainsIds([...requestedChains, chainId])\n        }\n\n        await provider.request({\n          method: 'wallet_switchEthereumChain',\n          params: [{ chainId: numberToHex(chainId) }],\n        })\n        return chain\n      } catch (error) {\n        const message =\n          typeof error === 'string'\n            ? error\n            : (error as ProviderRpcError)?.message\n        if (/user rejected request/i.test(message))\n          throw new UserRejectedRequestError(error as Error)\n        throw new SwitchChainError(error as Error)\n      }\n    },\n    onAccountsChanged(accounts) {\n      if (accounts.length === 0) this.onDisconnect()\n      else\n        config.emitter.emit('change', {\n          accounts: accounts.map((x) => getAddress(x)),\n        })\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain)\n      config.emitter.emit('change', { chainId })\n    },\n    async onConnect(connectInfo) {\n      const chainId = Number(connectInfo.chainId)\n      const accounts = await this.getAccounts()\n      config.emitter.emit('connect', { accounts, chainId })\n    },\n    async onDisconnect(_error) {\n      this.setRequestedChainsIds([])\n      config.emitter.emit('disconnect')\n\n      const provider = await this.getProvider()\n      provider.removeListener(\n        'accountsChanged',\n        this.onAccountsChanged.bind(this),\n      )\n      provider.removeListener('chainChanged', this.onChainChanged)\n      provider.removeListener('disconnect', this.onDisconnect.bind(this))\n      provider.removeListener('session_delete', this.onSessionDelete.bind(this))\n      provider.on('connect', this.onConnect.bind(this))\n    },\n    onDisplayUri(uri) {\n      config.emitter.emit('message', { type: 'display_uri', data: uri })\n    },\n    onSessionDelete() {\n      this.onDisconnect()\n    },\n    getNamespaceChainsIds() {\n      if (!provider_) return []\n      const chainIds = provider_.session?.namespaces[NAMESPACE]?.chains?.map(\n        (chain) => parseInt(chain.split(':')[1] || ''),\n      )\n      return chainIds ?? []\n    },\n    getNamespaceMethods() {\n      if (!provider_) return []\n      const methods = provider_.session?.namespaces[NAMESPACE]\n        ?.methods as NamespaceMethods[]\n      return methods ?? []\n    },\n    async getRequestedChainsIds() {\n      return (\n        (await config.storage?.getItem(this.requestedChainsStorageKey)) ?? []\n      )\n    },\n    /**\n     * Checks if the target chains match the chains that were\n     * initially requested by the connector for the WalletConnect session.\n     * If there is a mismatch, this means that the chains on the connector\n     * are considered stale, and need to be revalidated at a later point (via\n     * connection).\n     *\n     * There may be a scenario where a dapp adds a chain to the\n     * connector later on, however, this chain will not have been approved or rejected\n     * by the wallet. In this case, the chain is considered stale.\n     *\n     * There are exceptions however:\n     * -  If the wallet supports dynamic chain addition via `eth_addEthereumChain`,\n     *    then the chain is not considered stale.\n     * -  If the `isNewChainsStale` flag is falsy on the connector, then the chain is\n     *    not considered stale.\n     *\n     * For the above cases, chain validation occurs dynamically when the user\n     * attempts to switch chain.\n     *\n     * Also check that dapp supports at least 1 chain from previously approved session.\n     */\n    async isChainsStale() {\n      const namespaceMethods = this.getNamespaceMethods()\n      if (namespaceMethods.includes('wallet_addEthereumChain')) return false\n      if (!isNewChainsStale) return false\n\n      const connectorChains = config.chains.map((x) => x.id)\n      const namespaceChains = this.getNamespaceChainsIds()\n      if (\n        namespaceChains.length &&\n        !namespaceChains.some((id) => connectorChains.includes(id))\n      )\n        return false\n\n      const requestedChains = await this.getRequestedChainsIds()\n      return !connectorChains.every((id) => requestedChains.includes(id))\n    },\n    async setRequestedChainsIds(chains) {\n      await config.storage?.setItem(this.requestedChainsStorageKey, chains)\n    },\n    get requestedChainsStorageKey() {\n      return `${this.id}.requestedChains` as Properties['requestedChainsStorageKey']\n    },\n  }))\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}