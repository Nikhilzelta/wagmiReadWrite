{"ast":null,"code":"import { EventType } from '@metamask/sdk';\nimport { ChainNotConfiguredError, createConnector } from '@wagmi/core';\nimport { ResourceUnavailableRpcError, RpcError, SwitchChainError, UserRejectedRequestError, getAddress, numberToHex } from 'viem';\nmetaMask.type = 'metaMask';\n/**\n * @deprecated\n *\n * __Warning__ This connector has a large file size due to the underlying `@metamask/sdk`. For mobile\n * support, it is recommended to use {@link walletConnect}. For desktop support, you should rely on Multi Injected\n * Provider Discovery (EIP-6963) via the Wagmi {@link Config}.\n */\nexport function metaMask(parameters = {}) {\n  let sdk;\n  let walletProvider;\n  return createConnector(config => ({\n    id: 'metaMaskSDK',\n    name: 'MetaMask',\n    type: metaMask.type,\n    async setup() {\n      const provider = await this.getProvider();\n      if (provider) provider.on('connect', this.onConnect.bind(this));\n    },\n    async connect({\n      chainId,\n      isReconnecting\n    } = {}) {\n      const provider = await this.getProvider();\n      let accounts = null;\n      if (!isReconnecting) {\n        accounts = await this.getAccounts().catch(() => null);\n        const isAuthorized = !!accounts?.length;\n        if (isAuthorized)\n          // Attempt to show another prompt for selecting account if already connected\n          try {\n            const permissions = await provider.request({\n              method: 'wallet_requestPermissions',\n              params: [{\n                eth_accounts: {}\n              }]\n            });\n            accounts = permissions[0]?.caveats?.[0]?.value?.map(x => getAddress(x));\n          } catch (err) {\n            const error = err;\n            // Not all injected providers support `wallet_requestPermissions` (e.g. MetaMask iOS).\n            // Only bubble up error if user rejects request\n            if (error.code === UserRejectedRequestError.code) throw new UserRejectedRequestError(error);\n            // Or prompt is already open\n            if (error.code === ResourceUnavailableRpcError.code) throw error;\n          }\n      }\n      try {\n        if (!accounts?.length) {\n          const requestedAccounts = await sdk.connect();\n          accounts = requestedAccounts.map(x => getAddress(x));\n        }\n        provider.removeListener('connect', this.onConnect.bind(this));\n        provider.on('accountsChanged', this.onAccountsChanged.bind(this));\n        provider.on('chainChanged', this.onChainChanged);\n        provider.on('disconnect', this.onDisconnect.bind(this));\n        // Backward compatibility with older wallet (<7.3) version that return accounts before authorization\n        if (!sdk.isExtensionActive() && !sdk._getConnection()?.isAuthorized()) {\n          function waitForAuthorized() {\n            return new Promise(resolve => {\n              const connection = sdk._getConnection();\n              const connector = connection?.getConnector();\n              connector?.once(EventType.AUTHORIZED, () => resolve(true));\n            });\n          }\n          await waitForAuthorized();\n        }\n        // Switch to chain if provided\n        let currentChainId = await this.getChainId();\n        if (chainId && currentChainId !== chainId) {\n          const chain = await this.switchChain({\n            chainId\n          }).catch(error => {\n            if (error.code === UserRejectedRequestError.code) throw error;\n            return {\n              id: currentChainId\n            };\n          });\n          currentChainId = chain?.id ?? currentChainId;\n        }\n        await config.storage?.removeItem('metaMaskSDK.disconnected');\n        return {\n          accounts,\n          chainId: currentChainId\n        };\n      } catch (err) {\n        const error = err;\n        if (error.code === UserRejectedRequestError.code) throw new UserRejectedRequestError(error);\n        if (error.code === ResourceUnavailableRpcError.code) throw new ResourceUnavailableRpcError(error);\n        throw error;\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider();\n      provider.removeListener('accountsChanged', this.onAccountsChanged.bind(this));\n      provider.removeListener('chainChanged', this.onChainChanged);\n      provider.removeListener('disconnect', this.onDisconnect.bind(this));\n      provider.on('connect', this.onConnect.bind(this));\n      sdk.terminate();\n      // Add shim signalling connector is disconnected\n      await config.storage?.setItem('metaMaskSDK.disconnected', true);\n    },\n    async getAccounts() {\n      const provider = await this.getProvider();\n      const accounts = await provider.request({\n        method: 'eth_accounts'\n      });\n      return accounts.map(x => getAddress(x));\n    },\n    async getChainId() {\n      const provider = await this.getProvider();\n      const chainId = provider.chainId ?? (await provider?.request({\n        method: 'eth_chainId'\n      }));\n      return Number(chainId);\n    },\n    async getProvider() {\n      if (!walletProvider) {\n        if (!sdk || !sdk?.isInitialized()) {\n          const {\n            MetaMaskSDK\n          } = await import('@metamask/sdk');\n          sdk = new MetaMaskSDK({\n            dappMetadata: {\n              name: 'wagmi'\n            },\n            enableAnalytics: false,\n            extensionOnly: true,\n            modals: {\n              // Disable by default since it pops up when mobile tries to reconnect\n              otp() {\n                const noop = () => {};\n                return {\n                  mount: noop,\n                  unmount: noop\n                };\n              }\n            },\n            useDeeplink: true,\n            _source: 'wagmi',\n            ...parameters,\n            checkInstallationImmediately: false,\n            checkInstallationOnAllCalls: false\n          });\n          await sdk.init();\n        }\n        try {\n          walletProvider = sdk.getProvider();\n        } catch (error) {\n          // TODO: SDK sometimes throws errors when MM extension or mobile provider is not detected (don't throw for those errors)\n          const regex = /^SDK state invalid -- undefined( mobile)? provider$/;\n          if (!regex.test(error.message)) throw error;\n        }\n      }\n      return walletProvider;\n    },\n    async isAuthorized() {\n      try {\n        const isDisconnected =\n        // If shim exists in storage, connector is disconnected\n        await config.storage?.getItem('metaMaskSDK.disconnected');\n        if (isDisconnected) return false;\n        const accounts = await this.getAccounts();\n        return !!accounts.length;\n      } catch {\n        return false;\n      }\n    },\n    async switchChain({\n      chainId\n    }) {\n      const provider = await this.getProvider();\n      const chain = config.chains.find(x => x.id === chainId);\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError());\n      try {\n        await Promise.all([provider.request({\n          method: 'wallet_switchEthereumChain',\n          params: [{\n            chainId: numberToHex(chainId)\n          }]\n        }), new Promise(resolve => config.emitter.once('change', ({\n          chainId: currentChainId\n        }) => {\n          if (currentChainId === chainId) resolve();\n        }))]);\n        return chain;\n      } catch (err) {\n        const error = err;\n        // Indicates chain is not added to provider\n        if (error.code === 4902 ||\n        // Unwrapping for MetaMask Mobile\n        // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719\n        error?.data?.originalError?.code === 4902) {\n          try {\n            const {\n              default: blockExplorer,\n              ...blockExplorers\n            } = chain.blockExplorers ?? {};\n            let blockExplorerUrls;\n            if (blockExplorer) blockExplorerUrls = [blockExplorer.url, ...Object.values(blockExplorers).map(x => x.url)];\n            await provider.request({\n              method: 'wallet_addEthereumChain',\n              params: [{\n                chainId: numberToHex(chainId),\n                chainName: chain.name,\n                nativeCurrency: chain.nativeCurrency,\n                rpcUrls: [chain.rpcUrls.default?.http[0] ?? ''],\n                blockExplorerUrls\n              }]\n            });\n            const currentChainId = await this.getChainId();\n            if (currentChainId !== chainId) throw new UserRejectedRequestError(new Error('User rejected switch after adding network.'));\n            return chain;\n          } catch (error) {\n            throw new UserRejectedRequestError(error);\n          }\n        }\n        if (error.code === UserRejectedRequestError.code) throw new UserRejectedRequestError(error);\n        throw new SwitchChainError(error);\n      }\n    },\n    async onAccountsChanged(accounts) {\n      // Disconnect if there are no accounts\n      if (accounts.length === 0) this.onDisconnect();\n      // Connect if emitter is listening for connect event (e.g. is disconnected and connects through wallet interface)\n      else if (config.emitter.listenerCount('connect')) {\n        const chainId = (await this.getChainId()).toString();\n        this.onConnect({\n          chainId\n        });\n        await config.storage?.removeItem('metaMaskSDK.disconnected');\n      }\n      // Regular change event\n      else config.emitter.emit('change', {\n        accounts: accounts.map(x => getAddress(x))\n      });\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain);\n      config.emitter.emit('change', {\n        chainId\n      });\n    },\n    async onConnect(connectInfo) {\n      const accounts = await this.getAccounts();\n      if (accounts.length === 0) return;\n      const chainId = Number(connectInfo.chainId);\n      config.emitter.emit('connect', {\n        accounts,\n        chainId\n      });\n      const provider = await this.getProvider();\n      if (provider) {\n        provider.removeListener('connect', this.onConnect.bind(this));\n        provider.on('accountsChanged', this.onAccountsChanged.bind(this));\n        provider.on('chainChanged', this.onChainChanged);\n        provider.on('disconnect', this.onDisconnect.bind(this));\n      }\n    },\n    async onDisconnect(error) {\n      const provider = await this.getProvider();\n      // If MetaMask emits a `code: 1013` error, wait for reconnection before disconnecting\n      // https://github.com/MetaMask/providers/pull/120\n      if (error && error.code === 1013) {\n        if (provider && !!(await this.getAccounts()).length) return;\n      }\n      // No need to remove 'metaMaskSDK.disconnected' from storage because `onDisconnect` is typically\n      // only called when the wallet is disconnected through the wallet's interface, meaning the wallet\n      // actually disconnected and we don't need to simulate it.\n      config.emitter.emit('disconnect');\n      provider.removeListener('accountsChanged', this.onAccountsChanged.bind(this));\n      provider.removeListener('chainChanged', this.onChainChanged);\n      provider.removeListener('disconnect', this.onDisconnect.bind(this));\n      provider.on('connect', this.onConnect.bind(this));\n    }\n  }));\n}","map":{"version":3,"names":["EventType","ChainNotConfiguredError","createConnector","ResourceUnavailableRpcError","RpcError","SwitchChainError","UserRejectedRequestError","getAddress","numberToHex","metaMask","type","parameters","sdk","walletProvider","config","id","name","setup","provider","getProvider","on","onConnect","bind","connect","chainId","isReconnecting","accounts","getAccounts","catch","isAuthorized","length","permissions","request","method","params","eth_accounts","caveats","value","map","x","err","error","code","requestedAccounts","removeListener","onAccountsChanged","onChainChanged","onDisconnect","isExtensionActive","_getConnection","waitForAuthorized","Promise","resolve","connection","connector","getConnector","once","AUTHORIZED","currentChainId","getChainId","chain","switchChain","storage","removeItem","disconnect","terminate","setItem","Number","isInitialized","MetaMaskSDK","dappMetadata","enableAnalytics","extensionOnly","modals","otp","noop","mount","unmount","useDeeplink","_source","checkInstallationImmediately","checkInstallationOnAllCalls","init","regex","test","message","isDisconnected","getItem","chains","find","all","emitter","data","originalError","default","blockExplorer","blockExplorers","blockExplorerUrls","url","Object","values","chainName","nativeCurrency","rpcUrls","http","Error","listenerCount","toString","emit","connectInfo"],"sources":["/Users/nikhilbhatia/NIkhil/ZT-Prejects/wagmi-react-app/node_modules/wagmi/node_modules/@wagmi/connectors/src/metaMask.ts"],"sourcesContent":["import {\n  EventType,\n  type MetaMaskSDK,\n  type MetaMaskSDKOptions,\n  type SDKProvider,\n} from '@metamask/sdk'\nimport { ChainNotConfiguredError, createConnector } from '@wagmi/core'\nimport type { Evaluate, ExactPartial, Omit } from '@wagmi/core/internal'\nimport {\n  type Address,\n  type ProviderConnectInfo,\n  type ProviderRpcError,\n  ResourceUnavailableRpcError,\n  RpcError,\n  SwitchChainError,\n  UserRejectedRequestError,\n  type WalletPermission,\n  getAddress,\n  numberToHex,\n} from 'viem'\n\nexport type MetaMaskParameters = Evaluate<\n  ExactPartial<\n    Omit<\n      MetaMaskSDKOptions,\n      | 'checkInstallationImmediately'\n      | 'checkInstallationOnAllCalls'\n      | 'defaultReadOnlyChainId'\n      | 'readonlyRPCMap'\n    >\n  >\n>\n\nmetaMask.type = 'metaMask' as const\n/**\n * @deprecated\n *\n * __Warning__ This connector has a large file size due to the underlying `@metamask/sdk`. For mobile\n * support, it is recommended to use {@link walletConnect}. For desktop support, you should rely on Multi Injected\n * Provider Discovery (EIP-6963) via the Wagmi {@link Config}.\n */\nexport function metaMask(parameters: MetaMaskParameters = {}) {\n  type Provider = SDKProvider\n  type Properties = {\n    onConnect(connectInfo: ProviderConnectInfo): void\n  }\n  type StorageItem = { 'metaMaskSDK.disconnected': true }\n  type Listener = Parameters<Provider['on']>[1]\n\n  let sdk: MetaMaskSDK\n  let walletProvider: Provider | undefined\n\n  return createConnector<Provider, Properties, StorageItem>((config) => ({\n    id: 'metaMaskSDK',\n    name: 'MetaMask',\n    type: metaMask.type,\n    async setup() {\n      const provider = await this.getProvider()\n      if (provider)\n        provider.on('connect', this.onConnect.bind(this) as Listener)\n    },\n    async connect({ chainId, isReconnecting } = {}) {\n      const provider = await this.getProvider()\n\n      let accounts: readonly Address[] | null = null\n      if (!isReconnecting) {\n        accounts = await this.getAccounts().catch(() => null)\n        const isAuthorized = !!accounts?.length\n        if (isAuthorized)\n          // Attempt to show another prompt for selecting account if already connected\n          try {\n            const permissions = (await provider.request({\n              method: 'wallet_requestPermissions',\n              params: [{ eth_accounts: {} }],\n            })) as WalletPermission[]\n            accounts = (permissions[0]?.caveats?.[0]?.value as string[])?.map(\n              (x) => getAddress(x),\n            )\n          } catch (err) {\n            const error = err as RpcError\n            // Not all injected providers support `wallet_requestPermissions` (e.g. MetaMask iOS).\n            // Only bubble up error if user rejects request\n            if (error.code === UserRejectedRequestError.code)\n              throw new UserRejectedRequestError(error)\n            // Or prompt is already open\n            if (error.code === ResourceUnavailableRpcError.code) throw error\n          }\n      }\n\n      try {\n        if (!accounts?.length) {\n          const requestedAccounts = (await sdk.connect()) as string[]\n          accounts = requestedAccounts.map((x) => getAddress(x))\n        }\n\n        provider.removeListener(\n          'connect',\n          this.onConnect.bind(this) as Listener,\n        )\n        provider.on(\n          'accountsChanged',\n          this.onAccountsChanged.bind(this) as Listener,\n        )\n        provider.on('chainChanged', this.onChainChanged as Listener)\n        provider.on('disconnect', this.onDisconnect.bind(this) as Listener)\n\n        // Backward compatibility with older wallet (<7.3) version that return accounts before authorization\n        if (!sdk.isExtensionActive() && !sdk._getConnection()?.isAuthorized()) {\n          function waitForAuthorized() {\n            return new Promise((resolve) => {\n              const connection = sdk._getConnection()\n              const connector = connection?.getConnector()\n              connector?.once(EventType.AUTHORIZED, () => resolve(true))\n            })\n          }\n          await waitForAuthorized()\n        }\n\n        // Switch to chain if provided\n        let currentChainId = await this.getChainId()\n        if (chainId && currentChainId !== chainId) {\n          const chain = await this.switchChain!({ chainId }).catch((error) => {\n            if (error.code === UserRejectedRequestError.code) throw error\n            return { id: currentChainId }\n          })\n          currentChainId = chain?.id ?? currentChainId\n        }\n\n        await config.storage?.removeItem('metaMaskSDK.disconnected')\n\n        return { accounts, chainId: currentChainId }\n      } catch (err) {\n        const error = err as RpcError\n        if (error.code === UserRejectedRequestError.code)\n          throw new UserRejectedRequestError(error)\n        if (error.code === ResourceUnavailableRpcError.code)\n          throw new ResourceUnavailableRpcError(error)\n        throw error\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider()\n\n      provider.removeListener(\n        'accountsChanged',\n        this.onAccountsChanged.bind(this),\n      )\n      provider.removeListener('chainChanged', this.onChainChanged)\n      provider.removeListener('disconnect', this.onDisconnect.bind(this))\n      provider.on('connect', this.onConnect.bind(this) as Listener)\n\n      sdk.terminate()\n\n      // Add shim signalling connector is disconnected\n      await config.storage?.setItem('metaMaskSDK.disconnected', true)\n    },\n    async getAccounts() {\n      const provider = await this.getProvider()\n      const accounts = (await provider.request({\n        method: 'eth_accounts',\n      })) as string[]\n      return accounts.map((x) => getAddress(x))\n    },\n    async getChainId() {\n      const provider = await this.getProvider()\n      const chainId =\n        provider.chainId ?? (await provider?.request({ method: 'eth_chainId' }))\n      return Number(chainId)\n    },\n    async getProvider() {\n      if (!walletProvider) {\n        if (!sdk || !sdk?.isInitialized()) {\n          const { MetaMaskSDK } = await import('@metamask/sdk')\n          sdk = new MetaMaskSDK({\n            dappMetadata: { name: 'wagmi' },\n            enableAnalytics: false,\n            extensionOnly: true,\n            modals: {\n              // Disable by default since it pops up when mobile tries to reconnect\n              otp() {\n                const noop = () => {}\n                return { mount: noop, unmount: noop }\n              },\n            },\n            useDeeplink: true,\n            _source: 'wagmi',\n            ...parameters,\n            checkInstallationImmediately: false,\n            checkInstallationOnAllCalls: false,\n          })\n          await sdk.init()\n        }\n        try {\n          walletProvider = sdk.getProvider()\n        } catch (error) {\n          // TODO: SDK sometimes throws errors when MM extension or mobile provider is not detected (don't throw for those errors)\n          const regex = /^SDK state invalid -- undefined( mobile)? provider$/\n          if (!regex.test((error as Error).message)) throw error\n        }\n      }\n      return walletProvider!\n    },\n    async isAuthorized() {\n      try {\n        const isDisconnected =\n          // If shim exists in storage, connector is disconnected\n          await config.storage?.getItem('metaMaskSDK.disconnected')\n        if (isDisconnected) return false\n\n        const accounts = await this.getAccounts()\n        return !!accounts.length\n      } catch {\n        return false\n      }\n    },\n    async switchChain({ chainId }) {\n      const provider = await this.getProvider()\n\n      const chain = config.chains.find((x) => x.id === chainId)\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())\n\n      try {\n        await Promise.all([\n          provider.request({\n            method: 'wallet_switchEthereumChain',\n            params: [{ chainId: numberToHex(chainId) }],\n          }),\n          new Promise<void>((resolve) =>\n            config.emitter.once('change', ({ chainId: currentChainId }) => {\n              if (currentChainId === chainId) resolve()\n            }),\n          ),\n        ])\n        return chain\n      } catch (err) {\n        const error = err as RpcError\n\n        // Indicates chain is not added to provider\n        if (\n          error.code === 4902 ||\n          // Unwrapping for MetaMask Mobile\n          // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719\n          (error as ProviderRpcError<{ originalError?: { code: number } }>)\n            ?.data?.originalError?.code === 4902\n        ) {\n          try {\n            const { default: blockExplorer, ...blockExplorers } =\n              chain.blockExplorers ?? {}\n            let blockExplorerUrls\n            if (blockExplorer)\n              blockExplorerUrls = [\n                blockExplorer.url,\n                ...Object.values(blockExplorers).map((x) => x.url),\n              ]\n\n            await provider.request({\n              method: 'wallet_addEthereumChain',\n              params: [\n                {\n                  chainId: numberToHex(chainId),\n                  chainName: chain.name,\n                  nativeCurrency: chain.nativeCurrency,\n                  rpcUrls: [chain.rpcUrls.default?.http[0] ?? ''],\n                  blockExplorerUrls,\n                },\n              ],\n            })\n\n            const currentChainId = await this.getChainId()\n            if (currentChainId !== chainId)\n              throw new UserRejectedRequestError(\n                new Error('User rejected switch after adding network.'),\n              )\n\n            return chain\n          } catch (error) {\n            throw new UserRejectedRequestError(error as Error)\n          }\n        }\n\n        if (error.code === UserRejectedRequestError.code)\n          throw new UserRejectedRequestError(error)\n        throw new SwitchChainError(error)\n      }\n    },\n    async onAccountsChanged(accounts) {\n      // Disconnect if there are no accounts\n      if (accounts.length === 0) this.onDisconnect()\n      // Connect if emitter is listening for connect event (e.g. is disconnected and connects through wallet interface)\n      else if (config.emitter.listenerCount('connect')) {\n        const chainId = (await this.getChainId()).toString()\n        this.onConnect({ chainId })\n        await config.storage?.removeItem('metaMaskSDK.disconnected')\n      }\n      // Regular change event\n      else\n        config.emitter.emit('change', {\n          accounts: accounts.map((x) => getAddress(x)),\n        })\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain)\n      config.emitter.emit('change', { chainId })\n    },\n    async onConnect(connectInfo) {\n      const accounts = await this.getAccounts()\n      if (accounts.length === 0) return\n\n      const chainId = Number(connectInfo.chainId)\n      config.emitter.emit('connect', { accounts, chainId })\n\n      const provider = await this.getProvider()\n      if (provider) {\n        provider.removeListener('connect', this.onConnect.bind(this))\n        provider.on('accountsChanged', this.onAccountsChanged.bind(this) as any)\n        provider.on('chainChanged', this.onChainChanged as any)\n        provider.on('disconnect', this.onDisconnect.bind(this) as any)\n      }\n    },\n    async onDisconnect(error) {\n      const provider = await this.getProvider()\n\n      // If MetaMask emits a `code: 1013` error, wait for reconnection before disconnecting\n      // https://github.com/MetaMask/providers/pull/120\n      if (error && (error as RpcError<1013>).code === 1013) {\n        if (provider && !!(await this.getAccounts()).length) return\n      }\n\n      // No need to remove 'metaMaskSDK.disconnected' from storage because `onDisconnect` is typically\n      // only called when the wallet is disconnected through the wallet's interface, meaning the wallet\n      // actually disconnected and we don't need to simulate it.\n      config.emitter.emit('disconnect')\n\n      provider.removeListener(\n        'accountsChanged',\n        this.onAccountsChanged.bind(this),\n      )\n      provider.removeListener('chainChanged', this.onChainChanged)\n      provider.removeListener('disconnect', this.onDisconnect.bind(this))\n      provider.on('connect', this.onConnect.bind(this) as any)\n    },\n  }))\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}