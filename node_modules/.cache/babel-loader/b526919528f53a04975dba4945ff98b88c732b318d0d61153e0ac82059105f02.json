{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.watchEvent = void 0;\nconst observe_js_1 = require(\"../../utils/observe.js\");\nconst poll_js_1 = require(\"../../utils/poll.js\");\nconst stringify_js_1 = require(\"../../utils/stringify.js\");\nconst abi_js_1 = require(\"../../errors/abi.js\");\nconst rpc_js_1 = require(\"../../errors/rpc.js\");\nconst getAction_js_1 = require(\"../../utils/getAction.js\");\nconst index_js_1 = require(\"../../utils/index.js\");\nconst createEventFilter_js_1 = require(\"./createEventFilter.js\");\nconst getBlockNumber_js_1 = require(\"./getBlockNumber.js\");\nconst getFilterChanges_js_1 = require(\"./getFilterChanges.js\");\nconst getLogs_js_1 = require(\"./getLogs.js\");\nconst uninstallFilter_js_1 = require(\"./uninstallFilter.js\");\nfunction watchEvent(client, {\n  address,\n  args,\n  batch = true,\n  event,\n  events,\n  onError,\n  onLogs,\n  poll: poll_,\n  pollingInterval = client.pollingInterval,\n  strict: strict_\n}) {\n  const enablePolling = typeof poll_ !== 'undefined' ? poll_ : client.transport.type !== 'webSocket';\n  const strict = strict_ ?? false;\n  const pollEvent = () => {\n    const observerId = (0, stringify_js_1.stringify)(['watchEvent', address, args, batch, client.uid, event, pollingInterval]);\n    return (0, observe_js_1.observe)(observerId, {\n      onLogs,\n      onError\n    }, emit => {\n      let previousBlockNumber;\n      let filter;\n      let initialized = false;\n      const unwatch = (0, poll_js_1.poll)(async () => {\n        if (!initialized) {\n          try {\n            filter = await (0, getAction_js_1.getAction)(client, createEventFilter_js_1.createEventFilter, 'createEventFilter')({\n              address,\n              args,\n              event: event,\n              events,\n              strict\n            });\n          } catch {}\n          initialized = true;\n          return;\n        }\n        try {\n          let logs;\n          if (filter) {\n            logs = await (0, getAction_js_1.getAction)(client, getFilterChanges_js_1.getFilterChanges, 'getFilterChanges')({\n              filter\n            });\n          } else {\n            const blockNumber = await (0, getAction_js_1.getAction)(client, getBlockNumber_js_1.getBlockNumber, 'getBlockNumber')({});\n            if (previousBlockNumber && previousBlockNumber !== blockNumber) {\n              logs = await (0, getAction_js_1.getAction)(client, getLogs_js_1.getLogs, 'getLogs')({\n                address,\n                args,\n                event: event,\n                events,\n                fromBlock: previousBlockNumber + 1n,\n                toBlock: blockNumber\n              });\n            } else {\n              logs = [];\n            }\n            previousBlockNumber = blockNumber;\n          }\n          if (logs.length === 0) return;\n          if (batch) emit.onLogs(logs);else for (const log of logs) emit.onLogs([log]);\n        } catch (err) {\n          if (filter && err instanceof rpc_js_1.InvalidInputRpcError) initialized = false;\n          emit.onError?.(err);\n        }\n      }, {\n        emitOnBegin: true,\n        interval: pollingInterval\n      });\n      return async () => {\n        if (filter) await (0, getAction_js_1.getAction)(client, uninstallFilter_js_1.uninstallFilter, 'uninstallFilter')({\n          filter\n        });\n        unwatch();\n      };\n    });\n  };\n  const subscribeEvent = () => {\n    let active = true;\n    let unsubscribe = () => active = false;\n    (async () => {\n      try {\n        const events_ = events ?? (event ? [event] : undefined);\n        let topics = [];\n        if (events_) {\n          topics = [events_.flatMap(event => (0, index_js_1.encodeEventTopics)({\n            abi: [event],\n            eventName: event.name,\n            args\n          }))];\n          if (event) topics = topics[0];\n        }\n        const {\n          unsubscribe: unsubscribe_\n        } = await client.transport.subscribe({\n          params: ['logs', {\n            address,\n            topics\n          }],\n          onData(data) {\n            if (!active) return;\n            const log = data.result;\n            try {\n              const {\n                eventName,\n                args\n              } = (0, index_js_1.decodeEventLog)({\n                abi: events_,\n                data: log.data,\n                topics: log.topics,\n                strict\n              });\n              const formatted = (0, index_js_1.formatLog)(log, {\n                args,\n                eventName: eventName\n              });\n              onLogs([formatted]);\n            } catch (err) {\n              let eventName;\n              let isUnnamed;\n              if (err instanceof abi_js_1.DecodeLogDataMismatch || err instanceof abi_js_1.DecodeLogTopicsMismatch) {\n                if (strict_) return;\n                eventName = err.abiItem.name;\n                isUnnamed = err.abiItem.inputs?.some(x => !('name' in x && x.name));\n              }\n              const formatted = (0, index_js_1.formatLog)(log, {\n                args: isUnnamed ? [] : {},\n                eventName\n              });\n              onLogs([formatted]);\n            }\n          },\n          onError(error) {\n            onError?.(error);\n          }\n        });\n        unsubscribe = unsubscribe_;\n        if (!active) unsubscribe();\n      } catch (err) {\n        onError?.(err);\n      }\n    })();\n    return unsubscribe;\n  };\n  return enablePolling ? pollEvent() : subscribeEvent();\n}\nexports.watchEvent = watchEvent;","map":{"version":3,"names":["observe_js_1","require","poll_js_1","stringify_js_1","abi_js_1","rpc_js_1","getAction_js_1","index_js_1","createEventFilter_js_1","getBlockNumber_js_1","getFilterChanges_js_1","getLogs_js_1","uninstallFilter_js_1","watchEvent","client","address","args","batch","event","events","onError","onLogs","poll","poll_","pollingInterval","strict","strict_","enablePolling","transport","type","pollEvent","observerId","stringify","uid","observe","emit","previousBlockNumber","filter","initialized","unwatch","getAction","createEventFilter","logs","getFilterChanges","blockNumber","getBlockNumber","getLogs","fromBlock","toBlock","length","log","err","InvalidInputRpcError","emitOnBegin","interval","uninstallFilter","subscribeEvent","active","unsubscribe","events_","undefined","topics","flatMap","encodeEventTopics","abi","eventName","name","unsubscribe_","subscribe","params","onData","data","result","decodeEventLog","formatted","formatLog","isUnnamed","DecodeLogDataMismatch","DecodeLogTopicsMismatch","abiItem","inputs","some","x","error","exports"],"sources":["/Users/nikhilbhatia/NIkhil/ZT-Prejects/wagmi-react-app/node_modules/@safe-global/safe-apps-sdk/node_modules/viem/actions/public/watchEvent.ts"],"sourcesContent":["import type { Abi, AbiEvent, Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport type { Chain } from '../../types/chain.js'\nimport type {\n  MaybeAbiEventName,\n  MaybeExtractEventArgsFromAbi,\n} from '../../types/contract.js'\nimport type { Filter } from '../../types/filter.js'\nimport type { Log } from '../../types/log.js'\nimport type { LogTopic } from '../../types/misc.js'\nimport type { GetTransportConfig } from '../../types/transport.js'\nimport type { EncodeEventTopicsParameters } from '../../utils/index.js'\nimport { type ObserveErrorType, observe } from '../../utils/observe.js'\nimport { poll } from '../../utils/poll.js'\nimport { type StringifyErrorType, stringify } from '../../utils/stringify.js'\n\nimport {\n  DecodeLogDataMismatch,\n  DecodeLogTopicsMismatch,\n} from '../../errors/abi.js'\nimport { InvalidInputRpcError } from '../../errors/rpc.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport { getAction } from '../../utils/getAction.js'\nimport {\n  decodeEventLog,\n  encodeEventTopics,\n  formatLog,\n} from '../../utils/index.js'\nimport {\n  type CreateEventFilterParameters,\n  createEventFilter,\n} from './createEventFilter.js'\nimport { getBlockNumber } from './getBlockNumber.js'\nimport { getFilterChanges } from './getFilterChanges.js'\nimport { type GetLogsParameters, getLogs } from './getLogs.js'\nimport { uninstallFilter } from './uninstallFilter.js'\n\ntype PollOptions = {\n  /**\n   * Whether or not the transaction hashes should be batched on each invocation.\n   * @default true\n   */\n  batch?: boolean\n  /**\n   * Polling frequency (in ms). Defaults to Client's pollingInterval config.\n   * @default client.pollingInterval\n   */\n  pollingInterval?: number\n}\n\nexport type WatchEventOnLogsParameter<\n  TAbiEvent extends AbiEvent | undefined = undefined,\n  TAbiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = TAbiEvent extends AbiEvent ? [TAbiEvent] : undefined,\n  TStrict extends boolean | undefined = undefined,\n  TEventName extends string | undefined = MaybeAbiEventName<TAbiEvent>,\n> = Log<bigint, number, false, TAbiEvent, TStrict, TAbiEvents, TEventName>[]\nexport type WatchEventOnLogsFn<\n  TAbiEvent extends AbiEvent | undefined = undefined,\n  TAbiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = TAbiEvent extends AbiEvent ? [TAbiEvent] : undefined,\n  TStrict extends boolean | undefined = undefined,\n  _EventName extends string | undefined = MaybeAbiEventName<TAbiEvent>,\n> = (\n  logs: WatchEventOnLogsParameter<TAbiEvent, TAbiEvents, TStrict, _EventName>,\n) => void\n\nexport type WatchEventParameters<\n  TAbiEvent extends AbiEvent | undefined = undefined,\n  TAbiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = TAbiEvent extends AbiEvent ? [TAbiEvent] : undefined,\n  TStrict extends boolean | undefined = undefined,\n  _EventName extends string | undefined = MaybeAbiEventName<TAbiEvent>,\n> = {\n  /** The address of the contract. */\n  address?: Address | Address[]\n  /** The callback to call when an error occurred when trying to get for a new block. */\n  onError?: (error: Error) => void\n  /** The callback to call when new event logs are received. */\n  onLogs: WatchEventOnLogsFn<TAbiEvent, TAbiEvents, TStrict, _EventName>\n} & (GetTransportConfig<Transport>['type'] extends 'webSocket'\n  ?\n      | {\n          batch?: never\n          /**\n           * Whether or not the WebSocket Transport should poll the JSON-RPC, rather than using `eth_subscribe`.\n           * @default false\n           */\n          poll?: false\n          pollingInterval?: never\n        }\n      | (PollOptions & {\n          /**\n           * Whether or not the WebSocket Transport should poll the JSON-RPC, rather than using `eth_subscribe`.\n           * @default true\n           */\n          poll?: true\n        })\n  : PollOptions & {\n      poll?: true\n    }) &\n  (\n    | {\n        event: TAbiEvent\n        events?: never\n        args?: MaybeExtractEventArgsFromAbi<TAbiEvents, _EventName>\n        /**\n         * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n         * @default false\n         */\n        strict?: TStrict\n      }\n    | {\n        event?: never\n        events?: TAbiEvents\n        args?: never\n        /**\n         * Whether or not the logs must match the indexed/non-indexed arguments on `event`.\n         * @default false\n         */\n        strict?: TStrict\n      }\n    | {\n        event?: never\n        events?: never\n        args?: never\n        strict?: never\n      }\n  )\n\nexport type WatchEventReturnType = () => void\n\nexport type WatchEventErrorType =\n  | StringifyErrorType\n  | ObserveErrorType\n  | ErrorType\n\n/**\n * Watches and returns emitted [Event Logs](https://viem.sh/docs/glossary/terms.html#event-log).\n *\n * - Docs: https://viem.sh/docs/actions/public/watchEvent.html\n * - JSON-RPC Methods:\n *   - **RPC Provider supports `eth_newFilter`:**\n *     - Calls [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) to create a filter (called on initialize).\n *     - On a polling interval, it will call [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges).\n *   - **RPC Provider does not support `eth_newFilter`:**\n *     - Calls [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) for each block between the polling interval.\n *\n * This Action will batch up all the Event Logs found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchEvent.html#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/actions/public/watchEvent.html#onLogs).\n *\n * `watchEvent` will attempt to create an [Event Filter](https://viem.sh/docs/actions/public/createEventFilter.html) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs.html) instead.\n *\n * @param client - Client to use\n * @param parameters - {@link WatchEventParameters}\n * @returns A function that can be invoked to stop watching for new Event Logs. {@link WatchEventReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { watchEvent } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const unwatch = watchEvent(client, {\n *   onLogs: (logs) => console.log(logs),\n * })\n */\nexport function watchEvent<\n  TChain extends Chain | undefined,\n  const TAbiEvent extends AbiEvent | undefined = undefined,\n  const TAbiEvents extends\n    | readonly AbiEvent[]\n    | readonly unknown[]\n    | undefined = TAbiEvent extends AbiEvent ? [TAbiEvent] : undefined,\n  TStrict extends boolean | undefined = undefined,\n  _EventName extends string | undefined = undefined,\n>(\n  client: Client<Transport, TChain>,\n  {\n    address,\n    args,\n    batch = true,\n    event,\n    events,\n    onError,\n    onLogs,\n    poll: poll_,\n    pollingInterval = client.pollingInterval,\n    strict: strict_,\n  }: WatchEventParameters<TAbiEvent, TAbiEvents, TStrict>,\n): WatchEventReturnType {\n  const enablePolling =\n    typeof poll_ !== 'undefined' ? poll_ : client.transport.type !== 'webSocket'\n  const strict = strict_ ?? false\n\n  const pollEvent = () => {\n    const observerId = stringify([\n      'watchEvent',\n      address,\n      args,\n      batch,\n      client.uid,\n      event,\n      pollingInterval,\n    ])\n\n    return observe(observerId, { onLogs, onError }, (emit) => {\n      let previousBlockNumber: bigint\n      let filter: Filter<'event', TAbiEvents, _EventName, any>\n      let initialized = false\n\n      const unwatch = poll(\n        async () => {\n          if (!initialized) {\n            try {\n              filter = (await getAction(\n                client,\n                createEventFilter as any,\n                'createEventFilter',\n              )({\n                address,\n                args,\n                event: event!,\n                events,\n                strict,\n              } as unknown as CreateEventFilterParameters)) as unknown as Filter<\n                'event',\n                TAbiEvents,\n                _EventName\n              >\n            } catch {}\n            initialized = true\n            return\n          }\n\n          try {\n            let logs: Log[]\n            if (filter) {\n              logs = await getAction(\n                client,\n                getFilterChanges,\n                'getFilterChanges',\n              )({ filter })\n            } else {\n              // If the filter doesn't exist, we will fall back to use `getLogs`.\n              // The fall back exists because some RPC Providers do not support filters.\n\n              // Fetch the block number to use for `getLogs`.\n              const blockNumber = await getAction(\n                client,\n                getBlockNumber,\n                'getBlockNumber',\n              )({})\n\n              // If the block number has changed, we will need to fetch the logs.\n              // If the block number doesn't exist, we are yet to reach the first poll interval,\n              // so do not emit any logs.\n              if (previousBlockNumber && previousBlockNumber !== blockNumber) {\n                logs = await getAction(\n                  client,\n                  getLogs,\n                  'getLogs',\n                )({\n                  address,\n                  args,\n                  event: event!,\n                  events,\n                  fromBlock: previousBlockNumber + 1n,\n                  toBlock: blockNumber,\n                } as unknown as GetLogsParameters)\n              } else {\n                logs = []\n              }\n              previousBlockNumber = blockNumber\n            }\n\n            if (logs.length === 0) return\n            if (batch) emit.onLogs(logs as any)\n            else for (const log of logs) emit.onLogs([log] as any)\n          } catch (err) {\n            // If a filter has been set and gets uninstalled, providers will throw an InvalidInput error.\n            // Reinitalize the filter when this occurs\n            if (filter && err instanceof InvalidInputRpcError)\n              initialized = false\n            emit.onError?.(err as Error)\n          }\n        },\n        {\n          emitOnBegin: true,\n          interval: pollingInterval,\n        },\n      )\n\n      return async () => {\n        if (filter)\n          await getAction(\n            client,\n            uninstallFilter,\n            'uninstallFilter',\n          )({ filter })\n        unwatch()\n      }\n    })\n  }\n\n  const subscribeEvent = () => {\n    let active = true\n    let unsubscribe = () => (active = false)\n    ;(async () => {\n      try {\n        const events_ = events ?? (event ? [event] : undefined)\n        let topics: LogTopic[] = []\n        if (events_) {\n          topics = [\n            (events_ as AbiEvent[]).flatMap((event) =>\n              encodeEventTopics({\n                abi: [event],\n                eventName: (event as AbiEvent).name,\n                args,\n              } as EncodeEventTopicsParameters),\n            ),\n          ]\n          if (event) topics = topics[0] as LogTopic[]\n        }\n\n        const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({\n          params: ['logs', { address, topics }],\n          onData(data: any) {\n            if (!active) return\n            const log = data.result\n            try {\n              const { eventName, args } = decodeEventLog({\n                abi: events_ as Abi,\n                data: log.data,\n                topics: log.topics as any,\n                strict,\n              })\n              const formatted = formatLog(log, {\n                args,\n                eventName: eventName as string,\n              })\n              onLogs([formatted] as any)\n            } catch (err) {\n              let eventName\n              let isUnnamed\n              if (\n                err instanceof DecodeLogDataMismatch ||\n                err instanceof DecodeLogTopicsMismatch\n              ) {\n                // If strict mode is on, and log data/topics do not match event definition, skip.\n                if (strict_) return\n                eventName = err.abiItem.name\n                isUnnamed = err.abiItem.inputs?.some(\n                  (x) => !('name' in x && x.name),\n                )\n              }\n\n              // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n              const formatted = formatLog(log, {\n                args: isUnnamed ? [] : {},\n                eventName,\n              })\n              onLogs([formatted] as any)\n            }\n          },\n          onError(error: Error) {\n            onError?.(error)\n          },\n        })\n        unsubscribe = unsubscribe_\n        if (!active) unsubscribe()\n      } catch (err) {\n        onError?.(err as Error)\n      }\n    })()\n    return unsubscribe\n  }\n\n  return enablePolling ? pollEvent() : subscribeEvent()\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}