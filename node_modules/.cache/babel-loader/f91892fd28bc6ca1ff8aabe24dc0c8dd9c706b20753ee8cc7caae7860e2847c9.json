{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.encodeEventTopics = void 0;\nconst abi_js_1 = require(\"../../errors/abi.js\");\nconst log_js_1 = require(\"../../errors/log.js\");\nconst toBytes_js_1 = require(\"../encoding/toBytes.js\");\nconst getEventSelector_js_1 = require(\"../hash/getEventSelector.js\");\nconst keccak256_js_1 = require(\"../hash/keccak256.js\");\nconst encodeAbiParameters_js_1 = require(\"./encodeAbiParameters.js\");\nconst formatAbiItem_js_1 = require(\"./formatAbiItem.js\");\nconst getAbiItem_js_1 = require(\"./getAbiItem.js\");\nfunction encodeEventTopics({\n  abi,\n  eventName,\n  args\n}) {\n  let abiItem = abi[0];\n  if (eventName) {\n    abiItem = (0, getAbiItem_js_1.getAbiItem)({\n      abi,\n      args,\n      name: eventName\n    });\n    if (!abiItem) throw new abi_js_1.AbiEventNotFoundError(eventName, {\n      docsPath: '/docs/contract/encodeEventTopics'\n    });\n  }\n  if (abiItem.type !== 'event') throw new abi_js_1.AbiEventNotFoundError(undefined, {\n    docsPath: '/docs/contract/encodeEventTopics'\n  });\n  const definition = (0, formatAbiItem_js_1.formatAbiItem)(abiItem);\n  const signature = (0, getEventSelector_js_1.getEventSelector)(definition);\n  let topics = [];\n  if (args && 'inputs' in abiItem) {\n    const indexedInputs = abiItem.inputs?.filter(param => 'indexed' in param && param.indexed);\n    const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? indexedInputs?.map(x => args[x.name]) ?? [] : [];\n    if (args_.length > 0) {\n      topics = indexedInputs?.map((param, i) => Array.isArray(args_[i]) ? args_[i].map((_, j) => encodeArg({\n        param,\n        value: args_[i][j]\n      })) : args_[i] ? encodeArg({\n        param,\n        value: args_[i]\n      }) : null) ?? [];\n    }\n  }\n  return [signature, ...topics];\n}\nexports.encodeEventTopics = encodeEventTopics;\nfunction encodeArg({\n  param,\n  value\n}) {\n  if (param.type === 'string' || param.type === 'bytes') return (0, keccak256_js_1.keccak256)((0, toBytes_js_1.toBytes)(value));\n  if (param.type === 'tuple' || param.type.match(/^(.*)\\[(\\d+)?\\]$/)) throw new log_js_1.FilterTypeNotSupportedError(param.type);\n  return (0, encodeAbiParameters_js_1.encodeAbiParameters)([param], [value]);\n}","map":{"version":3,"names":["abi_js_1","require","log_js_1","toBytes_js_1","getEventSelector_js_1","keccak256_js_1","encodeAbiParameters_js_1","formatAbiItem_js_1","getAbiItem_js_1","encodeEventTopics","abi","eventName","args","abiItem","getAbiItem","name","AbiEventNotFoundError","docsPath","type","undefined","definition","formatAbiItem","signature","getEventSelector","topics","indexedInputs","inputs","filter","param","indexed","args_","Array","isArray","Object","values","length","map","x","i","_","j","encodeArg","value","exports","keccak256","toBytes","match","FilterTypeNotSupportedError","encodeAbiParameters"],"sources":["/Users/nikhilbhatia/NIkhil/ZT-Prejects/wagmi-react-app/node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/abi/encodeEventTopics.ts"],"sourcesContent":["import type { Abi, AbiParameter, AbiParameterToPrimitiveType } from 'abitype'\n\nimport {\n  AbiEventNotFoundError,\n  type AbiEventNotFoundErrorType,\n} from '../../errors/abi.js'\nimport {\n  FilterTypeNotSupportedError,\n  type FilterTypeNotSupportedErrorType,\n} from '../../errors/log.js'\nimport type {\n  AbiItem,\n  EventDefinition,\n  GetEventArgs,\n  InferEventName,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport {\n  type GetEventSelectorErrorType,\n  getEventSelector,\n} from '../hash/getEventSelector.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from './encodeAbiParameters.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\nimport { type GetAbiItemParameters, getAbiItem } from './getAbiItem.js'\n\nexport type EncodeEventTopicsParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TEventName extends string | undefined = string,\n  _EventName = InferEventName<TAbi, TEventName>,\n> = {\n  eventName?: _EventName\n} & (TEventName extends string\n  ? { abi: TAbi; args?: GetEventArgs<TAbi, TEventName> }\n  : _EventName extends string\n    ? { abi: [TAbi[number]]; args?: GetEventArgs<TAbi, _EventName> }\n    : never)\n\nexport type EncodeEventTopicsErrorType =\n  | AbiEventNotFoundErrorType\n  | EncodeArgErrorType\n  | FormatAbiItemErrorType\n  | GetEventSelectorErrorType\n  | ErrorType\n\nexport function encodeEventTopics<\n  const TAbi extends Abi | readonly unknown[],\n  TEventName extends string | undefined = undefined,\n>({ abi, eventName, args }: EncodeEventTopicsParameters<TAbi, TEventName>) {\n  let abiItem = abi[0] as AbiItem\n  if (eventName) {\n    abiItem = getAbiItem({\n      abi,\n      args,\n      name: eventName,\n    } as GetAbiItemParameters)\n    if (!abiItem)\n      throw new AbiEventNotFoundError(eventName, {\n        docsPath: '/docs/contract/encodeEventTopics',\n      })\n  }\n\n  if (abiItem.type !== 'event')\n    throw new AbiEventNotFoundError(undefined, {\n      docsPath: '/docs/contract/encodeEventTopics',\n    })\n\n  const definition = formatAbiItem(abiItem)\n  const signature = getEventSelector(definition as EventDefinition)\n\n  let topics: Hex[] = []\n  if (args && 'inputs' in abiItem) {\n    const indexedInputs = abiItem.inputs?.filter(\n      (param) => 'indexed' in param && param.indexed,\n    )\n    const args_ = Array.isArray(args)\n      ? args\n      : Object.values(args).length > 0\n        ? indexedInputs?.map((x: any) => (args as any)[x.name]) ?? []\n        : []\n\n    if (args_.length > 0) {\n      topics =\n        indexedInputs?.map((param, i) =>\n          Array.isArray(args_[i])\n            ? args_[i].map((_: any, j: number) =>\n                encodeArg({ param, value: args_[i][j] }),\n              )\n            : args_[i]\n              ? encodeArg({ param, value: args_[i] })\n              : null,\n        ) ?? []\n    }\n  }\n  return [signature, ...topics]\n}\n\nexport type EncodeArgErrorType =\n  | Keccak256ErrorType\n  | ToBytesErrorType\n  | EncodeAbiParametersErrorType\n  | FilterTypeNotSupportedErrorType\n  | ErrorType\n\nfunction encodeArg({\n  param,\n  value,\n}: { param: AbiParameter; value: AbiParameterToPrimitiveType<AbiParameter> }) {\n  if (param.type === 'string' || param.type === 'bytes')\n    return keccak256(toBytes(value as string))\n  if (param.type === 'tuple' || param.type.match(/^(.*)\\[(\\d+)?\\]$/))\n    throw new FilterTypeNotSupportedError(param.type)\n  return encodeAbiParameters([param], [value])\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}