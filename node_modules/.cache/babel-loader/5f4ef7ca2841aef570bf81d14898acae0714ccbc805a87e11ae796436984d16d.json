{"ast":null,"code":"import './createConfig.js';\nimport './types/utils.js';\nimport { deserialize as deserialize_ } from './utils/deserialize.js';\nimport { serialize as serialize_ } from './utils/serialize.js';\nexport function createStorage(parameters) {\n  const {\n    deserialize = deserialize_,\n    key: prefix = 'wagmi',\n    serialize = serialize_,\n    storage = noopStorage\n  } = parameters;\n  function unwrap(value) {\n    if (value instanceof Promise) return value.then(x => x).catch(() => null);\n    return value;\n  }\n  return {\n    ...storage,\n    key: prefix,\n    async getItem(key, defaultValue) {\n      const value = storage.getItem(`${prefix}.${key}`);\n      const unwrapped = await unwrap(value);\n      if (unwrapped) return deserialize(unwrapped) ?? null;\n      return defaultValue ?? null;\n    },\n    async setItem(key, value) {\n      const storageKey = `${prefix}.${key}`;\n      if (value === null) await unwrap(storage.removeItem(storageKey));else await unwrap(storage.setItem(storageKey, serialize(value)));\n    },\n    async removeItem(key) {\n      await unwrap(storage.removeItem(`${prefix}.${key}`));\n    }\n  };\n}\nexport const noopStorage = {\n  getItem: () => null,\n  setItem: () => {},\n  removeItem: () => {}\n};","map":{"version":3,"names":["deserialize","deserialize_","serialize","serialize_","createStorage","parameters","key","prefix","storage","noopStorage","unwrap","value","Promise","then","x","catch","getItem","defaultValue","unwrapped","setItem","storageKey","removeItem"],"sources":["/Users/nikhilbhatia/NIkhil/ZT-Prejects/wagmi-react-app/node_modules/@wagmi/core/src/createStorage.ts"],"sourcesContent":["import { type PartializedState } from './createConfig.js'\nimport { type Evaluate } from './types/utils.js'\nimport { deserialize as deserialize_ } from './utils/deserialize.js'\nimport { serialize as serialize_ } from './utils/serialize.js'\n\n// key-values for loose autocomplete and typing\nexport type StorageItemMap = {\n  recentConnectorId: string\n  state: PartializedState\n}\n\nexport type Storage<\n  itemMap extends Record<string, unknown> = {},\n  ///\n  storageItemMap extends StorageItemMap = StorageItemMap & itemMap,\n> = {\n  key: string\n  getItem<\n    key extends keyof storageItemMap,\n    value extends storageItemMap[key],\n    defaultValue extends value | null | undefined,\n  >(\n    key: key,\n    defaultValue?: defaultValue | undefined,\n  ):\n    | (defaultValue extends null ? value | null : value)\n    | Promise<defaultValue extends null ? value | null : value>\n  setItem<\n    key extends keyof storageItemMap,\n    value extends storageItemMap[key] | null,\n  >(key: key, value: value): void | Promise<void>\n  removeItem(key: keyof storageItemMap): void | Promise<void>\n}\n\nexport type BaseStorage = {\n  getItem(\n    key: string,\n  ): string | null | undefined | Promise<string | null | undefined>\n  setItem(key: string, value: string): void | Promise<void>\n  removeItem(key: string): void | Promise<void>\n}\n\nexport type CreateStorageParameters = {\n  deserialize?: (<T>(value: string) => T) | undefined\n  key?: string | undefined\n  serialize?: (<T>(value: T) => string) | undefined\n  storage?: Evaluate<BaseStorage> | undefined\n}\n\nexport function createStorage<\n  itemMap extends Record<string, unknown> = {},\n  storageItemMap extends StorageItemMap = StorageItemMap & itemMap,\n>(parameters: CreateStorageParameters): Evaluate<Storage<storageItemMap>> {\n  const {\n    deserialize = deserialize_,\n    key: prefix = 'wagmi',\n    serialize = serialize_,\n    storage = noopStorage,\n  } = parameters\n\n  function unwrap<type>(value: type): type | Promise<type> {\n    if (value instanceof Promise) return value.then((x) => x).catch(() => null)\n    return value\n  }\n\n  return {\n    ...storage,\n    key: prefix,\n    async getItem(key, defaultValue) {\n      const value = storage.getItem(`${prefix}.${key as string}`)\n      const unwrapped = await unwrap(value)\n      if (unwrapped) return deserialize(unwrapped) ?? null\n      return (defaultValue ?? null) as any\n    },\n    async setItem(key, value) {\n      const storageKey = `${prefix}.${key as string}`\n      if (value === null) await unwrap(storage.removeItem(storageKey))\n      else await unwrap(storage.setItem(storageKey, serialize(value)))\n    },\n    async removeItem(key) {\n      await unwrap(storage.removeItem(`${prefix}.${key as string}`))\n    },\n  }\n}\n\nexport const noopStorage = {\n  getItem: () => null,\n  setItem: () => {},\n  removeItem: () => {},\n} satisfies BaseStorage\n"],"mappings":"AAAA,OAAsC,mBAAmB;AACzD,OAA8B,kBAAkB;AAChD,SAASA,WAAW,IAAIC,YAAY,QAAQ,wBAAwB;AACpE,SAASC,SAAS,IAAIC,UAAU,QAAQ,sBAAsB;AA8C9D,OAAM,SAAUC,aAAaA,CAG3BC,UAAmC;EACnC,MAAM;IACJL,WAAW,GAAGC,YAAY;IAC1BK,GAAG,EAAEC,MAAM,GAAG,OAAO;IACrBL,SAAS,GAAGC,UAAU;IACtBK,OAAO,GAAGC;EAAW,CACtB,GAAGJ,UAAU;EAEd,SAASK,MAAMA,CAAOC,KAAW;IAC/B,IAAIA,KAAK,YAAYC,OAAO,EAAE,OAAOD,KAAK,CAACE,IAAI,CAAEC,CAAC,IAAKA,CAAC,CAAC,CAACC,KAAK,CAAC,MAAM,IAAI,CAAC;IAC3E,OAAOJ,KAAK;EACd;EAEA,OAAO;IACL,GAAGH,OAAO;IACVF,GAAG,EAAEC,MAAM;IACX,MAAMS,OAAOA,CAACV,GAAG,EAAEW,YAAY;MAC7B,MAAMN,KAAK,GAAGH,OAAO,CAACQ,OAAO,CAAC,GAAGT,MAAM,IAAID,GAAa,EAAE,CAAC;MAC3D,MAAMY,SAAS,GAAG,MAAMR,MAAM,CAACC,KAAK,CAAC;MACrC,IAAIO,SAAS,EAAE,OAAOlB,WAAW,CAACkB,SAAS,CAAC,IAAI,IAAI;MACpD,OAAQD,YAAY,IAAI,IAAI;IAC9B,CAAC;IACD,MAAME,OAAOA,CAACb,GAAG,EAAEK,KAAK;MACtB,MAAMS,UAAU,GAAG,GAAGb,MAAM,IAAID,GAAa,EAAE;MAC/C,IAAIK,KAAK,KAAK,IAAI,EAAE,MAAMD,MAAM,CAACF,OAAO,CAACa,UAAU,CAACD,UAAU,CAAC,CAAC,MAC3D,MAAMV,MAAM,CAACF,OAAO,CAACW,OAAO,CAACC,UAAU,EAAElB,SAAS,CAACS,KAAK,CAAC,CAAC,CAAC;IAClE,CAAC;IACD,MAAMU,UAAUA,CAACf,GAAG;MAClB,MAAMI,MAAM,CAACF,OAAO,CAACa,UAAU,CAAC,GAAGd,MAAM,IAAID,GAAa,EAAE,CAAC,CAAC;IAChE;GACD;AACH;AAEA,OAAO,MAAMG,WAAW,GAAG;EACzBO,OAAO,EAAEA,CAAA,KAAM,IAAI;EACnBG,OAAO,EAAEA,CAAA,KAAK,CAAE,CAAC;EACjBE,UAAU,EAAEA,CAAA,KAAK,CAAE;CACE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}