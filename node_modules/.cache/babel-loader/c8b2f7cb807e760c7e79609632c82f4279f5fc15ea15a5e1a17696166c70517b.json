{"ast":null,"code":"import { createStore as createMipd } from 'mipd';\nimport { createClient } from 'viem';\nimport { persist, subscribeWithSelector } from 'zustand/middleware';\nimport { createStore } from 'zustand/vanilla';\nimport './connectors/createConnector.js';\nimport { injected } from './connectors/injected.js';\nimport { Emitter, createEmitter } from './createEmitter.js';\nimport { createStorage, noopStorage } from './createStorage.js';\nimport { ChainNotConfiguredError } from './errors/config.js';\nimport { uid } from './utils/uid.js';\nimport { version } from './version.js';\nexport function createConfig(parameters) {\n  const {\n    multiInjectedProviderDiscovery = true,\n    storage = createStorage({\n      storage: typeof window !== 'undefined' && window.localStorage ? window.localStorage : noopStorage\n    }),\n    syncConnectedChain = true,\n    ssr,\n    ...rest\n  } = parameters;\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Set up connectors, clients, etc.\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  const mipd = typeof window !== 'undefined' && multiInjectedProviderDiscovery ? createMipd() : undefined;\n  const chains = createStore(() => rest.chains);\n  const connectors = createStore(() => [...(rest.connectors ?? []), ...(!ssr ? mipd?.getProviders().map(providerDetailToConnector) ?? [] : [])].map(setup));\n  function setup(connectorFn) {\n    // Set up emitter with uid and add to connector so they are \"linked\" together.\n    const emitter = createEmitter(uid());\n    const connector = {\n      ...connectorFn({\n        emitter,\n        chains: chains.getState(),\n        storage\n      }),\n      emitter,\n      uid: emitter.uid\n    };\n    // Start listening for `connect` events on connector setup\n    // This allows connectors to \"connect\" themselves without user interaction (e.g. MetaMask's \"Manually connect to current site\")\n    emitter.on('connect', connect);\n    connector.setup?.();\n    return connector;\n  }\n  function providerDetailToConnector(providerDetail) {\n    const {\n      info\n    } = providerDetail;\n    const provider = providerDetail.provider;\n    return injected({\n      target: {\n        ...info,\n        id: info.rdns,\n        provider\n      }\n    });\n  }\n  const clients = new Map();\n  function getClient(config = {}) {\n    const chainId = config.chainId ?? store.getState().chainId;\n    const chain = chains.getState().find(x => x.id === chainId);\n    // chainId specified and not configured\n    if (config.chainId && !chain) throw new ChainNotConfiguredError();\n    {\n      const client = clients.get(store.getState().chainId);\n      if (client && !chain) return client;else if (!chain) throw new ChainNotConfiguredError();\n    }\n    // If a memoized client exists for a chain id, use that.\n    {\n      const client = clients.get(chainId);\n      if (client) return client;\n    }\n    let client;\n    if (rest.client) client = rest.client({\n      chain\n    });else {\n      const chainId = chain.id;\n      const chainIds = chains.getState().map(x => x.id);\n      // Grab all properties off `rest` and resolve for use in `createClient`\n      const properties = {};\n      const entries = Object.entries(rest);\n      for (const [key, value] of entries) {\n        if (key === 'chains' || key === 'client' || key === 'connectors' || key === 'transports') continue;else {\n          if (typeof value === 'object') {\n            // check if value is chainId-specific since some values can be objects\n            // e.g. { batch: { multicall: { batchSize: 1024 } } }\n            if (chainId in value) properties[key] = value[chainId];else {\n              // check if value is chainId-specific, but does not have value for current chainId\n              const hasChainSpecificValue = chainIds.some(x => x in value);\n              if (hasChainSpecificValue) continue;\n              properties[key] = value;\n            }\n          } else properties[key] = value;\n        }\n      }\n      client = createClient({\n        ...properties,\n        chain,\n        batch: properties.batch ?? {\n          multicall: true\n        },\n        transport: parameters => rest.transports[chainId]({\n          ...parameters,\n          connectors\n        })\n      });\n    }\n    clients.set(chainId, client);\n    return client;\n  }\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Create store\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  function getInitialState() {\n    return {\n      chainId: chains.getState()[0].id,\n      connections: new Map(),\n      current: undefined,\n      status: 'disconnected'\n    };\n  }\n  let currentVersion;\n  const prefix = '0.0.0-canary-';\n  if (version.startsWith(prefix)) currentVersion = parseInt(version.replace(prefix, ''));else currentVersion = parseInt(version.split('.')[0] ?? '0');\n  const store = createStore(subscribeWithSelector(\n  // only use persist middleware if storage exists\n  storage ? persist(getInitialState, {\n    migrate(persistedState, version) {\n      if (version === currentVersion) return persistedState;\n      const initialState = getInitialState();\n      const chainId = persistedState && typeof persistedState === 'object' && 'chainId' in persistedState && typeof persistedState.chainId === 'number' ? persistedState.chainId : initialState.chainId;\n      return {\n        ...initialState,\n        chainId\n      };\n    },\n    name: 'store',\n    partialize(state) {\n      // Only persist \"critical\" store properties to preserve storage size.\n      return {\n        connections: {\n          __type: 'Map',\n          value: Array.from(state.connections.entries()).map(([key, connection]) => {\n            const {\n              id,\n              name,\n              type,\n              uid\n            } = connection.connector;\n            const connector = {\n              id,\n              name,\n              type,\n              uid\n            };\n            return [key, {\n              ...connection,\n              connector\n            }];\n          })\n        },\n        chainId: state.chainId,\n        current: state.current\n      };\n    },\n    skipHydration: ssr,\n    storage: storage,\n    version: currentVersion\n  }) : getInitialState));\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Subscribe to changes\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Update default chain when connector chain changes\n  if (syncConnectedChain) store.subscribe(({\n    connections,\n    current\n  }) => current ? connections.get(current)?.chainId : undefined, chainId => {\n    // If chain is not configured, then don't switch over to it.\n    const isChainConfigured = chains.getState().some(x => x.id === chainId);\n    if (!isChainConfigured) return;\n    return store.setState(x => ({\n      ...x,\n      chainId: chainId ?? x.chainId\n    }));\n  });\n  // EIP-6963 subscribe for new wallet providers\n  mipd?.subscribe(providerDetails => {\n    const currentConnectorIds = new Map();\n    for (const connector of connectors.getState()) {\n      currentConnectorIds.set(connector.id, true);\n    }\n    const newConnectors = [];\n    for (const providerDetail of providerDetails) {\n      const connector = setup(providerDetailToConnector(providerDetail));\n      if (currentConnectorIds.has(connector.id)) continue;\n      newConnectors.push(connector);\n    }\n    if (storage && !store.persist.hasHydrated()) return;\n    connectors.setState(x => [...x, ...newConnectors], true);\n  });\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Emitter listeners\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  function change(data) {\n    store.setState(x => {\n      const connection = x.connections.get(data.uid);\n      if (!connection) return x;\n      return {\n        ...x,\n        connections: new Map(x.connections).set(data.uid, {\n          accounts: data.accounts ?? connection.accounts,\n          chainId: data.chainId ?? connection.chainId,\n          connector: connection.connector\n        })\n      };\n    });\n  }\n  function connect(data) {\n    // Disable handling if reconnecting/connecting\n    if (store.getState().status === 'connecting' || store.getState().status === 'reconnecting') return;\n    store.setState(x => {\n      const connector = connectors.getState().find(x => x.uid === data.uid);\n      if (!connector) return x;\n      if (connector.emitter.listenerCount('connect')) connector.emitter.off('connect', change);\n      if (!connector.emitter.listenerCount('change')) connector.emitter.on('change', change);\n      if (!connector.emitter.listenerCount('disconnect')) connector.emitter.on('disconnect', disconnect);\n      return {\n        ...x,\n        connections: new Map(x.connections).set(data.uid, {\n          accounts: data.accounts,\n          chainId: data.chainId,\n          connector: connector\n        }),\n        current: data.uid,\n        status: 'connected'\n      };\n    });\n  }\n  function disconnect(data) {\n    store.setState(x => {\n      const connection = x.connections.get(data.uid);\n      if (connection) {\n        const connector = connection.connector;\n        if (connector.emitter.listenerCount('change')) connection.connector.emitter.off('change', change);\n        if (connector.emitter.listenerCount('disconnect')) connection.connector.emitter.off('disconnect', disconnect);\n        if (!connector.emitter.listenerCount('connect')) connection.connector.emitter.on('connect', connect);\n      }\n      x.connections.delete(data.uid);\n      if (x.connections.size === 0) return {\n        ...x,\n        connections: new Map(),\n        current: undefined,\n        status: 'disconnected'\n      };\n      const nextConnection = x.connections.values().next().value;\n      return {\n        ...x,\n        connections: new Map(x.connections),\n        current: nextConnection.connector.uid\n      };\n    });\n  }\n  return {\n    get chains() {\n      return chains.getState();\n    },\n    get connectors() {\n      return connectors.getState();\n    },\n    storage,\n    getClient,\n    get state() {\n      return store.getState();\n    },\n    setState(value) {\n      let newState;\n      if (typeof value === 'function') newState = value(store.getState());else newState = value;\n      // Reset state if it got set to something not matching the base state\n      const initialState = getInitialState();\n      if (typeof newState !== 'object') newState = initialState;\n      const isCorrupt = Object.keys(initialState).some(x => !(x in newState));\n      if (isCorrupt) newState = initialState;\n      store.setState(newState, true);\n    },\n    subscribe(selector, listener, options) {\n      return store.subscribe(selector, listener, options ? {\n        ...options,\n        fireImmediately: options.emitImmediately\n      } : undefined);\n    },\n    _internal: {\n      mipd,\n      store,\n      ssr: Boolean(ssr),\n      syncConnectedChain,\n      transports: rest.transports,\n      chains: {\n        setState(value) {\n          const nextChains = typeof value === 'function' ? value(chains.getState()) : value;\n          if (nextChains.length === 0) return;\n          return chains.setState(nextChains, true);\n        },\n        subscribe(listener) {\n          return chains.subscribe(listener);\n        }\n      },\n      connectors: {\n        providerDetailToConnector,\n        setup,\n        setState(value) {\n          return connectors.setState(typeof value === 'function' ? value(connectors.getState()) : value, true);\n        },\n        subscribe(listener) {\n          return connectors.subscribe(listener);\n        }\n      },\n      events: {\n        change,\n        connect,\n        disconnect\n      }\n    }\n  };\n}","map":{"version":3,"names":["createStore","createMipd","createClient","persist","subscribeWithSelector","injected","Emitter","createEmitter","createStorage","noopStorage","ChainNotConfiguredError","uid","version","createConfig","parameters","multiInjectedProviderDiscovery","storage","window","localStorage","syncConnectedChain","ssr","rest","mipd","undefined","chains","connectors","getProviders","map","providerDetailToConnector","setup","connectorFn","emitter","connector","getState","on","connect","providerDetail","info","provider","target","id","rdns","clients","Map","getClient","config","chainId","store","chain","find","x","client","get","chainIds","properties","entries","Object","key","value","hasChainSpecificValue","some","batch","multicall","transport","transports","set","getInitialState","connections","current","status","currentVersion","prefix","startsWith","parseInt","replace","split","migrate","persistedState","initialState","name","partialize","state","__type","Array","from","connection","type","skipHydration","subscribe","isChainConfigured","setState","providerDetails","currentConnectorIds","newConnectors","has","push","hasHydrated","change","data","accounts","listenerCount","off","disconnect","delete","size","nextConnection","values","next","newState","isCorrupt","keys","selector","listener","options","fireImmediately","emitImmediately","_internal","Boolean","nextChains","length","events"],"sources":["/Users/nikhilbhatia/NIkhil/ZT-Prejects/wagmi-react-app/node_modules/wagmi/node_modules/@wagmi/core/src/createConfig.ts"],"sourcesContent":["import {\n  type EIP6963ProviderDetail,\n  type Store as MipdStore,\n  createStore as createMipd,\n} from 'mipd'\nimport {\n  type Address,\n  type Chain,\n  type Client,\n  type ClientConfig as viem_ClientConfig,\n  type Transport as viem_Transport,\n  createClient,\n} from 'viem'\nimport { persist, subscribeWithSelector } from 'zustand/middleware'\nimport { type Mutate, type StoreApi, createStore } from 'zustand/vanilla'\n\nimport {\n  type ConnectorEventMap,\n  type CreateConnectorFn,\n} from './connectors/createConnector.js'\nimport { injected } from './connectors/injected.js'\nimport { Emitter, type EventData, createEmitter } from './createEmitter.js'\nimport { type Storage, createStorage, noopStorage } from './createStorage.js'\nimport { ChainNotConfiguredError } from './errors/config.js'\nimport type { Evaluate, ExactPartial, LooseOmit, OneOf } from './types/utils.js'\nimport { uid } from './utils/uid.js'\nimport { version } from './version.js'\n\nexport type CreateConfigParameters<\n  chains extends readonly [Chain, ...Chain[]] = readonly [Chain, ...Chain[]],\n  transports extends Record<chains[number]['id'], Transport> = Record<\n    chains[number]['id'],\n    Transport\n  >,\n> = Evaluate<\n  {\n    chains: chains\n    connectors?: CreateConnectorFn[] | undefined\n    multiInjectedProviderDiscovery?: boolean | undefined\n    storage?: Storage | null | undefined\n    ssr?: boolean | undefined\n    syncConnectedChain?: boolean | undefined\n  } & OneOf<\n    | ({ transports: transports } & {\n        [key in keyof ClientConfig]?:\n          | ClientConfig[key]\n          | { [_ in chains[number]['id']]?: ClientConfig[key] | undefined }\n          | undefined\n      })\n    | {\n        client(parameters: { chain: chains[number] }): Client<\n          transports[chains[number]['id']],\n          chains[number]\n        >\n      }\n  >\n>\n\nexport function createConfig<\n  const chains extends readonly [Chain, ...Chain[]],\n  transports extends Record<chains[number]['id'], Transport>,\n>(\n  parameters: CreateConfigParameters<chains, transports>,\n): Config<chains, transports> {\n  const {\n    multiInjectedProviderDiscovery = true,\n    storage = createStorage({\n      storage:\n        typeof window !== 'undefined' && window.localStorage\n          ? window.localStorage\n          : noopStorage,\n    }),\n    syncConnectedChain = true,\n    ssr,\n    ...rest\n  } = parameters\n\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Set up connectors, clients, etc.\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n\n  const mipd =\n    typeof window !== 'undefined' && multiInjectedProviderDiscovery\n      ? createMipd()\n      : undefined\n\n  const chains = createStore(() => rest.chains)\n  const connectors = createStore(() =>\n    [\n      ...(rest.connectors ?? []),\n      ...(!ssr\n        ? mipd?.getProviders().map(providerDetailToConnector) ?? []\n        : []),\n    ].map(setup),\n  )\n  function setup(connectorFn: CreateConnectorFn): Connector {\n    // Set up emitter with uid and add to connector so they are \"linked\" together.\n    const emitter = createEmitter<ConnectorEventMap>(uid())\n    const connector = {\n      ...connectorFn({ emitter, chains: chains.getState(), storage }),\n      emitter,\n      uid: emitter.uid,\n    }\n\n    // Start listening for `connect` events on connector setup\n    // This allows connectors to \"connect\" themselves without user interaction (e.g. MetaMask's \"Manually connect to current site\")\n    emitter.on('connect', connect)\n    connector.setup?.()\n\n    return connector\n  }\n  function providerDetailToConnector(providerDetail: EIP6963ProviderDetail) {\n    const { info } = providerDetail\n    const provider = providerDetail.provider as any\n    return injected({ target: { ...info, id: info.rdns, provider } })\n  }\n\n  const clients = new Map<number, Client<Transport, chains[number]>>()\n  function getClient<chainId extends chains[number]['id']>(\n    config: { chainId?: chainId | chains[number]['id'] | undefined } = {},\n  ): Client<Transport, Extract<chains[number], { id: chainId }>> {\n    const chainId = config.chainId ?? store.getState().chainId\n    const chain = chains.getState().find((x) => x.id === chainId)\n\n    // chainId specified and not configured\n    if (config.chainId && !chain) throw new ChainNotConfiguredError()\n\n    // If the target chain is not configured, use the client of the current chain.\n    type Return = Client<Transport, Extract<chains[number], { id: chainId }>>\n    {\n      const client = clients.get(store.getState().chainId)\n      if (client && !chain) return client as Return\n      else if (!chain) throw new ChainNotConfiguredError()\n    }\n\n    // If a memoized client exists for a chain id, use that.\n    {\n      const client = clients.get(chainId)\n      if (client) return client as Return\n    }\n\n    let client\n    if (rest.client) client = rest.client({ chain })\n    else {\n      const chainId = chain.id as chains[number]['id']\n      const chainIds = chains.getState().map((x) => x.id)\n      // Grab all properties off `rest` and resolve for use in `createClient`\n      const properties: Partial<viem_ClientConfig> = {}\n      const entries = Object.entries(rest) as [keyof typeof rest, any][]\n\n      for (const [key, value] of entries) {\n        if (\n          key === 'chains' ||\n          key === 'client' ||\n          key === 'connectors' ||\n          key === 'transports'\n        )\n          continue\n        else {\n          if (typeof value === 'object') {\n            // check if value is chainId-specific since some values can be objects\n            // e.g. { batch: { multicall: { batchSize: 1024 } } }\n            if (chainId in value) properties[key] = value[chainId]\n            else {\n              // check if value is chainId-specific, but does not have value for current chainId\n              const hasChainSpecificValue = chainIds.some((x) => x in value)\n              if (hasChainSpecificValue) continue\n              properties[key] = value\n            }\n          } else properties[key] = value\n        }\n      }\n\n      client = createClient({\n        ...properties,\n        chain,\n        batch: properties.batch ?? { multicall: true },\n        transport: (parameters) =>\n          rest.transports[chainId]({ ...parameters, connectors }),\n      })\n    }\n\n    clients.set(chainId, client)\n    return client as Return\n  }\n\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Create store\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n\n  function getInitialState() {\n    return {\n      chainId: chains.getState()[0].id,\n      connections: new Map<string, Connection>(),\n      current: undefined,\n      status: 'disconnected',\n    } satisfies State\n  }\n\n  let currentVersion: number\n  const prefix = '0.0.0-canary-'\n  if (version.startsWith(prefix))\n    currentVersion = parseInt(version.replace(prefix, ''))\n  else currentVersion = parseInt(version.split('.')[0] ?? '0')\n\n  const store = createStore(\n    subscribeWithSelector(\n      // only use persist middleware if storage exists\n      storage\n        ? persist(getInitialState, {\n            migrate(persistedState, version) {\n              if (version === currentVersion) return persistedState as State\n\n              const initialState = getInitialState()\n              const chainId =\n                persistedState &&\n                typeof persistedState === 'object' &&\n                'chainId' in persistedState &&\n                typeof persistedState.chainId === 'number'\n                  ? persistedState.chainId\n                  : initialState.chainId\n              return { ...initialState, chainId }\n            },\n            name: 'store',\n            partialize(state) {\n              // Only persist \"critical\" store properties to preserve storage size.\n              return {\n                connections: {\n                  __type: 'Map',\n                  value: Array.from(state.connections.entries()).map(\n                    ([key, connection]) => {\n                      const { id, name, type, uid } = connection.connector\n                      const connector = { id, name, type, uid }\n                      return [key, { ...connection, connector }]\n                    },\n                  ),\n                } as unknown as PartializedState['connections'],\n                chainId: state.chainId,\n                current: state.current,\n              } satisfies PartializedState\n            },\n            skipHydration: ssr,\n            storage: storage as Storage<Record<string, unknown>>,\n            version: currentVersion,\n          })\n        : getInitialState,\n    ),\n  )\n\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Subscribe to changes\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n\n  // Update default chain when connector chain changes\n  if (syncConnectedChain)\n    store.subscribe(\n      ({ connections, current }) =>\n        current ? connections.get(current)?.chainId : undefined,\n      (chainId) => {\n        // If chain is not configured, then don't switch over to it.\n        const isChainConfigured = chains\n          .getState()\n          .some((x) => x.id === chainId)\n        if (!isChainConfigured) return\n\n        return store.setState((x) => ({\n          ...x,\n          chainId: chainId ?? x.chainId,\n        }))\n      },\n    )\n\n  // EIP-6963 subscribe for new wallet providers\n  mipd?.subscribe((providerDetails) => {\n    const currentConnectorIds = new Map()\n    for (const connector of connectors.getState()) {\n      currentConnectorIds.set(connector.id, true)\n    }\n\n    const newConnectors: Connector[] = []\n    for (const providerDetail of providerDetails) {\n      const connector = setup(providerDetailToConnector(providerDetail))\n      if (currentConnectorIds.has(connector.id)) continue\n      newConnectors.push(connector)\n    }\n\n    if (storage && !store.persist.hasHydrated()) return\n    connectors.setState((x) => [...x, ...newConnectors], true)\n  })\n\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n  // Emitter listeners\n  /////////////////////////////////////////////////////////////////////////////////////////////////\n\n  function change(data: EventData<ConnectorEventMap, 'change'>) {\n    store.setState((x) => {\n      const connection = x.connections.get(data.uid)\n      if (!connection) return x\n      return {\n        ...x,\n        connections: new Map(x.connections).set(data.uid, {\n          accounts:\n            (data.accounts as readonly [Address, ...Address[]]) ??\n            connection.accounts,\n          chainId: data.chainId ?? connection.chainId,\n          connector: connection.connector,\n        }),\n      }\n    })\n  }\n  function connect(data: EventData<ConnectorEventMap, 'connect'>) {\n    // Disable handling if reconnecting/connecting\n    if (\n      store.getState().status === 'connecting' ||\n      store.getState().status === 'reconnecting'\n    )\n      return\n\n    store.setState((x) => {\n      const connector = connectors.getState().find((x) => x.uid === data.uid)\n      if (!connector) return x\n\n      if (connector.emitter.listenerCount('connect'))\n        connector.emitter.off('connect', change)\n      if (!connector.emitter.listenerCount('change'))\n        connector.emitter.on('change', change)\n      if (!connector.emitter.listenerCount('disconnect'))\n        connector.emitter.on('disconnect', disconnect)\n\n      return {\n        ...x,\n        connections: new Map(x.connections).set(data.uid, {\n          accounts: data.accounts as readonly [Address, ...Address[]],\n          chainId: data.chainId,\n          connector: connector,\n        }),\n        current: data.uid,\n        status: 'connected',\n      }\n    })\n  }\n  function disconnect(data: EventData<ConnectorEventMap, 'disconnect'>) {\n    store.setState((x) => {\n      const connection = x.connections.get(data.uid)\n      if (connection) {\n        const connector = connection.connector\n        if (connector.emitter.listenerCount('change'))\n          connection.connector.emitter.off('change', change)\n        if (connector.emitter.listenerCount('disconnect'))\n          connection.connector.emitter.off('disconnect', disconnect)\n        if (!connector.emitter.listenerCount('connect'))\n          connection.connector.emitter.on('connect', connect)\n      }\n\n      x.connections.delete(data.uid)\n\n      if (x.connections.size === 0)\n        return {\n          ...x,\n          connections: new Map(),\n          current: undefined,\n          status: 'disconnected',\n        }\n\n      const nextConnection = x.connections.values().next().value as Connection\n      return {\n        ...x,\n        connections: new Map(x.connections),\n        current: nextConnection.connector.uid,\n      }\n    })\n  }\n\n  return {\n    get chains() {\n      return chains.getState() as chains\n    },\n    get connectors() {\n      return connectors.getState()\n    },\n    storage,\n\n    getClient,\n    get state() {\n      return store.getState() as unknown as State<chains>\n    },\n    setState(value) {\n      let newState: State\n      if (typeof value === 'function') newState = value(store.getState() as any)\n      else newState = value\n\n      // Reset state if it got set to something not matching the base state\n      const initialState = getInitialState()\n      if (typeof newState !== 'object') newState = initialState\n      const isCorrupt = Object.keys(initialState).some((x) => !(x in newState))\n      if (isCorrupt) newState = initialState\n\n      store.setState(newState, true)\n    },\n    subscribe(selector, listener, options) {\n      return store.subscribe(\n        selector as unknown as (state: State) => any,\n        listener,\n        options\n          ? { ...options, fireImmediately: options.emitImmediately }\n          : undefined,\n      )\n    },\n\n    _internal: {\n      mipd,\n      store,\n      ssr: Boolean(ssr),\n      syncConnectedChain,\n      transports: rest.transports as transports,\n      chains: {\n        setState(value) {\n          const nextChains = (\n            typeof value === 'function' ? value(chains.getState()) : value\n          ) as chains\n          if (nextChains.length === 0) return\n          return chains.setState(nextChains, true)\n        },\n        subscribe(listener) {\n          return chains.subscribe(listener)\n        },\n      },\n      connectors: {\n        providerDetailToConnector,\n        setup,\n        setState(value) {\n          return connectors.setState(\n            typeof value === 'function' ? value(connectors.getState()) : value,\n            true,\n          )\n        },\n        subscribe(listener) {\n          return connectors.subscribe(listener)\n        },\n      },\n      events: { change, connect, disconnect },\n    },\n  }\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Types\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nexport type Config<\n  chains extends readonly [Chain, ...Chain[]] = readonly [Chain, ...Chain[]],\n  transports extends Record<chains[number]['id'], Transport> = Record<\n    chains[number]['id'],\n    Transport\n  >,\n> = {\n  readonly chains: chains\n  readonly connectors: readonly Connector[]\n  readonly storage: Storage | null\n\n  readonly state: State<chains>\n  setState<tchains extends readonly [Chain, ...Chain[]] = chains>(\n    value: State<tchains> | ((state: State<tchains>) => State<tchains>),\n  ): void\n  subscribe<state>(\n    selector: (state: State<chains>) => state,\n    listener: (state: state, previousState: state) => void,\n    options?:\n      | {\n          emitImmediately?: boolean | undefined\n          equalityFn?: ((a: state, b: state) => boolean) | undefined\n        }\n      | undefined,\n  ): () => void\n\n  getClient<chainId extends chains[number]['id']>(parameters?: {\n    chainId?: chainId | chains[number]['id'] | undefined\n  }): Client<transports[chainId], Extract<chains[number], { id: chainId }>>\n\n  /**\n   * Not part of versioned API, proceed with caution.\n   * @internal\n   */\n  _internal: {\n    readonly mipd: MipdStore | undefined\n    readonly store: Mutate<StoreApi<any>, [['zustand/persist', any]]>\n    readonly ssr: boolean\n    readonly syncConnectedChain: boolean\n    readonly transports: transports\n\n    chains: {\n      setState(\n        value:\n          | readonly [Chain, ...Chain[]]\n          | ((\n              state: readonly [Chain, ...Chain[]],\n            ) => readonly [Chain, ...Chain[]]),\n      ): void\n      subscribe(\n        listener: (\n          state: readonly [Chain, ...Chain[]],\n          prevState: readonly [Chain, ...Chain[]],\n        ) => void,\n      ): () => void\n    }\n    connectors: {\n      providerDetailToConnector(\n        providerDetail: EIP6963ProviderDetail,\n      ): CreateConnectorFn\n      setup(connectorFn: CreateConnectorFn): Connector\n      setState(value: Connector[] | ((state: Connector[]) => Connector[])): void\n      subscribe(\n        listener: (state: Connector[], prevState: Connector[]) => void,\n      ): () => void\n    }\n    events: {\n      change(data: EventData<ConnectorEventMap, 'change'>): void\n      connect(data: EventData<ConnectorEventMap, 'connect'>): void\n      disconnect(data: EventData<ConnectorEventMap, 'disconnect'>): void\n    }\n  }\n}\n\nexport type State<\n  chains extends readonly [Chain, ...Chain[]] = readonly [Chain, ...Chain[]],\n> = {\n  chainId: chains[number]['id']\n  connections: Map<string, Connection>\n  current: string | undefined\n  status: 'connected' | 'connecting' | 'disconnected' | 'reconnecting'\n}\n\nexport type PartializedState = Evaluate<\n  ExactPartial<Pick<State, 'chainId' | 'connections' | 'current' | 'status'>>\n>\n\nexport type Connection = {\n  accounts: readonly [Address, ...Address[]]\n  chainId: number\n  connector: Connector\n}\n\nexport type Connector = ReturnType<CreateConnectorFn> & {\n  emitter: Emitter<ConnectorEventMap>\n  uid: string\n}\n\nexport type Transport = (\n  params: Parameters<viem_Transport>[0] & {\n    connectors?: StoreApi<Connector[]>\n  },\n) => ReturnType<viem_Transport>\n\ntype ClientConfig = LooseOmit<\n  viem_ClientConfig,\n  'account' | 'chain' | 'key' | 'name' | 'transport' | 'type'\n>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}