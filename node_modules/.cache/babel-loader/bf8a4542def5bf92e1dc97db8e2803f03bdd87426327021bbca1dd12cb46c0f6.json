{"ast":null,"code":"import { HttpRequestError, TimeoutError } from '../../errors/request.js';\nimport { withTimeout } from '../promise/withTimeout.js';\nimport { stringify } from '../stringify.js';\nimport { idCache } from './id.js';\nexport function getHttpRpcClient(url, options = {}) {\n  return {\n    async request(params) {\n      const {\n        body,\n        fetchOptions = {},\n        onRequest = options.onRequest,\n        onResponse = options.onResponse,\n        timeout = options.timeout ?? 10_000\n      } = params;\n      const {\n        headers,\n        method,\n        signal: signal_\n      } = {\n        ...options.fetchOptions,\n        ...fetchOptions\n      };\n      try {\n        const response = await withTimeout(async ({\n          signal\n        }) => {\n          const request = new Request(url, {\n            ...fetchOptions,\n            body: Array.isArray(body) ? stringify(body.map(body => ({\n              jsonrpc: '2.0',\n              id: body.id ?? idCache.take(),\n              ...body\n            }))) : stringify({\n              jsonrpc: '2.0',\n              id: body.id ?? idCache.take(),\n              ...body\n            }),\n            headers: {\n              ...headers,\n              'Content-Type': 'application/json'\n            },\n            method: method || 'POST',\n            signal: signal_ || (timeout > 0 ? signal : null)\n          });\n          if (onRequest) await onRequest(request);\n          const response = await fetch(request);\n          return response;\n        }, {\n          errorInstance: new TimeoutError({\n            body,\n            url\n          }),\n          timeout,\n          signal: true\n        });\n        if (onResponse) await onResponse(response);\n        let data;\n        if (response.headers.get('Content-Type')?.startsWith('application/json')) data = await response.json();else data = await response.text();\n        if (!response.ok) {\n          throw new HttpRequestError({\n            body,\n            details: stringify(data.error) || response.statusText,\n            headers: response.headers,\n            status: response.status,\n            url\n          });\n        }\n        return data;\n      } catch (err) {\n        if (err instanceof HttpRequestError) throw err;\n        if (err instanceof TimeoutError) throw err;\n        throw new HttpRequestError({\n          body,\n          details: err.message,\n          url\n        });\n      }\n    }\n  };\n}","map":{"version":3,"names":["HttpRequestError","TimeoutError","withTimeout","stringify","idCache","getHttpRpcClient","url","options","request","params","body","fetchOptions","onRequest","onResponse","timeout","headers","method","signal","signal_","response","Request","Array","isArray","map","jsonrpc","id","take","fetch","errorInstance","data","get","startsWith","json","text","ok","details","error","statusText","status","err","message"],"sources":["/Users/nikhilbhatia/NIkhil/ZT-Prejects/wagmi-react-app/node_modules/viem/utils/rpc/http.ts"],"sourcesContent":["import {\n  HttpRequestError,\n  type HttpRequestErrorType as HttpRequestErrorType_,\n  TimeoutError,\n  type TimeoutErrorType,\n} from '../../errors/request.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { RpcRequest, RpcResponse } from '../../types/rpc.js'\nimport {\n  type WithTimeoutErrorType,\n  withTimeout,\n} from '../promise/withTimeout.js'\nimport { stringify } from '../stringify.js'\nimport { idCache } from './id.js'\n\nexport type HttpRpcClientOptions = {\n  /** Request configuration to pass to `fetch`. */\n  fetchOptions?: Omit<RequestInit, 'body'> | undefined\n  /** A callback to handle the request. */\n  onRequest?: ((request: Request) => Promise<void> | void) | undefined\n  /** A callback to handle the response. */\n  onResponse?: ((response: Response) => Promise<void> | void) | undefined\n  /** The timeout (in ms) for the request. */\n  timeout?: number | undefined\n}\n\nexport type HttpRequestParameters<\n  TBody extends RpcRequest | RpcRequest[] = RpcRequest,\n> = {\n  /** The RPC request body. */\n  body: TBody\n  /** Request configuration to pass to `fetch`. */\n  fetchOptions?: HttpRpcClientOptions['fetchOptions'] | undefined\n  /** A callback to handle the response. */\n  onRequest?: ((request: Request) => Promise<void> | void) | undefined\n  /** A callback to handle the response. */\n  onResponse?: ((response: Response) => Promise<void> | void) | undefined\n  /** The timeout (in ms) for the request. */\n  timeout?: HttpRpcClientOptions['timeout'] | undefined\n}\n\nexport type HttpRequestReturnType<\n  TBody extends RpcRequest | RpcRequest[] = RpcRequest,\n> = TBody extends RpcRequest[] ? RpcResponse[] : RpcResponse\n\nexport type HttpRequestErrorType =\n  | HttpRequestErrorType_\n  | TimeoutErrorType\n  | WithTimeoutErrorType\n  | ErrorType\n\nexport type HttpRpcClient = {\n  request<TBody extends RpcRequest | RpcRequest[]>(\n    params: HttpRequestParameters<TBody>,\n  ): Promise<HttpRequestReturnType<TBody>>\n}\n\nexport function getHttpRpcClient(\n  url: string,\n  options: HttpRpcClientOptions = {},\n): HttpRpcClient {\n  return {\n    async request(params) {\n      const {\n        body,\n        fetchOptions = {},\n        onRequest = options.onRequest,\n        onResponse = options.onResponse,\n        timeout = options.timeout ?? 10_000,\n      } = params\n      const {\n        headers,\n        method,\n        signal: signal_,\n      } = { ...options.fetchOptions, ...fetchOptions }\n\n      try {\n        const response = await withTimeout(\n          async ({ signal }) => {\n            const request = new Request(url, {\n              ...fetchOptions,\n              body: Array.isArray(body)\n                ? stringify(\n                    body.map((body) => ({\n                      jsonrpc: '2.0',\n                      id: body.id ?? idCache.take(),\n                      ...body,\n                    })),\n                  )\n                : stringify({\n                    jsonrpc: '2.0',\n                    id: body.id ?? idCache.take(),\n                    ...body,\n                  }),\n              headers: {\n                ...headers,\n                'Content-Type': 'application/json',\n              },\n              method: method || 'POST',\n              signal: signal_ || (timeout > 0 ? signal : null),\n            })\n            if (onRequest) await onRequest(request)\n            const response = await fetch(request)\n            return response\n          },\n          {\n            errorInstance: new TimeoutError({ body, url }),\n            timeout,\n            signal: true,\n          },\n        )\n\n        if (onResponse) await onResponse(response)\n\n        let data: any\n        if (\n          response.headers.get('Content-Type')?.startsWith('application/json')\n        )\n          data = await response.json()\n        else data = await response.text()\n\n        if (!response.ok) {\n          throw new HttpRequestError({\n            body,\n            details: stringify(data.error) || response.statusText,\n            headers: response.headers,\n            status: response.status,\n            url,\n          })\n        }\n\n        return data\n      } catch (err) {\n        if (err instanceof HttpRequestError) throw err\n        if (err instanceof TimeoutError) throw err\n        throw new HttpRequestError({\n          body,\n          details: (err as Error).message,\n          url,\n        })\n      }\n    },\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}