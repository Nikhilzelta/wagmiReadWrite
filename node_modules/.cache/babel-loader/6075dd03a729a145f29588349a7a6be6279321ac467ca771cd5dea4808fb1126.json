{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.waitForTransactionReceipt = void 0;\nconst block_js_1 = require(\"../../errors/block.js\");\nconst transaction_js_1 = require(\"../../errors/transaction.js\");\nconst getAction_js_1 = require(\"../../utils/getAction.js\");\nconst observe_js_1 = require(\"../../utils/observe.js\");\nconst withRetry_js_1 = require(\"../../utils/promise/withRetry.js\");\nconst stringify_js_1 = require(\"../../utils/stringify.js\");\nconst getBlock_js_1 = require(\"./getBlock.js\");\nconst getTransaction_js_1 = require(\"./getTransaction.js\");\nconst getTransactionReceipt_js_1 = require(\"./getTransactionReceipt.js\");\nconst watchBlockNumber_js_1 = require(\"./watchBlockNumber.js\");\nasync function waitForTransactionReceipt(client, {\n  confirmations = 1,\n  hash,\n  onReplaced,\n  pollingInterval = client.pollingInterval,\n  timeout\n}) {\n  const observerId = (0, stringify_js_1.stringify)(['waitForTransactionReceipt', client.uid, hash]);\n  let transaction;\n  let replacedTransaction;\n  let receipt;\n  let retrying = false;\n  return new Promise((resolve, reject) => {\n    if (timeout) setTimeout(() => reject(new transaction_js_1.WaitForTransactionReceiptTimeoutError({\n      hash\n    })), timeout);\n    const _unobserve = (0, observe_js_1.observe)(observerId, {\n      onReplaced,\n      resolve,\n      reject\n    }, emit => {\n      const _unwatch = (0, getAction_js_1.getAction)(client, watchBlockNumber_js_1.watchBlockNumber, 'watchBlockNumber')({\n        emitMissed: true,\n        emitOnBegin: true,\n        poll: true,\n        pollingInterval,\n        async onBlockNumber(blockNumber_) {\n          if (retrying) return;\n          let blockNumber = blockNumber_;\n          const done = fn => {\n            _unwatch();\n            fn();\n            _unobserve();\n          };\n          try {\n            if (receipt) {\n              if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations)) return;\n              done(() => emit.resolve(receipt));\n              return;\n            }\n            if (!transaction) {\n              retrying = true;\n              await (0, withRetry_js_1.withRetry)(async () => {\n                transaction = await (0, getAction_js_1.getAction)(client, getTransaction_js_1.getTransaction, 'getTransaction')({\n                  hash\n                });\n                if (transaction.blockNumber) blockNumber = transaction.blockNumber;\n              }, {\n                delay: ({\n                  count\n                }) => ~~(1 << count) * 200,\n                retryCount: 6\n              });\n              retrying = false;\n            }\n            receipt = await (0, getAction_js_1.getAction)(client, getTransactionReceipt_js_1.getTransactionReceipt, 'getTransactionReceipt')({\n              hash\n            });\n            if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations)) return;\n            done(() => emit.resolve(receipt));\n          } catch (err) {\n            if (transaction && (err instanceof transaction_js_1.TransactionNotFoundError || err instanceof transaction_js_1.TransactionReceiptNotFoundError)) {\n              try {\n                replacedTransaction = transaction;\n                retrying = true;\n                const block = await (0, withRetry_js_1.withRetry)(() => (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, 'getBlock')({\n                  blockNumber,\n                  includeTransactions: true\n                }), {\n                  delay: ({\n                    count\n                  }) => ~~(1 << count) * 200,\n                  retryCount: 6,\n                  shouldRetry: ({\n                    error\n                  }) => error instanceof block_js_1.BlockNotFoundError\n                });\n                retrying = false;\n                const replacementTransaction = block.transactions.find(({\n                  from,\n                  nonce\n                }) => from === replacedTransaction.from && nonce === replacedTransaction.nonce);\n                if (!replacementTransaction) return;\n                receipt = await (0, getAction_js_1.getAction)(client, getTransactionReceipt_js_1.getTransactionReceipt, 'getTransactionReceipt')({\n                  hash: replacementTransaction.hash\n                });\n                if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations)) return;\n                let reason = 'replaced';\n                if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value) {\n                  reason = 'repriced';\n                } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {\n                  reason = 'cancelled';\n                }\n                done(() => {\n                  emit.onReplaced?.({\n                    reason,\n                    replacedTransaction: replacedTransaction,\n                    transaction: replacementTransaction,\n                    transactionReceipt: receipt\n                  });\n                  emit.resolve(receipt);\n                });\n              } catch (err_) {\n                done(() => emit.reject(err_));\n              }\n            } else {\n              done(() => emit.reject(err));\n            }\n          }\n        }\n      });\n    });\n  });\n}\nexports.waitForTransactionReceipt = waitForTransactionReceipt;","map":{"version":3,"names":["block_js_1","require","transaction_js_1","getAction_js_1","observe_js_1","withRetry_js_1","stringify_js_1","getBlock_js_1","getTransaction_js_1","getTransactionReceipt_js_1","watchBlockNumber_js_1","waitForTransactionReceipt","client","confirmations","hash","onReplaced","pollingInterval","timeout","observerId","stringify","uid","transaction","replacedTransaction","receipt","retrying","Promise","resolve","reject","setTimeout","WaitForTransactionReceiptTimeoutError","_unobserve","observe","emit","_unwatch","getAction","watchBlockNumber","emitMissed","emitOnBegin","poll","onBlockNumber","blockNumber_","blockNumber","done","fn","withRetry","getTransaction","delay","count","retryCount","getTransactionReceipt","err","TransactionNotFoundError","TransactionReceiptNotFoundError","block","getBlock","includeTransactions","shouldRetry","error","BlockNotFoundError","replacementTransaction","transactions","find","from","nonce","reason","to","value","transactionReceipt","err_","exports"],"sources":["/Users/nikhilbhatia/NIkhil/ZT-Prejects/wagmi-react-app/node_modules/@safe-global/safe-apps-sdk/node_modules/viem/actions/public/waitForTransactionReceipt.ts"],"sourcesContent":["import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { BlockNotFoundError } from '../../errors/block.js'\nimport {\n  TransactionNotFoundError,\n  TransactionReceiptNotFoundError,\n  WaitForTransactionReceiptTimeoutError,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { Transaction } from '../../types/transaction.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { type ObserveErrorType, observe } from '../../utils/observe.js'\nimport { withRetry } from '../../utils/promise/withRetry.js'\nimport { stringify } from '../../utils/stringify.js'\n\nimport { type GetBlockErrorType, getBlock } from './getBlock.js'\nimport {\n  type GetTransactionErrorType,\n  type GetTransactionReturnType,\n  getTransaction,\n} from './getTransaction.js'\nimport {\n  type GetTransactionReceiptErrorType,\n  type GetTransactionReceiptReturnType,\n  getTransactionReceipt,\n} from './getTransactionReceipt.js'\nimport {\n  type WatchBlockNumberErrorType,\n  watchBlockNumber,\n} from './watchBlockNumber.js'\n\nexport type ReplacementReason = 'cancelled' | 'replaced' | 'repriced'\nexport type ReplacementReturnType<\n  TChain extends Chain | undefined = Chain | undefined,\n> = {\n  reason: ReplacementReason\n  replacedTransaction: Transaction\n  transaction: Transaction\n  transactionReceipt: GetTransactionReceiptReturnType<TChain>\n}\n\nexport type WaitForTransactionReceiptReturnType<\n  TChain extends Chain | undefined = Chain | undefined,\n> = GetTransactionReceiptReturnType<TChain>\n\nexport type WaitForTransactionReceiptParameters<\n  TChain extends Chain | undefined = Chain | undefined,\n> = {\n  /**\n   * The number of confirmations (blocks that have passed) to wait before resolving.\n   * @default 1\n   */\n  confirmations?: number\n  /** The hash of the transaction. */\n  hash: Hash\n  /** Optional callback to emit if the transaction has been replaced. */\n  onReplaced?: (response: ReplacementReturnType<TChain>) => void\n  /**\n   * Polling frequency (in ms). Defaults to the client's pollingInterval config.\n   * @default client.pollingInterval\n   */\n  pollingInterval?: number\n  /** Optional timeout (in milliseconds) to wait before stopping polling. */\n  timeout?: number\n}\n\nexport type WaitForTransactionReceiptErrorType =\n  | ObserveErrorType\n  | GetBlockErrorType\n  | GetTransactionErrorType\n  | GetTransactionReceiptErrorType\n  | WatchBlockNumberErrorType\n  | ErrorType\n\n/**\n * Waits for the [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) to be included on a [Block](https://viem.sh/docs/glossary/terms.html#block) (one confirmation), and then returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms.html#transaction-receipt). If the Transaction reverts, then the action will throw an error.\n *\n * - Docs: https://viem.sh/docs/actions/public/waitForTransactionReceipt.html\n * - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions/sending-transactions\n * - JSON-RPC Methods:\n *   - Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed.\n *   - If a Transaction has been replaced:\n *     - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions\n *     - Checks if one of the Transactions is a replacement\n *     - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt).\n *\n * The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions).\n *\n * Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce.\n *\n * There are 3 types of Transaction Replacement reasons:\n *\n * - `repriced`: The gas price has been modified (e.g. different `maxFeePerGas`)\n * - `cancelled`: The Transaction has been cancelled (e.g. `value === 0n`)\n * - `replaced`: The Transaction has been replaced (e.g. different `value` or `data`)\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForTransactionReceiptParameters}\n * @returns The transaction receipt. {@link WaitForTransactionReceiptReturnType}\n *\n * @example\n * import { createPublicClient, waitForTransactionReceipt, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const transactionReceipt = await waitForTransactionReceipt(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function waitForTransactionReceipt<\n  TChain extends Chain | undefined,\n>(\n  client: Client<Transport, TChain>,\n  {\n    confirmations = 1,\n    hash,\n    onReplaced,\n    pollingInterval = client.pollingInterval,\n    timeout,\n  }: WaitForTransactionReceiptParameters<TChain>,\n): Promise<WaitForTransactionReceiptReturnType<TChain>> {\n  const observerId = stringify(['waitForTransactionReceipt', client.uid, hash])\n\n  let transaction: GetTransactionReturnType<TChain> | undefined\n  let replacedTransaction: GetTransactionReturnType<TChain> | undefined\n  let receipt: GetTransactionReceiptReturnType<TChain>\n  let retrying = false\n\n  return new Promise((resolve, reject) => {\n    if (timeout)\n      setTimeout(\n        () => reject(new WaitForTransactionReceiptTimeoutError({ hash })),\n        timeout,\n      )\n\n    const _unobserve = observe(\n      observerId,\n      { onReplaced, resolve, reject },\n      (emit) => {\n        const _unwatch = getAction(\n          client,\n          watchBlockNumber,\n          'watchBlockNumber',\n        )({\n          emitMissed: true,\n          emitOnBegin: true,\n          poll: true,\n          pollingInterval,\n          async onBlockNumber(blockNumber_) {\n            if (retrying) return\n\n            let blockNumber = blockNumber_\n\n            const done = (fn: () => void) => {\n              _unwatch()\n              fn()\n              _unobserve()\n            }\n\n            try {\n              // If we already have a valid receipt, let's check if we have enough\n              // confirmations. If we do, then we can resolve.\n              if (receipt) {\n                if (\n                  confirmations > 1 &&\n                  (!receipt.blockNumber ||\n                    blockNumber - receipt.blockNumber + 1n < confirmations)\n                )\n                  return\n\n                done(() => emit.resolve(receipt))\n                return\n              }\n\n              // Get the transaction to check if it's been replaced.\n              // We need to retry as some RPC Providers may be slow to sync\n              // up mined transactions.\n              if (!transaction) {\n                retrying = true\n                await withRetry(\n                  async () => {\n                    transaction = (await getAction(\n                      client,\n                      getTransaction,\n                      'getTransaction',\n                    )({ hash })) as GetTransactionReturnType<TChain>\n                    if (transaction.blockNumber)\n                      blockNumber = transaction.blockNumber\n                  },\n                  {\n                    // exponential backoff\n                    delay: ({ count }) => ~~(1 << count) * 200,\n                    retryCount: 6,\n                  },\n                )\n                retrying = false\n              }\n\n              // Get the receipt to check if it's been processed.\n              receipt = await getAction(\n                client,\n                getTransactionReceipt,\n                'getTransactionReceipt',\n              )({ hash })\n\n              // Check if we have enough confirmations. If not, continue polling.\n              if (\n                confirmations > 1 &&\n                (!receipt.blockNumber ||\n                  blockNumber - receipt.blockNumber + 1n < confirmations)\n              )\n                return\n\n              done(() => emit.resolve(receipt))\n            } catch (err) {\n              // If the receipt is not found, the transaction will be pending.\n              // We need to check if it has potentially been replaced.\n              if (\n                transaction &&\n                (err instanceof TransactionNotFoundError ||\n                  err instanceof TransactionReceiptNotFoundError)\n              ) {\n                try {\n                  replacedTransaction = transaction\n\n                  // Let's retrieve the transactions from the current block.\n                  // We need to retry as some RPC Providers may be slow to sync\n                  // up mined blocks.\n                  retrying = true\n                  const block = await withRetry(\n                    () =>\n                      getAction(\n                        client,\n                        getBlock,\n                        'getBlock',\n                      )({\n                        blockNumber,\n                        includeTransactions: true,\n                      }),\n                    {\n                      // exponential backoff\n                      delay: ({ count }) => ~~(1 << count) * 200,\n                      retryCount: 6,\n                      shouldRetry: ({ error }) =>\n                        error instanceof BlockNotFoundError,\n                    },\n                  )\n                  retrying = false\n\n                  const replacementTransaction = (\n                    block.transactions as {} as Transaction[]\n                  ).find(\n                    ({ from, nonce }) =>\n                      from === replacedTransaction!.from &&\n                      nonce === replacedTransaction!.nonce,\n                  )\n\n                  // If we couldn't find a replacement transaction, continue polling.\n                  if (!replacementTransaction) return\n\n                  // If we found a replacement transaction, return it's receipt.\n                  receipt = await getAction(\n                    client,\n                    getTransactionReceipt,\n                    'getTransactionReceipt',\n                  )({\n                    hash: replacementTransaction.hash,\n                  })\n\n                  // Check if we have enough confirmations. If not, continue polling.\n                  if (\n                    confirmations > 1 &&\n                    (!receipt.blockNumber ||\n                      blockNumber - receipt.blockNumber + 1n < confirmations)\n                  )\n                    return\n\n                  let reason: ReplacementReason = 'replaced'\n                  if (\n                    replacementTransaction.to === replacedTransaction.to &&\n                    replacementTransaction.value === replacedTransaction.value\n                  ) {\n                    reason = 'repriced'\n                  } else if (\n                    replacementTransaction.from === replacementTransaction.to &&\n                    replacementTransaction.value === 0n\n                  ) {\n                    reason = 'cancelled'\n                  }\n\n                  done(() => {\n                    emit.onReplaced?.({\n                      reason,\n                      replacedTransaction: replacedTransaction!,\n                      transaction: replacementTransaction,\n                      transactionReceipt: receipt,\n                    })\n                    emit.resolve(receipt)\n                  })\n                } catch (err_) {\n                  done(() => emit.reject(err_))\n                }\n              } else {\n                done(() => emit.reject(err))\n              }\n            }\n          },\n        })\n      },\n    )\n  })\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}