{"ast":null,"code":"import { AbiEventSignatureNotFoundError, DecodeLogDataMismatch, DecodeLogTopicsMismatch } from '../../index.js';\nimport { decodeEventLog } from './decodeEventLog.js';\n/**\n * Extracts & decodes logs matching the provided signature(s) (`abi` + optional `eventName`)\n * from a set of opaque logs.\n *\n * @param parameters - {@link ParseEventLogsParameters}\n * @returns The logs. {@link ParseEventLogsReturnType}\n *\n * @example\n * import { createClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { parseEventLogs } from 'viem/op-stack'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const receipt = await getTransactionReceipt(client, {\n *   hash: '0xec23b2ba4bc59ba61554507c1b1bc91649e6586eb2dd00c728e8ed0db8bb37ea',\n * })\n *\n * const logs = parseEventLogs({ logs: receipt.logs })\n * // [{ args: { ... }, eventName: 'TransactionDeposited', ... }, ...]\n */\nexport function parseEventLogs({\n  abi,\n  eventName,\n  logs,\n  strict = true\n}) {\n  return logs.map(log => {\n    try {\n      const event = decodeEventLog({\n        ...log,\n        abi,\n        strict\n      });\n      if (eventName && !eventName.includes(event.eventName)) return null;\n      return {\n        ...event,\n        ...log\n      };\n    } catch (err) {\n      let eventName;\n      let isUnnamed;\n      if (err instanceof AbiEventSignatureNotFoundError) return null;\n      if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {\n        // If strict mode is on, and log data/topics do not match event definition, skip.\n        if (strict) return null;\n        eventName = err.abiItem.name;\n        isUnnamed = err.abiItem.inputs?.some(x => !('name' in x && x.name));\n      }\n      // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n      return {\n        ...log,\n        args: isUnnamed ? [] : {},\n        eventName\n      };\n    }\n  }).filter(Boolean);\n}","map":{"version":3,"names":["AbiEventSignatureNotFoundError","DecodeLogDataMismatch","DecodeLogTopicsMismatch","decodeEventLog","parseEventLogs","abi","eventName","logs","strict","map","log","event","includes","err","isUnnamed","abiItem","name","inputs","some","x","args","filter","Boolean"],"sources":["/Users/nikhilbhatia/NIkhil/ZT-Prejects/wagmi-react-app/node_modules/viem/utils/abi/parseEventLogs.ts"],"sourcesContent":["import type { Abi } from 'abitype'\nimport type { ErrorType } from '../../errors/utils.js'\nimport {\n  AbiEventSignatureNotFoundError,\n  DecodeLogDataMismatch,\n  DecodeLogTopicsMismatch,\n  type RpcLog,\n} from '../../index.js'\nimport type { ContractEventName } from '../../types/contract.js'\nimport type { Log } from '../../types/log.js'\nimport {\n  type DecodeEventLogErrorType,\n  decodeEventLog,\n} from './decodeEventLog.js'\n\nexport type ParseEventLogsParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined = ContractEventName<abi>,\n  strict extends boolean | undefined = boolean | undefined,\n> = {\n  /** Contract ABI. */\n  abi: abi\n  /** Contract event. */\n  eventName?:\n    | eventName\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined\n  /** List of logs. */\n  logs: (Log | RpcLog)[]\n  strict?: strict | boolean | undefined\n}\n\nexport type ParseEventLogsReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined = ContractEventName<abi>,\n  strict extends boolean | undefined = boolean | undefined,\n  ///\n  derivedEventName extends\n    | ContractEventName<abi>\n    | undefined = eventName extends ContractEventName<abi>[]\n    ? eventName[number]\n    : eventName,\n> = Log<bigint, number, false, undefined, strict, abi, derivedEventName>[]\n\nexport type ParseEventLogsErrorType = DecodeEventLogErrorType | ErrorType\n\n/**\n * Extracts & decodes logs matching the provided signature(s) (`abi` + optional `eventName`)\n * from a set of opaque logs.\n *\n * @param parameters - {@link ParseEventLogsParameters}\n * @returns The logs. {@link ParseEventLogsReturnType}\n *\n * @example\n * import { createClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { parseEventLogs } from 'viem/op-stack'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const receipt = await getTransactionReceipt(client, {\n *   hash: '0xec23b2ba4bc59ba61554507c1b1bc91649e6586eb2dd00c728e8ed0db8bb37ea',\n * })\n *\n * const logs = parseEventLogs({ logs: receipt.logs })\n * // [{ args: { ... }, eventName: 'TransactionDeposited', ... }, ...]\n */\nexport function parseEventLogs<\n  abi extends Abi | readonly unknown[],\n  strict extends boolean | undefined = true,\n  eventName extends\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined = undefined,\n>({\n  abi,\n  eventName,\n  logs,\n  strict = true,\n}: ParseEventLogsParameters<abi, eventName, strict>): ParseEventLogsReturnType<\n  abi,\n  eventName,\n  strict\n> {\n  return logs\n    .map((log) => {\n      try {\n        const event = decodeEventLog({\n          ...log,\n          abi,\n          strict,\n        })\n        if (eventName && !eventName.includes(event.eventName!)) return null\n        return { ...event, ...log }\n      } catch (err) {\n        let eventName: string | undefined\n        let isUnnamed: boolean | undefined\n\n        if (err instanceof AbiEventSignatureNotFoundError) return null\n        if (\n          err instanceof DecodeLogDataMismatch ||\n          err instanceof DecodeLogTopicsMismatch\n        ) {\n          // If strict mode is on, and log data/topics do not match event definition, skip.\n          if (strict) return null\n          eventName = err.abiItem.name\n          isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name))\n        }\n\n        // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n        return { ...log, args: isUnnamed ? [] : {}, eventName }\n      }\n    })\n    .filter(Boolean) as unknown as ParseEventLogsReturnType<\n    abi,\n    eventName,\n    strict\n  >\n}\n"],"mappings":"AAEA,SACEA,8BAA8B,EAC9BC,qBAAqB,EACrBC,uBAAuB,QAElB,gBAAgB;AAGvB,SAEEC,cAAc,QACT,qBAAqB;AAwC5B;;;;;;;;;;;;;;;;;;;;;;;;AAwBA,OAAM,SAAUC,cAAcA,CAO5B;EACAC,GAAG;EACHC,SAAS;EACTC,IAAI;EACJC,MAAM,GAAG;AAAI,CACoC;EAKjD,OAAOD,IAAI,CACRE,GAAG,CAAEC,GAAG,IAAI;IACX,IAAI;MACF,MAAMC,KAAK,GAAGR,cAAc,CAAC;QAC3B,GAAGO,GAAG;QACNL,GAAG;QACHG;OACD,CAAC;MACF,IAAIF,SAAS,IAAI,CAACA,SAAS,CAACM,QAAQ,CAACD,KAAK,CAACL,SAAU,CAAC,EAAE,OAAO,IAAI;MACnE,OAAO;QAAE,GAAGK,KAAK;QAAE,GAAGD;MAAG,CAAE;IAC7B,CAAC,CAAC,OAAOG,GAAG,EAAE;MACZ,IAAIP,SAA6B;MACjC,IAAIQ,SAA8B;MAElC,IAAID,GAAG,YAAYb,8BAA8B,EAAE,OAAO,IAAI;MAC9D,IACEa,GAAG,YAAYZ,qBAAqB,IACpCY,GAAG,YAAYX,uBAAuB,EACtC;QACA;QACA,IAAIM,MAAM,EAAE,OAAO,IAAI;QACvBF,SAAS,GAAGO,GAAG,CAACE,OAAO,CAACC,IAAI;QAC5BF,SAAS,GAAGD,GAAG,CAACE,OAAO,CAACE,MAAM,EAAEC,IAAI,CAAEC,CAAC,IAAK,EAAE,MAAM,IAAIA,CAAC,IAAIA,CAAC,CAACH,IAAI,CAAC,CAAC;MACvE;MAEA;MACA,OAAO;QAAE,GAAGN,GAAG;QAAEU,IAAI,EAAEN,SAAS,GAAG,EAAE,GAAG,EAAE;QAAER;MAAS,CAAE;IACzD;EACF,CAAC,CAAC,CACDe,MAAM,CAACC,OAAO,CAIhB;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}