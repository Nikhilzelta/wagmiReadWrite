{"ast":null,"code":"export {};","map":{"version":3,"names":[],"sources":["/Users/nikhilbhatia/NIkhil/ZT-Prejects/wagmi-react-app/node_modules/viem/types/rpc.ts"],"sourcesContent":["import type { Address } from 'abitype'\nimport type {\n  Block,\n  BlockIdentifier,\n  BlockNumber,\n  BlockTag,\n  Uncle,\n} from './block.js'\nimport type { FeeHistory, FeeValues } from './fee.js'\nimport type { Log } from './log.js'\nimport type { Hex } from './misc.js'\nimport type { Proof } from './proof.js'\nimport type {\n  TransactionEIP1559,\n  TransactionEIP2930,\n  TransactionEIP4844,\n  TransactionLegacy,\n  TransactionReceipt,\n  TransactionRequestEIP1559,\n  TransactionRequestEIP2930,\n  TransactionRequestEIP4844,\n  TransactionRequestLegacy,\n} from './transaction.js'\nimport type { OneOf, UnionOmit, UnionPartialBy } from './utils.js'\n\nexport type Index = `0x${string}`\nexport type Quantity = `0x${string}`\nexport type Status = '0x0' | '0x1'\nexport type TransactionType = '0x0' | '0x1' | '0x2' | (string & {})\n\nexport type RpcBlock<\n  TBlockTag extends BlockTag = BlockTag,\n  TIncludeTransactions extends boolean = boolean,\n  TTransaction = RpcTransaction<TBlockTag extends 'pending' ? true : false>,\n> = Block<Quantity, TIncludeTransactions, TBlockTag, TTransaction>\nexport type RpcBlockNumber = BlockNumber<Quantity>\nexport type RpcBlockIdentifier = BlockIdentifier<Quantity>\nexport type RpcUncle = Uncle<Quantity>\nexport type RpcFeeHistory = FeeHistory<Quantity>\nexport type RpcFeeValues = FeeValues<Quantity>\nexport type RpcLog = Log<Quantity, Index>\nexport type RpcProof = Proof<Quantity, Index>\nexport type RpcTransactionReceipt = TransactionReceipt<\n  Quantity,\n  Index,\n  Status,\n  TransactionType\n>\nexport type RpcTransactionRequest = OneOf<\n  | TransactionRequestLegacy<Quantity, Index, '0x0'>\n  | TransactionRequestEIP2930<Quantity, Index, '0x1'>\n  | TransactionRequestEIP1559<Quantity, Index, '0x2'>\n  | TransactionRequestEIP4844<Quantity, Index, '0x3'>\n>\nexport type RpcTransaction<TPending extends boolean = boolean> = UnionOmit<\n  UnionPartialBy<\n    OneOf<\n      | TransactionLegacy<Quantity, Index, TPending, '0x0'>\n      | TransactionEIP2930<Quantity, Index, TPending, '0x1'>\n      | TransactionEIP1559<Quantity, Index, TPending, '0x2'>\n      | TransactionEIP4844<Quantity, Index, TPending, '0x3'>\n    >,\n    // `yParity` is optional on the RPC type as some nodes do not return it\n    // for 1559 & 2930 transactions (they should!).\n    'yParity'\n  >,\n  'typeHex'\n>\n\ntype SuccessResult<T> = {\n  method?: never | undefined\n  result: T\n  error?: never | undefined\n}\ntype ErrorResult<T> = {\n  method?: never | undefined\n  result?: never | undefined\n  error: T\n}\ntype Subscription<TResult, TError> = {\n  method: 'eth_subscription'\n  error?: never | undefined\n  result?: never | undefined\n  params: {\n    subscription: string\n  } & (\n    | {\n        result: TResult\n        error?: never | undefined\n      }\n    | {\n        result?: never | undefined\n        error: TError\n      }\n  )\n}\n\nexport type RpcRequest = {\n  jsonrpc?: '2.0' | undefined\n  method: string\n  params?: any | undefined\n  id?: number | undefined\n}\n\nexport type RpcResponse<TResult = any, TError = any> = {\n  jsonrpc: `${number}`\n  id: number\n} & (\n  | SuccessResult<TResult>\n  | ErrorResult<TError>\n  | Subscription<TResult, TError>\n)\n\n/** A key-value mapping of slot and storage values (supposedly 32 bytes each) */\nexport type RpcStateMapping = {\n  [slots: Hex]: Hex\n}\n\nexport type RpcAccountStateOverride = {\n  /** Fake balance to set for the account before executing the call. <32 bytes */\n  balance?: Hex | undefined\n  /** Fake nonce to set for the account before executing the call. <8 bytes */\n  nonce?: Hex | undefined\n  /** Fake EVM bytecode to inject into the account before executing the call. */\n  code?: Hex | undefined\n  /** Fake key-value mapping to override all slots in the account storage before executing the call. */\n  state?: RpcStateMapping | undefined\n  /** Fake key-value mapping to override individual slots in the account storage before executing the call. */\n  stateDiff?: RpcStateMapping | undefined\n}\n\nexport type RpcStateOverride = {\n  [address: Address]: RpcAccountStateOverride\n}\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}