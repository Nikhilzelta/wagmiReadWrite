{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getAmbiguousTypes = exports.isArgOfType = exports.getAbiItem = void 0;\nconst abi_js_1 = require(\"../../errors/abi.js\");\nconst isHex_js_1 = require(\"../../utils/data/isHex.js\");\nconst getEventSelector_js_1 = require(\"../../utils/hash/getEventSelector.js\");\nconst getFunctionSelector_js_1 = require(\"../../utils/hash/getFunctionSelector.js\");\nconst isAddress_js_1 = require(\"../address/isAddress.js\");\nfunction getAbiItem({\n  abi,\n  args = [],\n  name\n}) {\n  const isSelector = (0, isHex_js_1.isHex)(name, {\n    strict: false\n  });\n  const abiItems = abi.filter(abiItem => {\n    if (isSelector) {\n      if (abiItem.type === 'function') return (0, getFunctionSelector_js_1.getFunctionSelector)(abiItem) === name;\n      if (abiItem.type === 'event') return (0, getEventSelector_js_1.getEventSelector)(abiItem) === name;\n      return false;\n    }\n    return 'name' in abiItem && abiItem.name === name;\n  });\n  if (abiItems.length === 0) return undefined;\n  if (abiItems.length === 1) return abiItems[0];\n  let matchedAbiItem = undefined;\n  for (const abiItem of abiItems) {\n    if (!('inputs' in abiItem)) continue;\n    if (!args || args.length === 0) {\n      if (!abiItem.inputs || abiItem.inputs.length === 0) return abiItem;\n      continue;\n    }\n    if (!abiItem.inputs) continue;\n    if (abiItem.inputs.length === 0) continue;\n    if (abiItem.inputs.length !== args.length) continue;\n    const matched = args.every((arg, index) => {\n      const abiParameter = 'inputs' in abiItem && abiItem.inputs[index];\n      if (!abiParameter) return false;\n      return isArgOfType(arg, abiParameter);\n    });\n    if (matched) {\n      if (matchedAbiItem && 'inputs' in matchedAbiItem && matchedAbiItem.inputs) {\n        const ambiguousTypes = getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);\n        if (ambiguousTypes) throw new abi_js_1.AbiItemAmbiguityError({\n          abiItem,\n          type: ambiguousTypes[0]\n        }, {\n          abiItem: matchedAbiItem,\n          type: ambiguousTypes[1]\n        });\n      }\n      matchedAbiItem = abiItem;\n    }\n  }\n  if (matchedAbiItem) return matchedAbiItem;\n  return abiItems[0];\n}\nexports.getAbiItem = getAbiItem;\nfunction isArgOfType(arg, abiParameter) {\n  const argType = typeof arg;\n  const abiParameterType = abiParameter.type;\n  switch (abiParameterType) {\n    case 'address':\n      return (0, isAddress_js_1.isAddress)(arg);\n    case 'bool':\n      return argType === 'boolean';\n    case 'function':\n      return argType === 'string';\n    case 'string':\n      return argType === 'string';\n    default:\n      {\n        if (abiParameterType === 'tuple' && 'components' in abiParameter) return Object.values(abiParameter.components).every((component, index) => {\n          return isArgOfType(Object.values(arg)[index], component);\n        });\n        if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType)) return argType === 'number' || argType === 'bigint';\n        if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType)) return argType === 'string' || arg instanceof Uint8Array;\n        if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n          return Array.isArray(arg) && arg.every(x => isArgOfType(x, {\n            ...abiParameter,\n            type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, '')\n          }));\n        }\n        return false;\n      }\n  }\n}\nexports.isArgOfType = isArgOfType;\nfunction getAmbiguousTypes(sourceParameters, targetParameters, args) {\n  for (const parameterIndex in sourceParameters) {\n    const sourceParameter = sourceParameters[parameterIndex];\n    const targetParameter = targetParameters[parameterIndex];\n    if (sourceParameter.type === 'tuple' && targetParameter.type === 'tuple' && 'components' in sourceParameter && 'components' in targetParameter) return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);\n    const types = [sourceParameter.type, targetParameter.type];\n    const ambiguous = (() => {\n      if (types.includes('address') && types.includes('bytes20')) return true;\n      if (types.includes('address') && types.includes('string')) return (0, isAddress_js_1.isAddress)(args[parameterIndex]);\n      if (types.includes('address') && types.includes('bytes')) return (0, isAddress_js_1.isAddress)(args[parameterIndex]);\n      return false;\n    })();\n    if (ambiguous) return types;\n  }\n  return;\n}\nexports.getAmbiguousTypes = getAmbiguousTypes;","map":{"version":3,"names":["abi_js_1","require","isHex_js_1","getEventSelector_js_1","getFunctionSelector_js_1","isAddress_js_1","getAbiItem","abi","args","name","isSelector","isHex","strict","abiItems","filter","abiItem","type","getFunctionSelector","getEventSelector","length","undefined","matchedAbiItem","inputs","matched","every","arg","index","abiParameter","isArgOfType","ambiguousTypes","getAmbiguousTypes","AbiItemAmbiguityError","exports","argType","abiParameterType","isAddress","Object","values","components","component","test","Uint8Array","Array","isArray","x","replace","sourceParameters","targetParameters","parameterIndex","sourceParameter","targetParameter","types","ambiguous","includes"],"sources":["/Users/nikhilbhatia/NIkhil/ZT-Prejects/wagmi-react-app/node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/abi/getAbiItem.ts"],"sourcesContent":["import { type Abi, type AbiParameter, type Address } from 'abitype'\n\nimport { AbiItemAmbiguityError } from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  AbiItem,\n  GetFunctionArgs,\n  InferItemName,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../../utils/data/isHex.js'\nimport { getEventSelector } from '../../utils/hash/getEventSelector.js'\nimport {\n  type GetFunctionSelectorErrorType,\n  getFunctionSelector,\n} from '../../utils/hash/getFunctionSelector.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\n\nexport type GetAbiItemParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TItemName extends string = string,\n> = {\n  abi: TAbi\n  name: InferItemName<TAbi, TItemName> | Hex\n} & Partial<GetFunctionArgs<TAbi, TItemName>>\n\nexport type GetAbiItemReturnType<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TItemName extends string = string,\n> = Extract<\n  TAbi[number],\n  {\n    name: TItemName\n  }\n>\n\nexport type GetAbiItemErrorType =\n  | IsArgOfTypeErrorType\n  | IsHexErrorType\n  | GetFunctionSelectorErrorType\n  | ErrorType\n\nexport function getAbiItem<\n  const TAbi extends Abi | readonly unknown[],\n  TItemName extends string,\n>({\n  abi,\n  args = [],\n  name,\n}: GetAbiItemParameters<TAbi, TItemName>): GetAbiItemReturnType<\n  TAbi,\n  TItemName\n> {\n  const isSelector = isHex(name, { strict: false })\n\n  const abiItems = (abi as Abi).filter((abiItem) => {\n    if (isSelector) {\n      if (abiItem.type === 'function')\n        return getFunctionSelector(abiItem) === name\n      if (abiItem.type === 'event') return getEventSelector(abiItem) === name\n      return false\n    }\n    return 'name' in abiItem && abiItem.name === name\n  })\n\n  if (abiItems.length === 0) return undefined as any\n  if (abiItems.length === 1) return abiItems[0] as any\n\n  let matchedAbiItem: AbiItem | undefined = undefined\n  for (const abiItem of abiItems) {\n    if (!('inputs' in abiItem)) continue\n    if (!args || args.length === 0) {\n      if (!abiItem.inputs || abiItem.inputs.length === 0) return abiItem as any\n      continue\n    }\n    if (!abiItem.inputs) continue\n    if (abiItem.inputs.length === 0) continue\n    if (abiItem.inputs.length !== args.length) continue\n    const matched = (args as readonly unknown[]).every((arg, index) => {\n      const abiParameter = 'inputs' in abiItem && abiItem.inputs![index]\n      if (!abiParameter) return false\n      return isArgOfType(arg, abiParameter as AbiParameter)\n    })\n    if (matched) {\n      // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).\n      if (\n        matchedAbiItem &&\n        'inputs' in matchedAbiItem &&\n        matchedAbiItem.inputs\n      ) {\n        const ambiguousTypes = getAmbiguousTypes(\n          abiItem.inputs,\n          matchedAbiItem.inputs,\n          args as readonly unknown[],\n        )\n        if (ambiguousTypes)\n          throw new AbiItemAmbiguityError(\n            {\n              abiItem,\n              type: ambiguousTypes[0],\n            },\n            {\n              abiItem: matchedAbiItem,\n              type: ambiguousTypes[1],\n            },\n          )\n      }\n\n      matchedAbiItem = abiItem\n    }\n  }\n\n  if (matchedAbiItem)\n    return matchedAbiItem as GetAbiItemReturnType<TAbi, TItemName>\n  return abiItems[0] as GetAbiItemReturnType<TAbi, TItemName>\n}\n\nexport type IsArgOfTypeErrorType = IsAddressErrorType | ErrorType\n\nexport function isArgOfType(arg: unknown, abiParameter: AbiParameter): boolean {\n  const argType = typeof arg\n  const abiParameterType = abiParameter.type\n  switch (abiParameterType) {\n    case 'address':\n      return isAddress(arg as Address)\n    case 'bool':\n      return argType === 'boolean'\n    case 'function':\n      return argType === 'string'\n    case 'string':\n      return argType === 'string'\n    default: {\n      if (abiParameterType === 'tuple' && 'components' in abiParameter)\n        return Object.values(abiParameter.components).every(\n          (component, index) => {\n            return isArgOfType(\n              Object.values(arg as unknown[] | Record<string, unknown>)[index],\n              component as AbiParameter,\n            )\n          },\n        )\n\n      // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n      // https://regexr.com/6v8hp\n      if (\n        /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(\n          abiParameterType,\n        )\n      )\n        return argType === 'number' || argType === 'bigint'\n\n      // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n      // https://regexr.com/6va55\n      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\n        return argType === 'string' || arg instanceof Uint8Array\n\n      // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n      // https://regexr.com/6va6i\n      if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n        return (\n          Array.isArray(arg) &&\n          arg.every((x: unknown) =>\n            isArgOfType(x, {\n              ...abiParameter,\n              // Pop off `[]` or `[M]` from end of type\n              type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, ''),\n            } as AbiParameter),\n          )\n        )\n      }\n\n      return false\n    }\n  }\n}\n\nexport function getAmbiguousTypes(\n  sourceParameters: readonly AbiParameter[],\n  targetParameters: readonly AbiParameter[],\n  args: readonly unknown[],\n): AbiParameter['type'][] | undefined {\n  for (const parameterIndex in sourceParameters) {\n    const sourceParameter = sourceParameters[parameterIndex]\n    const targetParameter = targetParameters[parameterIndex]\n\n    if (\n      sourceParameter.type === 'tuple' &&\n      targetParameter.type === 'tuple' &&\n      'components' in sourceParameter &&\n      'components' in targetParameter\n    )\n      return getAmbiguousTypes(\n        sourceParameter.components,\n        targetParameter.components,\n        (args as any)[parameterIndex],\n      )\n\n    const types = [sourceParameter.type, targetParameter.type]\n\n    const ambiguous = (() => {\n      if (types.includes('address') && types.includes('bytes20')) return true\n      if (types.includes('address') && types.includes('string'))\n        return isAddress(args[parameterIndex] as Address)\n      if (types.includes('address') && types.includes('bytes'))\n        return isAddress(args[parameterIndex] as Address)\n      return false\n    })()\n\n    if (ambiguous) return types\n  }\n\n  return\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}