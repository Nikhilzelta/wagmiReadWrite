{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.rpc = exports.getSocket = exports.socketsCache = void 0;\nconst isows_1 = require(\"isows\");\nconst request_js_1 = require(\"../errors/request.js\");\nconst createBatchScheduler_js_1 = require(\"./promise/createBatchScheduler.js\");\nconst withTimeout_js_1 = require(\"./promise/withTimeout.js\");\nconst stringify_js_1 = require(\"./stringify.js\");\nlet id = 0;\nasync function http(url, {\n  body,\n  fetchOptions = {},\n  timeout = 10000\n}) {\n  const {\n    headers,\n    method,\n    signal: signal_\n  } = fetchOptions;\n  try {\n    const response = await (0, withTimeout_js_1.withTimeout)(async ({\n      signal\n    }) => {\n      const response = await fetch(url, {\n        ...fetchOptions,\n        body: Array.isArray(body) ? (0, stringify_js_1.stringify)(body.map(body => ({\n          jsonrpc: '2.0',\n          id: body.id ?? id++,\n          ...body\n        }))) : (0, stringify_js_1.stringify)({\n          jsonrpc: '2.0',\n          id: body.id ?? id++,\n          ...body\n        }),\n        headers: {\n          ...headers,\n          'Content-Type': 'application/json'\n        },\n        method: method || 'POST',\n        signal: signal_ || (timeout > 0 ? signal : undefined)\n      });\n      return response;\n    }, {\n      errorInstance: new request_js_1.TimeoutError({\n        body,\n        url\n      }),\n      timeout,\n      signal: true\n    });\n    let data;\n    if (response.headers.get('Content-Type')?.startsWith('application/json')) {\n      data = await response.json();\n    } else {\n      data = await response.text();\n    }\n    if (!response.ok) {\n      throw new request_js_1.HttpRequestError({\n        body,\n        details: (0, stringify_js_1.stringify)(data.error) || response.statusText,\n        headers: response.headers,\n        status: response.status,\n        url\n      });\n    }\n    return data;\n  } catch (err) {\n    if (err instanceof request_js_1.HttpRequestError) throw err;\n    if (err instanceof request_js_1.TimeoutError) throw err;\n    throw new request_js_1.HttpRequestError({\n      body,\n      details: err.message,\n      url\n    });\n  }\n}\nexports.socketsCache = new Map();\nasync function getSocket(url) {\n  let socket = exports.socketsCache.get(url);\n  if (socket) return socket;\n  const {\n    schedule\n  } = (0, createBatchScheduler_js_1.createBatchScheduler)({\n    id: url,\n    fn: async () => {\n      const webSocket = new isows_1.WebSocket(url);\n      const requests = new Map();\n      const subscriptions = new Map();\n      const onMessage = ({\n        data\n      }) => {\n        const message = JSON.parse(data);\n        const isSubscription = message.method === 'eth_subscription';\n        const id = isSubscription ? message.params.subscription : message.id;\n        const cache = isSubscription ? subscriptions : requests;\n        const callback = cache.get(id);\n        if (callback) callback({\n          data\n        });\n        if (!isSubscription) cache.delete(id);\n      };\n      const onClose = () => {\n        exports.socketsCache.delete(url);\n        webSocket.removeEventListener('close', onClose);\n        webSocket.removeEventListener('message', onMessage);\n      };\n      webSocket.addEventListener('close', onClose);\n      webSocket.addEventListener('message', onMessage);\n      if (webSocket.readyState === isows_1.WebSocket.CONNECTING) {\n        await new Promise((resolve, reject) => {\n          if (!webSocket) return;\n          webSocket.onopen = resolve;\n          webSocket.onerror = reject;\n        });\n      }\n      socket = Object.assign(webSocket, {\n        requests,\n        subscriptions\n      });\n      exports.socketsCache.set(url, socket);\n      return [socket];\n    }\n  });\n  const [_, [socket_]] = await schedule();\n  return socket_;\n}\nexports.getSocket = getSocket;\nfunction webSocket(socket, {\n  body,\n  onResponse\n}) {\n  if (socket.readyState === socket.CLOSED || socket.readyState === socket.CLOSING) throw new request_js_1.WebSocketRequestError({\n    body,\n    url: socket.url,\n    details: 'Socket is closed.'\n  });\n  const id_ = id++;\n  const callback = ({\n    data\n  }) => {\n    const message = JSON.parse(data);\n    if (typeof message.id === 'number' && id_ !== message.id) return;\n    onResponse?.(message);\n    if (body.method === 'eth_subscribe' && typeof message.result === 'string') {\n      socket.subscriptions.set(message.result, callback);\n    }\n    if (body.method === 'eth_unsubscribe') {\n      socket.subscriptions.delete(body.params?.[0]);\n    }\n  };\n  socket.requests.set(id_, callback);\n  socket.send(JSON.stringify({\n    jsonrpc: '2.0',\n    ...body,\n    id: id_\n  }));\n  return socket;\n}\nasync function webSocketAsync(socket, {\n  body,\n  timeout = 10000\n}) {\n  return (0, withTimeout_js_1.withTimeout)(() => new Promise(onResponse => exports.rpc.webSocket(socket, {\n    body,\n    onResponse\n  })), {\n    errorInstance: new request_js_1.TimeoutError({\n      body,\n      url: socket.url\n    }),\n    timeout\n  });\n}\nexports.rpc = {\n  http,\n  webSocket,\n  webSocketAsync\n};","map":{"version":3,"names":["isows_1","require","request_js_1","createBatchScheduler_js_1","withTimeout_js_1","stringify_js_1","id","http","url","body","fetchOptions","timeout","headers","method","signal","signal_","response","withTimeout","fetch","Array","isArray","stringify","map","jsonrpc","undefined","errorInstance","TimeoutError","data","get","startsWith","json","text","ok","HttpRequestError","details","error","statusText","status","err","message","exports","socketsCache","Map","getSocket","socket","schedule","createBatchScheduler","fn","webSocket","WebSocket","requests","subscriptions","onMessage","JSON","parse","isSubscription","params","subscription","cache","callback","delete","onClose","removeEventListener","addEventListener","readyState","CONNECTING","Promise","resolve","reject","onopen","onerror","Object","assign","set","_","socket_","onResponse","CLOSED","CLOSING","WebSocketRequestError","id_","result","send","webSocketAsync","rpc"],"sources":["/Users/nikhilbhatia/NIkhil/ZT-Prejects/wagmi-react-app/node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/rpc.ts"],"sourcesContent":["import { WebSocket } from 'isows'\nimport type { MessageEvent } from 'isows'\n\nimport {\n  HttpRequestError,\n  type HttpRequestErrorType,\n  TimeoutError,\n  type TimeoutErrorType,\n  WebSocketRequestError,\n} from '../errors/request.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport {\n  type CreateBatchSchedulerErrorType,\n  createBatchScheduler,\n} from './promise/createBatchScheduler.js'\nimport {\n  type WithTimeoutErrorType,\n  withTimeout,\n} from './promise/withTimeout.js'\nimport { stringify } from './stringify.js'\n\nlet id = 0\n\ntype SuccessResult<T> = {\n  method?: never\n  result: T\n  error?: never\n}\ntype ErrorResult<T> = {\n  method?: never\n  result?: never\n  error: T\n}\ntype Subscription<TResult, TError> = {\n  method: 'eth_subscription'\n  error?: never\n  result?: never\n  params: {\n    subscription: string\n  } & (\n    | {\n        result: TResult\n        error?: never\n      }\n    | {\n        result?: never\n        error: TError\n      }\n  )\n}\n\nexport type RpcRequest = { method: string; params?: any; id?: number }\n\nexport type RpcResponse<TResult = any, TError = any> = {\n  jsonrpc: `${number}`\n  id: number\n} & (\n  | SuccessResult<TResult>\n  | ErrorResult<TError>\n  | Subscription<TResult, TError>\n)\n\n///////////////////////////////////////////////////\n// HTTP\n\nexport type HttpOptions<TBody extends RpcRequest | RpcRequest[] = RpcRequest> =\n  {\n    // The RPC request body.\n    body: TBody\n    // Request configuration to pass to `fetch`.\n    fetchOptions?: Omit<RequestInit, 'body'>\n    // The timeout (in ms) for the request.\n    timeout?: number\n  }\n\nexport type HttpReturnType<\n  TBody extends RpcRequest | RpcRequest[] = RpcRequest,\n> = TBody extends RpcRequest[] ? RpcResponse[] : RpcResponse\n\nexport type HttpErrorType =\n  | HttpRequestErrorType\n  | TimeoutErrorType\n  | WithTimeoutErrorType\n  | ErrorType\n\nasync function http<TBody extends RpcRequest | RpcRequest[]>(\n  url: string,\n  { body, fetchOptions = {}, timeout = 10_000 }: HttpOptions<TBody>,\n): Promise<HttpReturnType<TBody>> {\n  const { headers, method, signal: signal_ } = fetchOptions\n  try {\n    const response = await withTimeout(\n      async ({ signal }) => {\n        const response = await fetch(url, {\n          ...fetchOptions,\n          body: Array.isArray(body)\n            ? stringify(\n                body.map((body) => ({\n                  jsonrpc: '2.0',\n                  id: body.id ?? id++,\n                  ...body,\n                })),\n              )\n            : stringify({ jsonrpc: '2.0', id: body.id ?? id++, ...body }),\n          headers: {\n            ...headers,\n            'Content-Type': 'application/json',\n          },\n          method: method || 'POST',\n          signal: signal_ || (timeout > 0 ? signal : undefined),\n        })\n        return response\n      },\n      {\n        errorInstance: new TimeoutError({ body, url }),\n        timeout,\n        signal: true,\n      },\n    )\n\n    let data\n    if (response.headers.get('Content-Type')?.startsWith('application/json')) {\n      data = await response.json()\n    } else {\n      data = await response.text()\n    }\n\n    if (!response.ok) {\n      throw new HttpRequestError({\n        body,\n        details: stringify(data.error) || response.statusText,\n        headers: response.headers,\n        status: response.status,\n        url,\n      })\n    }\n\n    return data\n  } catch (err) {\n    if (err instanceof HttpRequestError) throw err\n    if (err instanceof TimeoutError) throw err\n    throw new HttpRequestError({\n      body,\n      details: (err as Error).message,\n      url,\n    })\n  }\n}\n\n///////////////////////////////////////////////////\n// WebSocket\n\ntype Id = string | number\ntype CallbackFn = (message: any) => void\ntype CallbackMap = Map<Id, CallbackFn>\n\nexport type Socket = WebSocket & {\n  requests: CallbackMap\n  subscriptions: CallbackMap\n}\n\nexport type GetSocketErrorType = CreateBatchSchedulerErrorType | ErrorType\n\nexport const socketsCache = /*#__PURE__*/ new Map<string, Socket>()\n\nexport async function getSocket(url: string) {\n  let socket = socketsCache.get(url)\n\n  // If the socket already exists, return it.\n  if (socket) return socket\n\n  const { schedule } = createBatchScheduler<undefined, [Socket]>({\n    id: url,\n    fn: async () => {\n      const webSocket = new WebSocket(url)\n\n      // Set up a cache for incoming \"synchronous\" requests.\n      const requests = new Map<Id, CallbackFn>()\n\n      // Set up a cache for subscriptions (eth_subscribe).\n      const subscriptions = new Map<Id, CallbackFn>()\n\n      const onMessage: (event: MessageEvent) => void = ({ data }) => {\n        const message: RpcResponse = JSON.parse(data as string)\n        const isSubscription = message.method === 'eth_subscription'\n        const id = isSubscription ? message.params.subscription : message.id\n        const cache = isSubscription ? subscriptions : requests\n        const callback = cache.get(id)\n        if (callback) callback({ data })\n        if (!isSubscription) cache.delete(id)\n      }\n      const onClose = () => {\n        socketsCache.delete(url)\n        webSocket.removeEventListener('close', onClose)\n        webSocket.removeEventListener('message', onMessage)\n      }\n\n      // Setup event listeners for RPC & subscription responses.\n      webSocket.addEventListener('close', onClose)\n      webSocket.addEventListener('message', onMessage)\n\n      // Wait for the socket to open.\n      if (webSocket.readyState === WebSocket.CONNECTING) {\n        await new Promise((resolve, reject) => {\n          if (!webSocket) return\n          webSocket.onopen = resolve\n          webSocket.onerror = reject\n        })\n      }\n\n      // Create a new socket instance.\n      socket = Object.assign(webSocket, {\n        requests,\n        subscriptions,\n      })\n      socketsCache.set(url, socket)\n\n      return [socket]\n    },\n  })\n\n  const [_, [socket_]] = await schedule()\n  return socket_\n}\n\nexport type WebSocketOptions = {\n  /** The RPC request body. */\n  body: RpcRequest\n  /** The callback to invoke on response. */\n  onResponse?: (message: RpcResponse) => void\n}\n\nexport type WebSocketReturnType = Socket\n\nexport type WebSocketErrorType = WebSocketRequestError | ErrorType\n\nfunction webSocket(\n  socket: Socket,\n  { body, onResponse }: WebSocketOptions,\n): WebSocketReturnType {\n  if (\n    socket.readyState === socket.CLOSED ||\n    socket.readyState === socket.CLOSING\n  )\n    throw new WebSocketRequestError({\n      body,\n      url: socket.url,\n      details: 'Socket is closed.',\n    })\n\n  const id_ = id++\n\n  const callback = ({ data }: { data: any }) => {\n    const message: RpcResponse = JSON.parse(data)\n\n    if (typeof message.id === 'number' && id_ !== message.id) return\n\n    onResponse?.(message)\n\n    // If we are subscribing to a topic, we want to set up a listener for incoming\n    // messages.\n    if (body.method === 'eth_subscribe' && typeof message.result === 'string') {\n      socket.subscriptions.set(message.result, callback)\n    }\n\n    // If we are unsubscribing from a topic, we want to remove the listener.\n    if (body.method === 'eth_unsubscribe') {\n      socket.subscriptions.delete(body.params?.[0])\n    }\n  }\n  socket.requests.set(id_, callback)\n\n  socket.send(JSON.stringify({ jsonrpc: '2.0', ...body, id: id_ }))\n\n  return socket\n}\n\nexport type WebSocketAsyncOptions = {\n  /** The RPC request body. */\n  body: RpcRequest\n  /** The timeout (in ms) for the request. */\n  timeout?: number\n}\n\nexport type WebSocketAsyncReturnType = RpcResponse\n\nexport type WebSocketAsyncErrorType =\n  | WebSocketErrorType\n  | TimeoutErrorType\n  | WithTimeoutErrorType\n  | ErrorType\n\nasync function webSocketAsync(\n  socket: Socket,\n  { body, timeout = 10_000 }: WebSocketAsyncOptions,\n): Promise<WebSocketAsyncReturnType> {\n  return withTimeout(\n    () =>\n      new Promise<RpcResponse>((onResponse) =>\n        rpc.webSocket(socket, {\n          body,\n          onResponse,\n        }),\n      ),\n    {\n      errorInstance: new TimeoutError({ body, url: socket.url }),\n      timeout,\n    },\n  )\n}\n\n///////////////////////////////////////////////////\n\nexport const rpc = {\n  http,\n  webSocket,\n  webSocketAsync,\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}