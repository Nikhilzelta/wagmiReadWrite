{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.stringToHex = exports.numberToHex = exports.bytesToHex = exports.boolToHex = exports.toHex = void 0;\nconst encoding_js_1 = require(\"../../errors/encoding.js\");\nconst pad_js_1 = require(\"../data/pad.js\");\nconst fromHex_js_1 = require(\"./fromHex.js\");\nconst hexes = Array.from({\n  length: 256\n}, (_v, i) => i.toString(16).padStart(2, '0'));\nfunction toHex(value, opts = {}) {\n  if (typeof value === 'number' || typeof value === 'bigint') return numberToHex(value, opts);\n  if (typeof value === 'string') {\n    return stringToHex(value, opts);\n  }\n  if (typeof value === 'boolean') return boolToHex(value, opts);\n  return bytesToHex(value, opts);\n}\nexports.toHex = toHex;\nfunction boolToHex(value, opts = {}) {\n  const hex = `0x${Number(value)}`;\n  if (typeof opts.size === 'number') {\n    (0, fromHex_js_1.assertSize)(hex, {\n      size: opts.size\n    });\n    return (0, pad_js_1.pad)(hex, {\n      size: opts.size\n    });\n  }\n  return hex;\n}\nexports.boolToHex = boolToHex;\nfunction bytesToHex(value, opts = {}) {\n  let string = '';\n  for (let i = 0; i < value.length; i++) {\n    string += hexes[value[i]];\n  }\n  const hex = `0x${string}`;\n  if (typeof opts.size === 'number') {\n    (0, fromHex_js_1.assertSize)(hex, {\n      size: opts.size\n    });\n    return (0, pad_js_1.pad)(hex, {\n      dir: 'right',\n      size: opts.size\n    });\n  }\n  return hex;\n}\nexports.bytesToHex = bytesToHex;\nfunction numberToHex(value_, opts = {}) {\n  const {\n    signed,\n    size\n  } = opts;\n  const value = BigInt(value_);\n  let maxValue;\n  if (size) {\n    if (signed) maxValue = (1n << BigInt(size) * 8n - 1n) - 1n;else maxValue = 2n ** (BigInt(size) * 8n) - 1n;\n  } else if (typeof value_ === 'number') {\n    maxValue = BigInt(Number.MAX_SAFE_INTEGER);\n  }\n  const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;\n  if (maxValue && value > maxValue || value < minValue) {\n    const suffix = typeof value_ === 'bigint' ? 'n' : '';\n    throw new encoding_js_1.IntegerOutOfRangeError({\n      max: maxValue ? `${maxValue}${suffix}` : undefined,\n      min: `${minValue}${suffix}`,\n      signed,\n      size,\n      value: `${value_}${suffix}`\n    });\n  }\n  const hex = `0x${(signed && value < 0 ? (1n << BigInt(size * 8)) + BigInt(value) : value).toString(16)}`;\n  if (size) return (0, pad_js_1.pad)(hex, {\n    size\n  });\n  return hex;\n}\nexports.numberToHex = numberToHex;\nconst encoder = new TextEncoder();\nfunction stringToHex(value_, opts = {}) {\n  const value = encoder.encode(value_);\n  return bytesToHex(value, opts);\n}\nexports.stringToHex = stringToHex;","map":{"version":3,"names":["encoding_js_1","require","pad_js_1","fromHex_js_1","hexes","Array","from","length","_v","i","toString","padStart","toHex","value","opts","numberToHex","stringToHex","boolToHex","bytesToHex","exports","hex","Number","size","assertSize","pad","string","dir","value_","signed","BigInt","maxValue","MAX_SAFE_INTEGER","minValue","suffix","IntegerOutOfRangeError","max","undefined","min","encoder","TextEncoder","encode"],"sources":["/Users/nikhilbhatia/NIkhil/ZT-Prejects/wagmi-react-app/node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/encoding/toHex.ts"],"sourcesContent":["import {\n  IntegerOutOfRangeError,\n  type IntegerOutOfRangeErrorType,\n} from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type PadErrorType, pad } from '../data/pad.js'\n\nimport { type AssertSizeErrorType, assertSize } from './fromHex.js'\n\nconst hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) =>\n  i.toString(16).padStart(2, '0'),\n)\n\nexport type ToHexParameters = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number\n}\n\nexport type ToHexErrorType =\n  | BoolToHexErrorType\n  | BytesToHexErrorType\n  | NumberToHexErrorType\n  | StringToHexErrorType\n  | ErrorType\n\n/**\n * Encodes a string, number, bigint, or ByteArray into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html\n * - Example: https://viem.sh/docs/utilities/toHex.html#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world')\n * // '0x48656c6c6f20776f726c6421'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex(420)\n * // '0x1a4'\n *\n * @example\n * import { toHex } from 'viem'\n * const data = toHex('Hello world', { size: 32 })\n * // '0x48656c6c6f20776f726c64210000000000000000000000000000000000000000'\n */\nexport function toHex(\n  value: string | number | bigint | boolean | ByteArray,\n  opts: ToHexParameters = {},\n): Hex {\n  if (typeof value === 'number' || typeof value === 'bigint')\n    return numberToHex(value, opts)\n  if (typeof value === 'string') {\n    return stringToHex(value, opts)\n  }\n  if (typeof value === 'boolean') return boolToHex(value, opts)\n  return bytesToHex(value, opts)\n}\n\nexport type BoolToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number\n}\n\nexport type BoolToHexErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a boolean into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html#booltohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true)\n * // '0x1'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(false)\n * // '0x0'\n *\n * @example\n * import { boolToHex } from 'viem'\n * const data = boolToHex(true, { size: 32 })\n * // '0x0000000000000000000000000000000000000000000000000000000000000001'\n */\nexport function boolToHex(value: boolean, opts: BoolToHexOpts = {}): Hex {\n  const hex: Hex = `0x${Number(value)}`\n  if (typeof opts.size === 'number') {\n    assertSize(hex, { size: opts.size })\n    return pad(hex, { size: opts.size })\n  }\n  return hex\n}\n\nexport type BytesToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number\n}\n\nexport type BytesToHexErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a bytes array into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html#bytestohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { bytesToHex } from 'viem'\n * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function bytesToHex(value: ByteArray, opts: BytesToHexOpts = {}): Hex {\n  let string = ''\n  for (let i = 0; i < value.length; i++) {\n    string += hexes[value[i]]\n  }\n  const hex = `0x${string}` as const\n\n  if (typeof opts.size === 'number') {\n    assertSize(hex, { size: opts.size })\n    return pad(hex, { dir: 'right', size: opts.size })\n  }\n  return hex\n}\n\nexport type NumberToHexOpts =\n  | {\n      /** Whether or not the number of a signed representation. */\n      signed?: boolean\n      /** The size (in bytes) of the output hex value. */\n      size: number\n    }\n  | {\n      signed?: never\n      /** The size (in bytes) of the output hex value. */\n      size?: number\n    }\n\nexport type NumberToHexErrorType =\n  | IntegerOutOfRangeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a number or bigint into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html#numbertohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420)\n * // '0x1a4'\n *\n * @example\n * import { numberToHex } from 'viem'\n * const data = numberToHex(420, { size: 32 })\n * // '0x00000000000000000000000000000000000000000000000000000000000001a4'\n */\nexport function numberToHex(\n  value_: number | bigint,\n  opts: NumberToHexOpts = {},\n): Hex {\n  const { signed, size } = opts\n\n  const value = BigInt(value_)\n\n  let maxValue\n  if (size) {\n    if (signed) maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n\n    else maxValue = 2n ** (BigInt(size) * 8n) - 1n\n  } else if (typeof value_ === 'number') {\n    maxValue = BigInt(Number.MAX_SAFE_INTEGER)\n  }\n\n  const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0\n\n  if ((maxValue && value > maxValue) || value < minValue) {\n    const suffix = typeof value_ === 'bigint' ? 'n' : ''\n    throw new IntegerOutOfRangeError({\n      max: maxValue ? `${maxValue}${suffix}` : undefined,\n      min: `${minValue}${suffix}`,\n      signed,\n      size,\n      value: `${value_}${suffix}`,\n    })\n  }\n\n  const hex = `0x${(signed && value < 0\n    ? (1n << BigInt(size * 8)) + BigInt(value)\n    : value\n  ).toString(16)}` as Hex\n  if (size) return pad(hex, { size }) as Hex\n  return hex\n}\n\nexport type StringToHexOpts = {\n  /** The size (in bytes) of the output hex value. */\n  size?: number\n}\n\nexport type StringToHexErrorType = BytesToHexErrorType | ErrorType\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\n/**\n * Encodes a UTF-8 string into a hex string\n *\n * - Docs: https://viem.sh/docs/utilities/toHex.html#stringtohex\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Hex value.\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * @example\n * import { stringToHex } from 'viem'\n * const data = stringToHex('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n */\nexport function stringToHex(value_: string, opts: StringToHexOpts = {}): Hex {\n  const value = encoder.encode(value_)\n  return bytesToHex(value, opts)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}