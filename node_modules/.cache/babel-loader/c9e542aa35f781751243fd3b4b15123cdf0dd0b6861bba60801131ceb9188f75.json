{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeAbiParameters = void 0;\nconst abi_js_1 = require(\"../../errors/abi.js\");\nconst getAddress_js_1 = require(\"../address/getAddress.js\");\nconst size_js_1 = require(\"../data/size.js\");\nconst slice_js_1 = require(\"../data/slice.js\");\nconst trim_js_1 = require(\"../data/trim.js\");\nconst fromHex_js_1 = require(\"../encoding/fromHex.js\");\nconst encodeAbiParameters_js_1 = require(\"./encodeAbiParameters.js\");\nfunction decodeAbiParameters(params, data) {\n  if (data === '0x' && params.length > 0) throw new abi_js_1.AbiDecodingZeroDataError();\n  if ((0, size_js_1.size)(data) && (0, size_js_1.size)(data) < 32) throw new abi_js_1.AbiDecodingDataSizeTooSmallError({\n    data,\n    params: params,\n    size: (0, size_js_1.size)(data)\n  });\n  return decodeParams({\n    data,\n    params: params\n  });\n}\nexports.decodeAbiParameters = decodeAbiParameters;\nfunction decodeParams({\n  data,\n  params\n}) {\n  const decodedValues = [];\n  let position = 0;\n  for (let i = 0; i < params.length; i++) {\n    if (position >= (0, size_js_1.size)(data)) throw new abi_js_1.AbiDecodingDataSizeTooSmallError({\n      data,\n      params,\n      size: (0, size_js_1.size)(data)\n    });\n    const param = params[i];\n    const {\n      consumed,\n      value\n    } = decodeParam({\n      data,\n      param,\n      position\n    });\n    decodedValues.push(value);\n    position += consumed;\n  }\n  return decodedValues;\n}\nfunction decodeParam({\n  data,\n  param,\n  position\n}) {\n  const arrayComponents = (0, encodeAbiParameters_js_1.getArrayComponents)(param.type);\n  if (arrayComponents) {\n    const [length, type] = arrayComponents;\n    return decodeArray(data, {\n      length,\n      param: {\n        ...param,\n        type: type\n      },\n      position\n    });\n  }\n  if (param.type === 'tuple') {\n    return decodeTuple(data, {\n      param: param,\n      position\n    });\n  }\n  if (param.type === 'string') {\n    return decodeString(data, {\n      position\n    });\n  }\n  if (param.type.startsWith('bytes')) {\n    return decodeBytes(data, {\n      param,\n      position\n    });\n  }\n  const value = (0, slice_js_1.slice)(data, position, position + 32, {\n    strict: true\n  });\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) {\n    return decodeNumber(value, {\n      param\n    });\n  }\n  if (param.type === 'address') {\n    return decodeAddress(value);\n  }\n  if (param.type === 'bool') {\n    return decodeBool(value);\n  }\n  throw new abi_js_1.InvalidAbiDecodingTypeError(param.type, {\n    docsPath: '/docs/contract/decodeAbiParameters'\n  });\n}\nfunction decodeAddress(value) {\n  return {\n    consumed: 32,\n    value: (0, getAddress_js_1.checksumAddress)((0, slice_js_1.slice)(value, -20))\n  };\n}\nfunction decodeArray(data, {\n  param,\n  length,\n  position\n}) {\n  if (!length) {\n    const offset = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, position, position + 32, {\n      strict: true\n    }));\n    const length = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, offset, offset + 32, {\n      strict: true\n    }));\n    let consumed = 0;\n    const value = [];\n    for (let i = 0; i < length; ++i) {\n      const decodedChild = decodeParam({\n        data: (0, slice_js_1.slice)(data, offset + 32),\n        param,\n        position: consumed\n      });\n      consumed += decodedChild.consumed;\n      value.push(decodedChild.value);\n    }\n    return {\n      value,\n      consumed: 32\n    };\n  }\n  if (hasDynamicChild(param)) {\n    const arrayComponents = (0, encodeAbiParameters_js_1.getArrayComponents)(param.type);\n    const dynamicChild = !arrayComponents?.[0];\n    let consumed = 0;\n    const value = [];\n    for (let i = 0; i < length; ++i) {\n      const offset = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, position, position + 32, {\n        strict: true\n      }));\n      const decodedChild = decodeParam({\n        data: (0, slice_js_1.slice)(data, offset),\n        param,\n        position: dynamicChild ? consumed : i * 32\n      });\n      consumed += decodedChild.consumed;\n      value.push(decodedChild.value);\n    }\n    return {\n      value,\n      consumed: 32\n    };\n  }\n  let consumed = 0;\n  const value = [];\n  for (let i = 0; i < length; ++i) {\n    const decodedChild = decodeParam({\n      data,\n      param,\n      position: position + consumed\n    });\n    consumed += decodedChild.consumed;\n    value.push(decodedChild.value);\n  }\n  return {\n    value,\n    consumed\n  };\n}\nfunction decodeBool(value) {\n  return {\n    consumed: 32,\n    value: (0, fromHex_js_1.hexToBool)(value)\n  };\n}\nfunction decodeBytes(data, {\n  param,\n  position\n}) {\n  const [_, size] = param.type.split('bytes');\n  if (!size) {\n    const offset = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, position, position + 32, {\n      strict: true\n    }));\n    const length = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, offset, offset + 32, {\n      strict: true\n    }));\n    if (length === 0) return {\n      consumed: 32,\n      value: '0x'\n    };\n    const value = (0, slice_js_1.slice)(data, offset + 32, offset + 32 + length, {\n      strict: true\n    });\n    return {\n      consumed: 32,\n      value\n    };\n  }\n  const value = (0, slice_js_1.slice)(data, position, position + parseInt(size), {\n    strict: true\n  });\n  return {\n    consumed: 32,\n    value\n  };\n}\nfunction decodeNumber(value, {\n  param\n}) {\n  const signed = param.type.startsWith('int');\n  const size = parseInt(param.type.split('int')[1] || '256');\n  return {\n    consumed: 32,\n    value: size > 48 ? (0, fromHex_js_1.hexToBigInt)(value, {\n      signed\n    }) : (0, fromHex_js_1.hexToNumber)(value, {\n      signed\n    })\n  };\n}\nfunction decodeString(data, {\n  position\n}) {\n  const offset = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, position, position + 32, {\n    strict: true\n  }));\n  const length = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, offset, offset + 32, {\n    strict: true\n  }));\n  if (length === 0) return {\n    consumed: 32,\n    value: ''\n  };\n  const value = (0, fromHex_js_1.hexToString)((0, trim_js_1.trim)((0, slice_js_1.slice)(data, offset + 32, offset + 32 + length, {\n    strict: true\n  })));\n  return {\n    consumed: 32,\n    value\n  };\n}\nfunction decodeTuple(data, {\n  param,\n  position\n}) {\n  const hasUnnamedChild = param.components.length === 0 || param.components.some(({\n    name\n  }) => !name);\n  const value = hasUnnamedChild ? [] : {};\n  let consumed = 0;\n  if (hasDynamicChild(param)) {\n    const offset = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, position, position + 32, {\n      strict: true\n    }));\n    for (let i = 0; i < param.components.length; ++i) {\n      const component = param.components[i];\n      const decodedChild = decodeParam({\n        data: (0, slice_js_1.slice)(data, offset),\n        param: component,\n        position: consumed\n      });\n      consumed += decodedChild.consumed;\n      value[hasUnnamedChild ? i : component?.name] = decodedChild.value;\n    }\n    return {\n      consumed: 32,\n      value\n    };\n  }\n  for (let i = 0; i < param.components.length; ++i) {\n    const component = param.components[i];\n    const decodedChild = decodeParam({\n      data,\n      param: component,\n      position: position + consumed\n    });\n    consumed += decodedChild.consumed;\n    value[hasUnnamedChild ? i : component?.name] = decodedChild.value;\n  }\n  return {\n    consumed,\n    value\n  };\n}\nfunction hasDynamicChild(param) {\n  const {\n    type\n  } = param;\n  if (type === 'string') return true;\n  if (type === 'bytes') return true;\n  if (type.endsWith('[]')) return true;\n  if (type === 'tuple') return param.components?.some(hasDynamicChild);\n  const arrayComponents = (0, encodeAbiParameters_js_1.getArrayComponents)(param.type);\n  if (arrayComponents && hasDynamicChild({\n    ...param,\n    type: arrayComponents[1]\n  })) return true;\n  return false;\n}","map":{"version":3,"names":["abi_js_1","require","getAddress_js_1","size_js_1","slice_js_1","trim_js_1","fromHex_js_1","encodeAbiParameters_js_1","decodeAbiParameters","params","data","length","AbiDecodingZeroDataError","size","AbiDecodingDataSizeTooSmallError","decodeParams","exports","decodedValues","position","i","param","consumed","value","decodeParam","push","arrayComponents","getArrayComponents","type","decodeArray","decodeTuple","decodeString","startsWith","decodeBytes","slice","strict","decodeNumber","decodeAddress","decodeBool","InvalidAbiDecodingTypeError","docsPath","checksumAddress","offset","hexToNumber","decodedChild","hasDynamicChild","dynamicChild","hexToBool","_","split","parseInt","signed","hexToBigInt","hexToString","trim","hasUnnamedChild","components","some","name","component","endsWith"],"sources":["/Users/nikhilbhatia/NIkhil/ZT-Prejects/wagmi-react-app/node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/abi/decodeAbiParameters.ts"],"sourcesContent":["import type {\n  AbiParameter,\n  AbiParameterToPrimitiveType,\n  AbiParametersToPrimitiveTypes,\n} from 'abitype'\n\nimport {\n  AbiDecodingDataSizeTooSmallError,\n  type AbiDecodingDataSizeTooSmallErrorType,\n  AbiDecodingZeroDataError,\n  type AbiDecodingZeroDataErrorType,\n  InvalidAbiDecodingTypeError,\n  type InvalidAbiDecodingTypeErrorType,\n} from '../../errors/abi.js'\nimport type { Hex } from '../../types/misc.js'\nimport {\n  type ChecksumAddressErrorType,\n  checksumAddress,\n} from '../address/getAddress.js'\nimport { type SizeErrorType, size } from '../data/size.js'\nimport { type SliceErrorType, slice } from '../data/slice.js'\nimport { type TrimErrorType, trim } from '../data/trim.js'\nimport {\n  type HexToBigIntErrorType,\n  type HexToBoolErrorType,\n  type HexToNumberErrorType,\n  type HexToStringErrorType,\n  hexToBigInt,\n  hexToBool,\n  hexToNumber,\n  hexToString,\n} from '../encoding/fromHex.js'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport {\n  type GetArrayComponentsErrorType,\n  getArrayComponents,\n} from './encodeAbiParameters.js'\n\nexport type DecodeAbiParametersReturnType<\n  TParams extends\n    | readonly AbiParameter[]\n    | readonly unknown[] = readonly AbiParameter[],\n> = AbiParametersToPrimitiveTypes<\n  TParams extends readonly AbiParameter[] ? TParams : AbiParameter[]\n>\n\nexport type DecodeAbiParametersErrorType =\n  | AbiDecodingDataSizeTooSmallErrorType\n  | AbiDecodingZeroDataErrorType\n  | DecodeParamsErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function decodeAbiParameters<\n  const TParams extends readonly AbiParameter[] | readonly unknown[],\n>(params: TParams, data: Hex): DecodeAbiParametersReturnType<TParams> {\n  if (data === '0x' && (params as unknown[]).length > 0)\n    throw new AbiDecodingZeroDataError()\n  if (size(data) && size(data) < 32)\n    throw new AbiDecodingDataSizeTooSmallError({\n      data,\n      params: params as readonly AbiParameter[],\n      size: size(data),\n    })\n  return decodeParams({\n    data,\n    params: params as readonly AbiParameter[],\n  }) as unknown as DecodeAbiParametersReturnType<TParams>\n}\n\n////////////////////////////////////////////////////////////////////\n\ntype TupleAbiParameter = AbiParameter & { components: readonly AbiParameter[] }\n\ntype DecodeParamsErrorType = DecodeParamErrorType | SizeErrorType | ErrorType\n\nfunction decodeParams<const TParams extends readonly AbiParameter[]>({\n  data,\n  params,\n}: { data: Hex; params: TParams }) {\n  const decodedValues: unknown[] = []\n  let position = 0\n\n  for (let i = 0; i < params.length; i++) {\n    if (position >= size(data))\n      throw new AbiDecodingDataSizeTooSmallError({\n        data,\n        params,\n        size: size(data),\n      })\n\n    const param = params[i]\n    const { consumed, value } = decodeParam({ data, param, position })\n    decodedValues.push(value)\n    // Step across the data by the amount of data consumed by this parameter.\n    position += consumed\n  }\n\n  return decodedValues as unknown as AbiParametersToPrimitiveTypes<TParams>\n}\n\ntype DecodeParamErrorType =\n  | DecodeArrayErrorType\n  | DecodeTupleErrorType\n  | DecodeStringErrorType\n  | DecodeBytesErrorType\n  | DecodeNumberErrorType\n  | DecodeAddressErrorType\n  | DecodeBoolErrorType\n  | InvalidAbiDecodingTypeErrorType\n  | ErrorType\n\nfunction decodeParam({\n  data,\n  param,\n  position,\n}: { data: Hex; param: AbiParameter; position: number }): {\n  consumed: number\n  value: any\n} {\n  const arrayComponents = getArrayComponents(param.type)\n  if (arrayComponents) {\n    const [length, type] = arrayComponents\n    return decodeArray(data, {\n      length,\n      param: { ...param, type: type } as AbiParameter,\n      position,\n    })\n  }\n  if (param.type === 'tuple') {\n    return decodeTuple(data, { param: param as TupleAbiParameter, position })\n  }\n  if (param.type === 'string') {\n    return decodeString(data, { position })\n  }\n  if (param.type.startsWith('bytes')) {\n    return decodeBytes(data, { param, position })\n  }\n\n  const value = slice(data, position, position + 32, { strict: true }) as Hex\n  if (param.type.startsWith('uint') || param.type.startsWith('int')) {\n    return decodeNumber(value, { param })\n  }\n  if (param.type === 'address') {\n    return decodeAddress(value)\n  }\n  if (param.type === 'bool') {\n    return decodeBool(value)\n  }\n  throw new InvalidAbiDecodingTypeError(param.type, {\n    docsPath: '/docs/contract/decodeAbiParameters',\n  })\n}\n\n////////////////////////////////////////////////////////////////////\n\ntype DecodeAddressErrorType =\n  | ChecksumAddressErrorType\n  | SliceErrorType\n  | ErrorType\n\nfunction decodeAddress(value: Hex) {\n  return { consumed: 32, value: checksumAddress(slice(value, -20)) }\n}\n\ntype DecodeArrayErrorType = HexToNumberErrorType | SliceErrorType | ErrorType\n\nfunction decodeArray<const TParam extends AbiParameter>(\n  data: Hex,\n  {\n    param,\n    length,\n    position,\n  }: {\n    param: TParam\n    length: number | null\n    position: number\n  },\n) {\n  // If the length of the array is not known in advance (dynamic array),\n  // we will need to decode the offset of the array data.\n  if (!length) {\n    // Get the offset of the array data.\n    const offset = hexToNumber(\n      slice(data, position, position + 32, { strict: true }),\n    )\n    // Get the length of the array from the offset.\n    const length = hexToNumber(\n      slice(data, offset, offset + 32, { strict: true }),\n    )\n\n    let consumed = 0\n    const value: AbiParameterToPrimitiveType<TParam>[] = []\n    for (let i = 0; i < length; ++i) {\n      const decodedChild = decodeParam({\n        data: slice(data, offset + 32),\n        param,\n        position: consumed,\n      })\n      consumed += decodedChild.consumed\n      value.push(decodedChild.value)\n    }\n    return { value, consumed: 32 }\n  }\n\n  // If the length of the array is known in advance,\n  // and the length of an element deeply nested in the array is not known,\n  // we need to decode the offset of the array data.\n  if (hasDynamicChild(param)) {\n    // Get the child type of the array.\n    const arrayComponents = getArrayComponents(param.type)\n    // If the child type is not known, the array is dynamic.\n    const dynamicChild = !arrayComponents?.[0]\n\n    let consumed = 0\n    const value: AbiParameterToPrimitiveType<TParam>[] = []\n    for (let i = 0; i < length; ++i) {\n      const offset = hexToNumber(\n        slice(data, position, position + 32, { strict: true }),\n      )\n      const decodedChild = decodeParam({\n        data: slice(data, offset),\n        param,\n        position: dynamicChild ? consumed : i * 32,\n      })\n      consumed += decodedChild.consumed\n      value.push(decodedChild.value)\n    }\n    return { value, consumed: 32 }\n  }\n\n  // If the length of the array is known in advance,\n  // and the length of each element in the array is known,\n  // the array data is encoded contiguously after the array.\n  let consumed = 0\n  const value: AbiParameterToPrimitiveType<TParam>[] = []\n  for (let i = 0; i < length; ++i) {\n    const decodedChild = decodeParam({\n      data,\n      param,\n      position: position + consumed,\n    })\n    consumed += decodedChild.consumed\n    value.push(decodedChild.value)\n  }\n  return { value, consumed }\n}\n\ntype DecodeBoolErrorType = HexToBoolErrorType | ErrorType\n\nfunction decodeBool(value: Hex) {\n  return { consumed: 32, value: hexToBool(value) }\n}\n\ntype DecodeBytesErrorType = HexToNumberErrorType | SliceErrorType | ErrorType\n\nfunction decodeBytes<const TParam extends AbiParameter>(\n  data: Hex,\n  { param, position }: { param: TParam; position: number },\n) {\n  const [_, size] = param.type.split('bytes')\n  if (!size) {\n    // If we don't have a size, we're dealing with a dynamic-size array\n    // so we need to read the offset of the data part first.\n    const offset = hexToNumber(\n      slice(data, position, position + 32, { strict: true }),\n    )\n    const length = hexToNumber(\n      slice(data, offset, offset + 32, { strict: true }),\n    )\n    // If there is no length, we have zero data.\n    if (length === 0) return { consumed: 32, value: '0x' }\n    const value = slice(data, offset + 32, offset + 32 + length, {\n      strict: true,\n    })\n    return { consumed: 32, value }\n  }\n\n  const value = slice(data, position, position + parseInt(size), {\n    strict: true,\n  })\n  return { consumed: 32, value }\n}\n\ntype DecodeNumberErrorType =\n  | HexToBigIntErrorType\n  | HexToNumberErrorType\n  | ErrorType\n\nfunction decodeNumber<const TParam extends AbiParameter>(\n  value: Hex,\n  { param }: { param: TParam },\n) {\n  const signed = param.type.startsWith('int')\n  const size = parseInt(param.type.split('int')[1] || '256')\n  return {\n    consumed: 32,\n    value:\n      size > 48\n        ? hexToBigInt(value, { signed })\n        : hexToNumber(value, { signed }),\n  }\n}\n\ntype DecodeStringErrorType =\n  | HexToNumberErrorType\n  | HexToStringErrorType\n  | SliceErrorType\n  | TrimErrorType\n  | ErrorType\n\nfunction decodeString(data: Hex, { position }: { position: number }) {\n  const offset = hexToNumber(\n    slice(data, position, position + 32, { strict: true }),\n  )\n  const length = hexToNumber(slice(data, offset, offset + 32, { strict: true }))\n  // If there is no length, we have zero data (empty string).\n  if (length === 0) return { consumed: 32, value: '' }\n  const value = hexToString(\n    trim(slice(data, offset + 32, offset + 32 + length, { strict: true })),\n  )\n  return { consumed: 32, value }\n}\n\ntype DecodeTupleErrorType =\n  | HasDynamicChildErrorType\n  | HexToNumberErrorType\n  | SliceErrorType\n  | ErrorType\n\nfunction decodeTuple<\n  const TParam extends AbiParameter & { components: readonly AbiParameter[] },\n>(data: Hex, { param, position }: { param: TParam; position: number }) {\n  // Tuples can have unnamed components (i.e. they are arrays), so we must\n  // determine whether the tuple is named or unnamed. In the case of a named\n  // tuple, the value will be an object where each property is the name of the\n  // component. In the case of an unnamed tuple, the value will be an array.\n  const hasUnnamedChild =\n    param.components.length === 0 || param.components.some(({ name }) => !name)\n\n  // Initialize the value to an object or an array, depending on whether the\n  // tuple is named or unnamed.\n  const value: any = hasUnnamedChild ? [] : {}\n  let consumed = 0\n\n  // If the tuple has a dynamic child, we must first decode the offset to the\n  // tuple data.\n  if (hasDynamicChild(param)) {\n    const offset = hexToNumber(\n      slice(data, position, position + 32, { strict: true }),\n    )\n    // Decode each component of the tuple, starting at the offset.\n    for (let i = 0; i < param.components.length; ++i) {\n      const component = param.components[i]\n      const decodedChild = decodeParam({\n        data: slice(data, offset),\n        param: component,\n        position: consumed,\n      })\n      consumed += decodedChild.consumed\n      value[hasUnnamedChild ? i : component?.name!] = decodedChild.value\n    }\n    return { consumed: 32, value }\n  }\n\n  // If the tuple has static children, we can just decode each component\n  // in sequence.\n  for (let i = 0; i < param.components.length; ++i) {\n    const component = param.components[i]\n    const decodedChild = decodeParam({\n      data,\n      param: component,\n      position: position + consumed,\n    })\n    consumed += decodedChild.consumed\n    value[hasUnnamedChild ? i : component?.name!] = decodedChild.value\n  }\n  return { consumed, value }\n}\n\ntype HasDynamicChildErrorType = GetArrayComponentsErrorType | ErrorType\n\nfunction hasDynamicChild(param: AbiParameter) {\n  const { type } = param\n  if (type === 'string') return true\n  if (type === 'bytes') return true\n  if (type.endsWith('[]')) return true\n\n  if (type === 'tuple') return (param as any).components?.some(hasDynamicChild)\n\n  const arrayComponents = getArrayComponents(param.type)\n  if (\n    arrayComponents &&\n    hasDynamicChild({ ...param, type: arrayComponents[1] } as AbiParameter)\n  )\n    return true\n\n  return false\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}