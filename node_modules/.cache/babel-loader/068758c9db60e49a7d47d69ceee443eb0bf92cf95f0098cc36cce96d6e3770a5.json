{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeEventLog = void 0;\nconst abi_js_1 = require(\"../../errors/abi.js\");\nconst getEventSelector_js_1 = require(\"../hash/getEventSelector.js\");\nconst decodeAbiParameters_js_1 = require(\"./decodeAbiParameters.js\");\nconst formatAbiItem_js_1 = require(\"./formatAbiItem.js\");\nconst docsPath = '/docs/contract/decodeEventLog';\nfunction decodeEventLog({\n  abi,\n  data,\n  strict: strict_,\n  topics\n}) {\n  const strict = strict_ ?? true;\n  const [signature, ...argTopics] = topics;\n  if (!signature) throw new abi_js_1.AbiEventSignatureEmptyTopicsError({\n    docsPath\n  });\n  const abiItem = abi.find(x => x.type === 'event' && signature === (0, getEventSelector_js_1.getEventSelector)((0, formatAbiItem_js_1.formatAbiItem)(x)));\n  if (!(abiItem && 'name' in abiItem) || abiItem.type !== 'event') throw new abi_js_1.AbiEventSignatureNotFoundError(signature, {\n    docsPath\n  });\n  const {\n    name,\n    inputs\n  } = abiItem;\n  const isUnnamed = inputs?.some(x => !('name' in x && x.name));\n  let args = isUnnamed ? [] : {};\n  const indexedInputs = inputs.filter(x => 'indexed' in x && x.indexed);\n  for (let i = 0; i < indexedInputs.length; i++) {\n    const param = indexedInputs[i];\n    const topic = argTopics[i];\n    if (!topic) throw new abi_js_1.DecodeLogTopicsMismatch({\n      abiItem,\n      param: param\n    });\n    args[param.name || i] = decodeTopic({\n      param,\n      value: topic\n    });\n  }\n  const nonIndexedInputs = inputs.filter(x => !('indexed' in x && x.indexed));\n  if (nonIndexedInputs.length > 0) {\n    if (data && data !== '0x') {\n      try {\n        const decodedData = (0, decodeAbiParameters_js_1.decodeAbiParameters)(nonIndexedInputs, data);\n        if (decodedData) {\n          if (isUnnamed) args = [...args, ...decodedData];else {\n            for (let i = 0; i < nonIndexedInputs.length; i++) {\n              args[nonIndexedInputs[i].name] = decodedData[i];\n            }\n          }\n        }\n      } catch (err) {\n        if (strict) {\n          if (err instanceof abi_js_1.AbiDecodingDataSizeTooSmallError) throw new abi_js_1.DecodeLogDataMismatch({\n            abiItem,\n            data: err.data,\n            params: err.params,\n            size: err.size\n          });\n          throw err;\n        }\n      }\n    } else if (strict) {\n      throw new abi_js_1.DecodeLogDataMismatch({\n        abiItem,\n        data: '0x',\n        params: nonIndexedInputs,\n        size: 0\n      });\n    }\n  }\n  return {\n    eventName: name,\n    args: Object.values(args).length > 0 ? args : undefined\n  };\n}\nexports.decodeEventLog = decodeEventLog;\nfunction decodeTopic({\n  param,\n  value\n}) {\n  if (param.type === 'string' || param.type === 'bytes' || param.type === 'tuple' || param.type.match(/^(.*)\\[(\\d+)?\\]$/)) return value;\n  const decodedArg = (0, decodeAbiParameters_js_1.decodeAbiParameters)([param], value) || [];\n  return decodedArg[0];\n}","map":{"version":3,"names":["abi_js_1","require","getEventSelector_js_1","decodeAbiParameters_js_1","formatAbiItem_js_1","docsPath","decodeEventLog","abi","data","strict","strict_","topics","signature","argTopics","AbiEventSignatureEmptyTopicsError","abiItem","find","x","type","getEventSelector","formatAbiItem","AbiEventSignatureNotFoundError","name","inputs","isUnnamed","some","args","indexedInputs","filter","indexed","i","length","param","topic","DecodeLogTopicsMismatch","decodeTopic","value","nonIndexedInputs","decodedData","decodeAbiParameters","err","AbiDecodingDataSizeTooSmallError","DecodeLogDataMismatch","params","size","eventName","Object","values","undefined","exports","match","decodedArg"],"sources":["/Users/nikhilbhatia/NIkhil/ZT-Prejects/wagmi-react-app/node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/abi/decodeEventLog.ts"],"sourcesContent":["import type { Abi, AbiParameter, ExtractAbiEventNames } from 'abitype'\n\nimport {\n  AbiDecodingDataSizeTooSmallError,\n  type AbiDecodingDataSizeTooSmallErrorType,\n  AbiEventSignatureEmptyTopicsError,\n  type AbiEventSignatureEmptyTopicsErrorType,\n  AbiEventSignatureNotFoundError,\n  type AbiEventSignatureNotFoundErrorType,\n  DecodeLogDataMismatch,\n  type DecodeLogDataMismatchErrorType,\n  DecodeLogTopicsMismatch,\n  type DecodeLogTopicsMismatchErrorType,\n} from '../../errors/abi.js'\nimport type {\n  EventDefinition,\n  GetEventArgsFromTopics,\n  InferEventName,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { Prettify } from '../../types/utils.js'\nimport {\n  type GetEventSelectorErrorType,\n  getEventSelector,\n} from '../hash/getEventSelector.js'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport {\n  type DecodeAbiParametersErrorType,\n  decodeAbiParameters,\n} from './decodeAbiParameters.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\n\nexport type DecodeEventLogParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TEventName extends string | undefined = string,\n  TTopics extends Hex[] = Hex[],\n  TData extends Hex | undefined = undefined,\n  TStrict extends boolean = true,\n> = {\n  abi: TAbi\n  data?: TData\n  eventName?: InferEventName<TAbi, TEventName>\n  strict?: TStrict\n  topics: [signature: Hex, ...args: TTopics] | []\n}\n\nexport type DecodeEventLogReturnType<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  TEventName extends string | undefined = string,\n  TTopics extends Hex[] = Hex[],\n  TData extends Hex | undefined = undefined,\n  TStrict extends boolean = true,\n  _EventNames extends string = TAbi extends Abi\n    ? Abi extends TAbi\n      ? string\n      : ExtractAbiEventNames<TAbi>\n    : string,\n> = TEventName extends _EventNames[number]\n  ? Prettify<\n      {\n        eventName: TEventName\n      } & GetEventArgsFromTopics<TAbi, TEventName, TTopics, TData, TStrict>\n    >\n  : {\n      [TName in _EventNames]: Prettify<\n        {\n          eventName: TName\n        } & GetEventArgsFromTopics<TAbi, TName, TTopics, TData, TStrict>\n      >\n    }[_EventNames]\n\nexport type DecodeEventLogErrorType =\n  | AbiDecodingDataSizeTooSmallErrorType\n  | AbiEventSignatureEmptyTopicsErrorType\n  | AbiEventSignatureNotFoundErrorType\n  | DecodeAbiParametersErrorType\n  | DecodeLogTopicsMismatchErrorType\n  | DecodeLogDataMismatchErrorType\n  | FormatAbiItemErrorType\n  | GetEventSelectorErrorType\n  | ErrorType\n\nconst docsPath = '/docs/contract/decodeEventLog'\n\nexport function decodeEventLog<\n  const TAbi extends Abi | readonly unknown[],\n  TEventName extends string | undefined = undefined,\n  TTopics extends Hex[] = Hex[],\n  TData extends Hex | undefined = undefined,\n  TStrict extends boolean = true,\n>({\n  abi,\n  data,\n  strict: strict_,\n  topics,\n}: DecodeEventLogParameters<\n  TAbi,\n  TEventName,\n  TTopics,\n  TData,\n  TStrict\n>): DecodeEventLogReturnType<TAbi, TEventName, TTopics, TData, TStrict> {\n  const strict = strict_ ?? true\n  const [signature, ...argTopics] = topics\n  if (!signature)\n    throw new AbiEventSignatureEmptyTopicsError({\n      docsPath,\n    })\n  const abiItem = (abi as Abi).find(\n    (x) =>\n      x.type === 'event' &&\n      signature === getEventSelector(formatAbiItem(x) as EventDefinition),\n  )\n  if (!(abiItem && 'name' in abiItem) || abiItem.type !== 'event')\n    throw new AbiEventSignatureNotFoundError(signature, {\n      docsPath,\n    })\n\n  const { name, inputs } = abiItem\n  const isUnnamed = inputs?.some((x) => !('name' in x && x.name))\n\n  let args: any = isUnnamed ? [] : {}\n\n  // Decode topics (indexed args).\n  const indexedInputs = inputs.filter((x) => 'indexed' in x && x.indexed)\n  for (let i = 0; i < indexedInputs.length; i++) {\n    const param = indexedInputs[i]\n    const topic = argTopics[i]\n    if (!topic)\n      throw new DecodeLogTopicsMismatch({\n        abiItem,\n        param: param as AbiParameter & { indexed: boolean },\n      })\n    args[param.name || i] = decodeTopic({ param, value: topic })\n  }\n\n  // Decode data (non-indexed args).\n  const nonIndexedInputs = inputs.filter((x) => !('indexed' in x && x.indexed))\n  if (nonIndexedInputs.length > 0) {\n    if (data && data !== '0x') {\n      try {\n        const decodedData = decodeAbiParameters(nonIndexedInputs, data)\n        if (decodedData) {\n          if (isUnnamed) args = [...args, ...decodedData]\n          else {\n            for (let i = 0; i < nonIndexedInputs.length; i++) {\n              args[nonIndexedInputs[i].name!] = decodedData[i]\n            }\n          }\n        }\n      } catch (err) {\n        if (strict) {\n          if (err instanceof AbiDecodingDataSizeTooSmallError)\n            throw new DecodeLogDataMismatch({\n              abiItem,\n              data: err.data,\n              params: err.params,\n              size: err.size,\n            })\n          throw err\n        }\n      }\n    } else if (strict) {\n      throw new DecodeLogDataMismatch({\n        abiItem,\n        data: '0x',\n        params: nonIndexedInputs,\n        size: 0,\n      })\n    }\n  }\n\n  return {\n    eventName: name,\n    args: Object.values(args).length > 0 ? args : undefined,\n  } as unknown as DecodeEventLogReturnType<\n    TAbi,\n    TEventName,\n    TTopics,\n    TData,\n    TStrict\n  >\n}\n\nfunction decodeTopic({ param, value }: { param: AbiParameter; value: Hex }) {\n  if (\n    param.type === 'string' ||\n    param.type === 'bytes' ||\n    param.type === 'tuple' ||\n    param.type.match(/^(.*)\\[(\\d+)?\\]$/)\n  )\n    return value\n  const decodedArg = decodeAbiParameters([param], value) || []\n  return decodedArg[0]\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}