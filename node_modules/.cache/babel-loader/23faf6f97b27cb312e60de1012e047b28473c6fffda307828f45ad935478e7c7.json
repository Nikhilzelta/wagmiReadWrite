{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.verifyHash = void 0;\nconst abis_js_1 = require(\"../../constants/abis.js\");\nconst contracts_js_1 = require(\"../../constants/contracts.js\");\nconst contract_js_1 = require(\"../../errors/contract.js\");\nconst isBytesEqual_js_1 = require(\"../../utils/data/isBytesEqual.js\");\nconst getAction_js_1 = require(\"../../utils/getAction.js\");\nconst index_js_1 = require(\"../../utils/index.js\");\nconst call_js_1 = require(\"./call.js\");\nasync function verifyHash(client, {\n  address,\n  hash,\n  signature,\n  ...callRequest\n}) {\n  const signatureHex = (0, index_js_1.isHex)(signature) ? signature : (0, index_js_1.toHex)(signature);\n  try {\n    const {\n      data\n    } = await (0, getAction_js_1.getAction)(client, call_js_1.call, 'call')({\n      data: (0, index_js_1.encodeDeployData)({\n        abi: abis_js_1.universalSignatureValidatorAbi,\n        args: [address, hash, signatureHex],\n        bytecode: contracts_js_1.universalSignatureValidatorByteCode\n      }),\n      ...callRequest\n    });\n    return (0, isBytesEqual_js_1.isBytesEqual)(data ?? '0x0', '0x1');\n  } catch (error) {\n    if (error instanceof contract_js_1.CallExecutionError) {\n      return false;\n    }\n    throw error;\n  }\n}\nexports.verifyHash = verifyHash;","map":{"version":3,"names":["abis_js_1","require","contracts_js_1","contract_js_1","isBytesEqual_js_1","getAction_js_1","index_js_1","call_js_1","verifyHash","client","address","hash","signature","callRequest","signatureHex","isHex","toHex","data","getAction","call","encodeDeployData","abi","universalSignatureValidatorAbi","args","bytecode","universalSignatureValidatorByteCode","isBytesEqual","error","CallExecutionError","exports"],"sources":["/Users/nikhilbhatia/NIkhil/ZT-Prejects/wagmi-react-app/node_modules/@safe-global/safe-apps-sdk/node_modules/viem/actions/public/verifyHash.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { universalSignatureValidatorAbi } from '../../constants/abis.js'\nimport { universalSignatureValidatorByteCode } from '../../constants/contracts.js'\nimport { CallExecutionError } from '../../errors/contract.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport type { EncodeDeployDataErrorType } from '../../utils/abi/encodeDeployData.js'\nimport {\n  type IsBytesEqualErrorType,\n  isBytesEqual,\n} from '../../utils/data/isBytesEqual.js'\nimport type { IsHexErrorType } from '../../utils/data/isHex.js'\nimport type { ToHexErrorType } from '../../utils/encoding/toHex.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { encodeDeployData, isHex, toHex } from '../../utils/index.js'\nimport { type CallErrorType, type CallParameters, call } from './call.js'\n\nexport type VerifyHashParameters = Pick<\n  CallParameters,\n  'blockNumber' | 'blockTag'\n> & {\n  /** The address that signed the original message. */\n  address: Address\n  /** The hash to be verified. */\n  hash: Hex\n  /** The signature that was generated by signing the message with the address's private key. */\n  signature: Hex | ByteArray\n}\n\nexport type VerifyHashReturnType = boolean\n\nexport type VerifyHashErrorType =\n  | CallErrorType\n  | IsHexErrorType\n  | ToHexErrorType\n  | IsBytesEqualErrorType\n  | EncodeDeployDataErrorType\n  | ErrorType\n\n/**\n * Verifies a message hash on chain using ERC-6492.\n *\n * @param client - Client to use.\n * @param parameters - {@link VerifyHashParameters}\n * @returns Whether or not the signature is valid. {@link VerifyHashReturnType}\n */\nexport async function verifyHash<TChain extends Chain | undefined>(\n  client: Client<Transport, TChain>,\n  { address, hash, signature, ...callRequest }: VerifyHashParameters,\n): Promise<VerifyHashReturnType> {\n  const signatureHex = isHex(signature) ? signature : toHex(signature)\n\n  try {\n    const { data } = await getAction(\n      client,\n      call,\n      'call',\n    )({\n      data: encodeDeployData({\n        abi: universalSignatureValidatorAbi,\n        args: [address, hash, signatureHex],\n        bytecode: universalSignatureValidatorByteCode,\n      }),\n      ...callRequest,\n    } as unknown as CallParameters)\n\n    return isBytesEqual(data ?? '0x0', '0x1')\n  } catch (error) {\n    if (error instanceof CallExecutionError) {\n      // if the execution fails, the signature was not valid and an internal method inside of the validator reverted\n      // this can happen for many reasons, for example if signer can not be recovered from the signature\n      // or if the signature has no valid format\n      return false\n    }\n\n    throw error\n  }\n}\n"],"mappings":";;;;;;AAIA,MAAAA,SAAA,GAAAC,OAAA;AACA,MAAAC,cAAA,GAAAD,OAAA;AACA,MAAAE,aAAA,GAAAF,OAAA;AAKA,MAAAG,iBAAA,GAAAH,OAAA;AAMA,MAAAI,cAAA,GAAAJ,OAAA;AACA,MAAAK,UAAA,GAAAL,OAAA;AACA,MAAAM,SAAA,GAAAN,OAAA;AA+BO,eAAeO,UAAUA,CAC9BC,MAAiC,EACjC;EAAEC,OAAO;EAAEC,IAAI;EAAEC,SAAS;EAAE,GAAGC;AAAW,CAAwB;EAElE,MAAMC,YAAY,GAAG,IAAAR,UAAA,CAAAS,KAAK,EAACH,SAAS,CAAC,GAAGA,SAAS,GAAG,IAAAN,UAAA,CAAAU,KAAK,EAACJ,SAAS,CAAC;EAEpE,IAAI;IACF,MAAM;MAAEK;IAAI,CAAE,GAAG,MAAM,IAAAZ,cAAA,CAAAa,SAAS,EAC9BT,MAAM,EACNF,SAAA,CAAAY,IAAI,EACJ,MAAM,CACP,CAAC;MACAF,IAAI,EAAE,IAAAX,UAAA,CAAAc,gBAAgB,EAAC;QACrBC,GAAG,EAAErB,SAAA,CAAAsB,8BAA8B;QACnCC,IAAI,EAAE,CAACb,OAAO,EAAEC,IAAI,EAAEG,YAAY,CAAC;QACnCU,QAAQ,EAAEtB,cAAA,CAAAuB;OACX,CAAC;MACF,GAAGZ;KACyB,CAAC;IAE/B,OAAO,IAAAT,iBAAA,CAAAsB,YAAY,EAACT,IAAI,IAAI,KAAK,EAAE,KAAK,CAAC;GAC1C,CAAC,OAAOU,KAAK,EAAE;IACd,IAAIA,KAAK,YAAYxB,aAAA,CAAAyB,kBAAkB,EAAE;MAIvC,OAAO,KAAK;;IAGd,MAAMD,KAAK;;AAEf;AA/BAE,OAAA,CAAArB,UAAA,GAAAA,UAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}