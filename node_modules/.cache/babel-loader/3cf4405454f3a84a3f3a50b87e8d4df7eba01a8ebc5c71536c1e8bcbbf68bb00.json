{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getEnsText = void 0;\nconst abis_js_1 = require(\"../../constants/abis.js\");\nconst decodeFunctionResult_js_1 = require(\"../../utils/abi/decodeFunctionResult.js\");\nconst encodeFunctionData_js_1 = require(\"../../utils/abi/encodeFunctionData.js\");\nconst getChainContractAddress_js_1 = require(\"../../utils/chain/getChainContractAddress.js\");\nconst toHex_js_1 = require(\"../../utils/encoding/toHex.js\");\nconst errors_js_1 = require(\"../../utils/ens/errors.js\");\nconst namehash_js_1 = require(\"../../utils/ens/namehash.js\");\nconst packetToBytes_js_1 = require(\"../../utils/ens/packetToBytes.js\");\nconst getAction_js_1 = require(\"../../utils/getAction.js\");\nconst readContract_js_1 = require(\"../public/readContract.js\");\nasync function getEnsText(client, {\n  blockNumber,\n  blockTag,\n  name,\n  key,\n  universalResolverAddress: universalResolverAddress_\n}) {\n  let universalResolverAddress = universalResolverAddress_;\n  if (!universalResolverAddress) {\n    if (!client.chain) throw new Error('client chain not configured. universalResolverAddress is required.');\n    universalResolverAddress = (0, getChainContractAddress_js_1.getChainContractAddress)({\n      blockNumber,\n      chain: client.chain,\n      contract: 'ensUniversalResolver'\n    });\n  }\n  try {\n    const res = await (0, getAction_js_1.getAction)(client, readContract_js_1.readContract, 'readContract')({\n      address: universalResolverAddress,\n      abi: abis_js_1.universalResolverResolveAbi,\n      functionName: 'resolve',\n      args: [(0, toHex_js_1.toHex)((0, packetToBytes_js_1.packetToBytes)(name)), (0, encodeFunctionData_js_1.encodeFunctionData)({\n        abi: abis_js_1.textResolverAbi,\n        functionName: 'text',\n        args: [(0, namehash_js_1.namehash)(name), key]\n      })],\n      blockNumber,\n      blockTag\n    });\n    if (res[0] === '0x') return null;\n    const record = (0, decodeFunctionResult_js_1.decodeFunctionResult)({\n      abi: abis_js_1.textResolverAbi,\n      functionName: 'text',\n      data: res[0]\n    });\n    return record === '' ? null : record;\n  } catch (err) {\n    if ((0, errors_js_1.isNullUniversalResolverError)(err, 'resolve')) return null;\n    throw err;\n  }\n}\nexports.getEnsText = getEnsText;","map":{"version":3,"names":["abis_js_1","require","decodeFunctionResult_js_1","encodeFunctionData_js_1","getChainContractAddress_js_1","toHex_js_1","errors_js_1","namehash_js_1","packetToBytes_js_1","getAction_js_1","readContract_js_1","getEnsText","client","blockNumber","blockTag","name","key","universalResolverAddress","universalResolverAddress_","chain","Error","getChainContractAddress","contract","res","getAction","readContract","address","abi","universalResolverResolveAbi","functionName","args","toHex","packetToBytes","encodeFunctionData","textResolverAbi","namehash","record","decodeFunctionResult","data","err","isNullUniversalResolverError","exports"],"sources":["/Users/nikhilbhatia/NIkhil/ZT-Prejects/wagmi-react-app/node_modules/@safe-global/safe-apps-sdk/node_modules/viem/actions/ens/getEnsText.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport {\n  textResolverAbi,\n  universalResolverResolveAbi,\n} from '../../constants/abis.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Prettify } from '../../types/utils.js'\nimport {\n  type DecodeFunctionResultErrorType,\n  decodeFunctionResult,\n} from '../../utils/abi/decodeFunctionResult.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport {\n  type GetChainContractAddressErrorType,\n  getChainContractAddress,\n} from '../../utils/chain/getChainContractAddress.js'\nimport { type ToHexErrorType, toHex } from '../../utils/encoding/toHex.js'\nimport { isNullUniversalResolverError } from '../../utils/ens/errors.js'\nimport { type NamehashErrorType, namehash } from '../../utils/ens/namehash.js'\nimport {\n  type PacketToBytesErrorType,\n  packetToBytes,\n} from '../../utils/ens/packetToBytes.js'\nimport { getAction } from '../../utils/getAction.js'\nimport {\n  type ReadContractErrorType,\n  type ReadContractParameters,\n  readContract,\n} from '../public/readContract.js'\n\nexport type GetEnsTextParameters = Prettify<\n  Pick<ReadContractParameters, 'blockNumber' | 'blockTag'> & {\n    /** ENS name to get Text for. */\n    name: string\n    /** Text record to retrieve. */\n    key: string\n    /** Address of ENS Universal Resolver Contract. */\n    universalResolverAddress?: Address\n  }\n>\n\nexport type GetEnsTextReturnType = string | null\n\nexport type GetEnsTextErrorType =\n  | GetChainContractAddressErrorType\n  | ReadContractErrorType\n  | ToHexErrorType\n  | PacketToBytesErrorType\n  | EncodeFunctionDataErrorType\n  | NamehashErrorType\n  | DecodeFunctionResultErrorType\n\n/**\n * Gets a text record for specified ENS name.\n *\n * - Docs: https://viem.sh/docs/ens/actions/getEnsResolver.html\n * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens\n *\n * Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize.html) function for this.\n *\n * @param client - Client to use\n * @param parameters - {@link GetEnsTextParameters}\n * @returns Address for ENS resolver. {@link GetEnsTextReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { getEnsText, normalize } from 'viem/ens'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const twitterRecord = await getEnsText(client, {\n *   name: normalize('wevm.eth'),\n *   key: 'com.twitter',\n * })\n * // 'wagmi_sh'\n */\nexport async function getEnsText<TChain extends Chain | undefined>(\n  client: Client<Transport, TChain>,\n  {\n    blockNumber,\n    blockTag,\n    name,\n    key,\n    universalResolverAddress: universalResolverAddress_,\n  }: GetEnsTextParameters,\n): Promise<GetEnsTextReturnType> {\n  let universalResolverAddress = universalResolverAddress_\n  if (!universalResolverAddress) {\n    if (!client.chain)\n      throw new Error(\n        'client chain not configured. universalResolverAddress is required.',\n      )\n\n    universalResolverAddress = getChainContractAddress({\n      blockNumber,\n      chain: client.chain,\n      contract: 'ensUniversalResolver',\n    })\n  }\n\n  try {\n    const res = await getAction(\n      client,\n      readContract,\n      'readContract',\n    )({\n      address: universalResolverAddress,\n      abi: universalResolverResolveAbi,\n      functionName: 'resolve',\n      args: [\n        toHex(packetToBytes(name)),\n        encodeFunctionData({\n          abi: textResolverAbi,\n          functionName: 'text',\n          args: [namehash(name), key],\n        }),\n      ],\n      blockNumber,\n      blockTag,\n    })\n\n    if (res[0] === '0x') return null\n\n    const record = decodeFunctionResult({\n      abi: textResolverAbi,\n      functionName: 'text',\n      data: res[0],\n    })\n\n    return record === '' ? null : record\n  } catch (err) {\n    if (isNullUniversalResolverError(err, 'resolve')) return null\n    throw err\n  }\n}\n"],"mappings":";;;;;;AAIA,MAAAA,SAAA,GAAAC,OAAA;AAMA,MAAAC,yBAAA,GAAAD,OAAA;AAIA,MAAAE,uBAAA,GAAAF,OAAA;AAIA,MAAAG,4BAAA,GAAAH,OAAA;AAIA,MAAAI,UAAA,GAAAJ,OAAA;AACA,MAAAK,WAAA,GAAAL,OAAA;AACA,MAAAM,aAAA,GAAAN,OAAA;AACA,MAAAO,kBAAA,GAAAP,OAAA;AAIA,MAAAQ,cAAA,GAAAR,OAAA;AACA,MAAAS,iBAAA,GAAAT,OAAA;AAyDO,eAAeU,UAAUA,CAC9BC,MAAiC,EACjC;EACEC,WAAW;EACXC,QAAQ;EACRC,IAAI;EACJC,GAAG;EACHC,wBAAwB,EAAEC;AAAyB,CAC9B;EAEvB,IAAID,wBAAwB,GAAGC,yBAAyB;EACxD,IAAI,CAACD,wBAAwB,EAAE;IAC7B,IAAI,CAACL,MAAM,CAACO,KAAK,EACf,MAAM,IAAIC,KAAK,CACb,oEAAoE,CACrE;IAEHH,wBAAwB,GAAG,IAAAb,4BAAA,CAAAiB,uBAAuB,EAAC;MACjDR,WAAW;MACXM,KAAK,EAAEP,MAAM,CAACO,KAAK;MACnBG,QAAQ,EAAE;KACX,CAAC;;EAGJ,IAAI;IACF,MAAMC,GAAG,GAAG,MAAM,IAAAd,cAAA,CAAAe,SAAS,EACzBZ,MAAM,EACNF,iBAAA,CAAAe,YAAY,EACZ,cAAc,CACf,CAAC;MACAC,OAAO,EAAET,wBAAwB;MACjCU,GAAG,EAAE3B,SAAA,CAAA4B,2BAA2B;MAChCC,YAAY,EAAE,SAAS;MACvBC,IAAI,EAAE,CACJ,IAAAzB,UAAA,CAAA0B,KAAK,EAAC,IAAAvB,kBAAA,CAAAwB,aAAa,EAACjB,IAAI,CAAC,CAAC,EAC1B,IAAAZ,uBAAA,CAAA8B,kBAAkB,EAAC;QACjBN,GAAG,EAAE3B,SAAA,CAAAkC,eAAe;QACpBL,YAAY,EAAE,MAAM;QACpBC,IAAI,EAAE,CAAC,IAAAvB,aAAA,CAAA4B,QAAQ,EAACpB,IAAI,CAAC,EAAEC,GAAG;OAC3B,CAAC,CACH;MACDH,WAAW;MACXC;KACD,CAAC;IAEF,IAAIS,GAAG,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE,OAAO,IAAI;IAEhC,MAAMa,MAAM,GAAG,IAAAlC,yBAAA,CAAAmC,oBAAoB,EAAC;MAClCV,GAAG,EAAE3B,SAAA,CAAAkC,eAAe;MACpBL,YAAY,EAAE,MAAM;MACpBS,IAAI,EAAEf,GAAG,CAAC,CAAC;KACZ,CAAC;IAEF,OAAOa,MAAM,KAAK,EAAE,GAAG,IAAI,GAAGA,MAAM;GACrC,CAAC,OAAOG,GAAG,EAAE;IACZ,IAAI,IAAAjC,WAAA,CAAAkC,4BAA4B,EAACD,GAAG,EAAE,SAAS,CAAC,EAAE,OAAO,IAAI;IAC7D,MAAMA,GAAG;;AAEb;AA1DAE,OAAA,CAAA9B,UAAA,GAAAA,UAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}