{"ast":null,"code":"import { BytesSizeMismatchError } from '../errors/abi.js';\nimport { InvalidAddressError } from '../errors/address.js';\nimport { isAddress } from './address/isAddress.js';\nimport { size } from './data/size.js';\nimport { numberToHex } from './encoding/toHex.js';\nimport { bytesRegex, integerRegex } from './regex.js';\nimport { hashDomain } from './signature/hashTypedData.js';\nexport function validateTypedData(parameters) {\n  const {\n    domain,\n    message,\n    primaryType,\n    types\n  } = parameters;\n  const validateData = (struct, data) => {\n    for (const param of struct) {\n      const {\n        name,\n        type\n      } = param;\n      const value = data[name];\n      const integerMatch = type.match(integerRegex);\n      if (integerMatch && (typeof value === 'number' || typeof value === 'bigint')) {\n        const [_type, base, size_] = integerMatch;\n        // If number cannot be cast to a sized hex value, it is out of range\n        // and will throw.\n        numberToHex(value, {\n          signed: base === 'int',\n          size: parseInt(size_) / 8\n        });\n      }\n      if (type === 'address' && typeof value === 'string' && !isAddress(value)) throw new InvalidAddressError({\n        address: value\n      });\n      const bytesMatch = type.match(bytesRegex);\n      if (bytesMatch) {\n        const [_type, size_] = bytesMatch;\n        if (size_ && size(value) !== parseInt(size_)) throw new BytesSizeMismatchError({\n          expectedSize: parseInt(size_),\n          givenSize: size(value)\n        });\n      }\n      const struct = types[type];\n      if (struct) validateData(struct, value);\n    }\n  };\n  // Validate domain types.\n  if (types.EIP712Domain && domain) validateData(types.EIP712Domain, domain);\n  if (primaryType !== 'EIP712Domain') {\n    // Validate message types.\n    const type = types[primaryType];\n    validateData(type, message);\n  }\n}\nexport function getTypesForEIP712Domain({\n  domain\n}) {\n  return [typeof domain?.name === 'string' && {\n    name: 'name',\n    type: 'string'\n  }, domain?.version && {\n    name: 'version',\n    type: 'string'\n  }, typeof domain?.chainId === 'number' && {\n    name: 'chainId',\n    type: 'uint256'\n  }, domain?.verifyingContract && {\n    name: 'verifyingContract',\n    type: 'address'\n  }, domain?.salt && {\n    name: 'salt',\n    type: 'bytes32'\n  }].filter(Boolean);\n}\nexport function domainSeparator({\n  domain\n}) {\n  return hashDomain({\n    domain,\n    types: {\n      EIP712Domain: getTypesForEIP712Domain({\n        domain\n      })\n    }\n  });\n}","map":{"version":3,"names":["BytesSizeMismatchError","InvalidAddressError","isAddress","size","numberToHex","bytesRegex","integerRegex","hashDomain","validateTypedData","parameters","domain","message","primaryType","types","validateData","struct","data","param","name","type","value","integerMatch","match","_type","base","size_","signed","parseInt","address","bytesMatch","expectedSize","givenSize","EIP712Domain","getTypesForEIP712Domain","version","chainId","verifyingContract","salt","filter","Boolean","domainSeparator"],"sources":["/Users/nikhilbhatia/NIkhil/ZT-Prejects/wagmi-react-app/node_modules/viem/utils/typedData.ts"],"sourcesContent":["import type { TypedData, TypedDataDomain, TypedDataParameter } from 'abitype'\n\nimport { BytesSizeMismatchError } from '../errors/abi.js'\nimport { InvalidAddressError } from '../errors/address.js'\nimport type { Hex } from '../types/misc.js'\nimport type { TypedDataDefinition } from '../types/typedData.js'\n\nimport type { ErrorType } from '../errors/utils.js'\nimport { type IsAddressErrorType, isAddress } from './address/isAddress.js'\nimport { type SizeErrorType, size } from './data/size.js'\nimport { type NumberToHexErrorType, numberToHex } from './encoding/toHex.js'\nimport { bytesRegex, integerRegex } from './regex.js'\nimport {\n  type HashDomainErrorType,\n  hashDomain,\n} from './signature/hashTypedData.js'\n\nexport type ValidateTypedDataErrorType =\n  | HashDomainErrorType\n  | IsAddressErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function validateTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(parameters: TypedDataDefinition<typedData, primaryType>) {\n  const { domain, message, primaryType, types } =\n    parameters as unknown as TypedDataDefinition\n\n  const validateData = (\n    struct: readonly TypedDataParameter[],\n    data: Record<string, unknown>,\n  ) => {\n    for (const param of struct) {\n      const { name, type } = param\n      const value = data[name]\n\n      const integerMatch = type.match(integerRegex)\n      if (\n        integerMatch &&\n        (typeof value === 'number' || typeof value === 'bigint')\n      ) {\n        const [_type, base, size_] = integerMatch\n        // If number cannot be cast to a sized hex value, it is out of range\n        // and will throw.\n        numberToHex(value, {\n          signed: base === 'int',\n          size: parseInt(size_) / 8,\n        })\n      }\n\n      if (type === 'address' && typeof value === 'string' && !isAddress(value))\n        throw new InvalidAddressError({ address: value })\n\n      const bytesMatch = type.match(bytesRegex)\n      if (bytesMatch) {\n        const [_type, size_] = bytesMatch\n        if (size_ && size(value as Hex) !== parseInt(size_))\n          throw new BytesSizeMismatchError({\n            expectedSize: parseInt(size_),\n            givenSize: size(value as Hex),\n          })\n      }\n\n      const struct = types[type]\n      if (struct) validateData(struct, value as Record<string, unknown>)\n    }\n  }\n\n  // Validate domain types.\n  if (types.EIP712Domain && domain) validateData(types.EIP712Domain, domain)\n\n  if (primaryType !== 'EIP712Domain') {\n    // Validate message types.\n    const type = types[primaryType]\n    validateData(type, message)\n  }\n}\n\nexport type GetTypesForEIP712DomainErrorType = ErrorType\n\nexport function getTypesForEIP712Domain({\n  domain,\n}: { domain?: TypedDataDomain | undefined }): TypedDataParameter[] {\n  return [\n    typeof domain?.name === 'string' && { name: 'name', type: 'string' },\n    domain?.version && { name: 'version', type: 'string' },\n    typeof domain?.chainId === 'number' && {\n      name: 'chainId',\n      type: 'uint256',\n    },\n    domain?.verifyingContract && {\n      name: 'verifyingContract',\n      type: 'address',\n    },\n    domain?.salt && { name: 'salt', type: 'bytes32' },\n  ].filter(Boolean) as TypedDataParameter[]\n}\n\nexport type DomainSeparatorErrorType =\n  | GetTypesForEIP712DomainErrorType\n  | HashDomainErrorType\n  | ErrorType\n\nexport function domainSeparator({ domain }: { domain: TypedDataDomain }): Hex {\n  return hashDomain({\n    domain,\n    types: {\n      EIP712Domain: getTypesForEIP712Domain({ domain }),\n    },\n  })\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}