{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.stringToBytes = exports.numberToBytes = exports.hexToBytes = exports.boolToBytes = exports.toBytes = void 0;\nconst base_js_1 = require(\"../../errors/base.js\");\nconst isHex_js_1 = require(\"../data/isHex.js\");\nconst pad_js_1 = require(\"../data/pad.js\");\nconst fromHex_js_1 = require(\"./fromHex.js\");\nconst toHex_js_1 = require(\"./toHex.js\");\nconst encoder = new TextEncoder();\nfunction toBytes(value, opts = {}) {\n  if (typeof value === 'number' || typeof value === 'bigint') return numberToBytes(value, opts);\n  if (typeof value === 'boolean') return boolToBytes(value, opts);\n  if ((0, isHex_js_1.isHex)(value)) return hexToBytes(value, opts);\n  return stringToBytes(value, opts);\n}\nexports.toBytes = toBytes;\nfunction boolToBytes(value, opts = {}) {\n  const bytes = new Uint8Array(1);\n  bytes[0] = Number(value);\n  if (typeof opts.size === 'number') {\n    (0, fromHex_js_1.assertSize)(bytes, {\n      size: opts.size\n    });\n    return (0, pad_js_1.pad)(bytes, {\n      size: opts.size\n    });\n  }\n  return bytes;\n}\nexports.boolToBytes = boolToBytes;\nconst charCodeMap = {\n  zero: 48,\n  nine: 57,\n  A: 65,\n  F: 70,\n  a: 97,\n  f: 102\n};\nfunction charCodeToBase16(char) {\n  if (char >= charCodeMap.zero && char <= charCodeMap.nine) return char - charCodeMap.zero;\n  if (char >= charCodeMap.A && char <= charCodeMap.F) return char - (charCodeMap.A - 10);\n  if (char >= charCodeMap.a && char <= charCodeMap.f) return char - (charCodeMap.a - 10);\n  return undefined;\n}\nfunction hexToBytes(hex_, opts = {}) {\n  let hex = hex_;\n  if (opts.size) {\n    (0, fromHex_js_1.assertSize)(hex, {\n      size: opts.size\n    });\n    hex = (0, pad_js_1.pad)(hex, {\n      dir: 'right',\n      size: opts.size\n    });\n  }\n  let hexString = hex.slice(2);\n  if (hexString.length % 2) hexString = `0${hexString}`;\n  const length = hexString.length / 2;\n  const bytes = new Uint8Array(length);\n  for (let index = 0, j = 0; index < length; index++) {\n    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));\n    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));\n    if (nibbleLeft === undefined || nibbleRight === undefined) {\n      throw new base_js_1.BaseError(`Invalid byte sequence (\"${hexString[j - 2]}${hexString[j - 1]}\" in \"${hexString}\").`);\n    }\n    bytes[index] = nibbleLeft * 16 + nibbleRight;\n  }\n  return bytes;\n}\nexports.hexToBytes = hexToBytes;\nfunction numberToBytes(value, opts) {\n  const hex = (0, toHex_js_1.numberToHex)(value, opts);\n  return hexToBytes(hex);\n}\nexports.numberToBytes = numberToBytes;\nfunction stringToBytes(value, opts = {}) {\n  const bytes = encoder.encode(value);\n  if (typeof opts.size === 'number') {\n    (0, fromHex_js_1.assertSize)(bytes, {\n      size: opts.size\n    });\n    return (0, pad_js_1.pad)(bytes, {\n      dir: 'right',\n      size: opts.size\n    });\n  }\n  return bytes;\n}\nexports.stringToBytes = stringToBytes;","map":{"version":3,"names":["base_js_1","require","isHex_js_1","pad_js_1","fromHex_js_1","toHex_js_1","encoder","TextEncoder","toBytes","value","opts","numberToBytes","boolToBytes","isHex","hexToBytes","stringToBytes","exports","bytes","Uint8Array","Number","size","assertSize","pad","charCodeMap","zero","nine","A","F","a","f","charCodeToBase16","char","undefined","hex_","hex","dir","hexString","slice","length","index","j","nibbleLeft","charCodeAt","nibbleRight","BaseError","numberToHex","encode"],"sources":["/Users/nikhilbhatia/NIkhil/ZT-Prejects/wagmi-react-app/node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/encoding/toBytes.ts"],"sourcesContent":["import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type PadErrorType, pad } from '../data/pad.js'\n\nimport { type AssertSizeErrorType, assertSize } from './fromHex.js'\nimport {\n  type NumberToHexErrorType,\n  type NumberToHexOpts,\n  numberToHex,\n} from './toHex.js'\n\nconst encoder = /*#__PURE__*/ new TextEncoder()\n\nexport type ToBytesParameters = {\n  /** Size of the output bytes. */\n  size?: number\n}\n\nexport type ToBytesErrorType =\n  | NumberToBytesErrorType\n  | BoolToBytesErrorType\n  | HexToBytesErrorType\n  | StringToBytesErrorType\n  | IsHexErrorType\n  | ErrorType\n\n/**\n * Encodes a UTF-8 string, hex value, bigint, number or boolean to a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes.html\n * - Example: https://viem.sh/docs/utilities/toBytes.html#usage\n *\n * @param value Value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes('Hello world')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { toBytes } from 'viem'\n * const data = toBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function toBytes(\n  value: string | bigint | number | boolean | Hex,\n  opts: ToBytesParameters = {},\n): ByteArray {\n  if (typeof value === 'number' || typeof value === 'bigint')\n    return numberToBytes(value, opts)\n  if (typeof value === 'boolean') return boolToBytes(value, opts)\n  if (isHex(value)) return hexToBytes(value, opts)\n  return stringToBytes(value, opts)\n}\n\nexport type BoolToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number\n}\n\nexport type BoolToBytesErrorType =\n  | AssertSizeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a boolean into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes.html#booltobytes\n *\n * @param value Boolean value to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true)\n * // Uint8Array([1])\n *\n * @example\n * import { boolToBytes } from 'viem'\n * const data = boolToBytes(true, { size: 32 })\n * // Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n */\nexport function boolToBytes(value: boolean, opts: BoolToBytesOpts = {}) {\n  const bytes = new Uint8Array(1)\n  bytes[0] = Number(value)\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, { size: opts.size })\n    return pad(bytes, { size: opts.size })\n  }\n  return bytes\n}\n\n// We use very optimized technique to convert hex string to byte array\nconst charCodeMap = {\n  zero: 48,\n  nine: 57,\n  A: 65,\n  F: 70,\n  a: 97,\n  f: 102,\n} as const\n\nfunction charCodeToBase16(char: number) {\n  if (char >= charCodeMap.zero && char <= charCodeMap.nine)\n    return char - charCodeMap.zero\n  if (char >= charCodeMap.A && char <= charCodeMap.F)\n    return char - (charCodeMap.A - 10)\n  if (char >= charCodeMap.a && char <= charCodeMap.f)\n    return char - (charCodeMap.a - 10)\n  return undefined\n}\n\nexport type HexToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number\n}\n\nexport type HexToBytesErrorType = AssertSizeErrorType | PadErrorType | ErrorType\n\n/**\n * Encodes a hex string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes.html#hextobytes\n *\n * @param hex Hex string to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n *\n * @example\n * import { hexToBytes } from 'viem'\n * const data = hexToBytes('0x48656c6c6f20776f726c6421', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function hexToBytes(hex_: Hex, opts: HexToBytesOpts = {}): ByteArray {\n  let hex = hex_\n  if (opts.size) {\n    assertSize(hex, { size: opts.size })\n    hex = pad(hex, { dir: 'right', size: opts.size })\n  }\n\n  let hexString = hex.slice(2) as string\n  if (hexString.length % 2) hexString = `0${hexString}`\n\n  const length = hexString.length / 2\n  const bytes = new Uint8Array(length)\n  for (let index = 0, j = 0; index < length; index++) {\n    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++))\n    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++))\n    if (nibbleLeft === undefined || nibbleRight === undefined) {\n      throw new BaseError(\n        `Invalid byte sequence (\"${hexString[j - 2]}${\n          hexString[j - 1]\n        }\" in \"${hexString}\").`,\n      )\n    }\n    bytes[index] = nibbleLeft * 16 + nibbleRight\n  }\n  return bytes\n}\n\nexport type NumberToBytesErrorType =\n  | NumberToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\n/**\n * Encodes a number into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes.html#numbertobytes\n *\n * @param value Number to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420)\n * // Uint8Array([1, 164])\n *\n * @example\n * import { numberToBytes } from 'viem'\n * const data = numberToBytes(420, { size: 4 })\n * // Uint8Array([0, 0, 1, 164])\n */\nexport function numberToBytes(value: bigint | number, opts?: NumberToHexOpts) {\n  const hex = numberToHex(value, opts)\n  return hexToBytes(hex)\n}\n\nexport type StringToBytesOpts = {\n  /** Size of the output bytes. */\n  size?: number\n}\n\nexport type StringToBytesErrorType =\n  | AssertSizeErrorType\n  | PadErrorType\n  | ErrorType\n\n/**\n * Encodes a UTF-8 string into a byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/toBytes.html#stringtobytes\n *\n * @param value String to encode.\n * @param opts Options.\n * @returns Byte array value.\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!')\n * // Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n *\n * @example\n * import { stringToBytes } from 'viem'\n * const data = stringToBytes('Hello world!', { size: 32 })\n * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n */\nexport function stringToBytes(\n  value: string,\n  opts: StringToBytesOpts = {},\n): ByteArray {\n  const bytes = encoder.encode(value)\n  if (typeof opts.size === 'number') {\n    assertSize(bytes, { size: opts.size })\n    return pad(bytes, { dir: 'right', size: opts.size })\n  }\n  return bytes\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}