{"ast":null,"code":"import { RpcRequestError, SwitchChainError, UserRejectedRequestError, custom, fromHex, getAddress, numberToHex } from 'viem';\nimport { rpc } from 'viem/utils';\nimport { ChainNotConfiguredError, ConnectorNotConnectedError } from '../errors/config.js';\nimport { createConnector } from './createConnector.js';\nmock.type = 'mock';\nexport function mock(parameters) {\n  const features = parameters.features ?? {};\n  let connected = false;\n  let connectedChainId;\n  return createConnector(config => ({\n    id: 'mock',\n    name: 'Mock Connector',\n    type: mock.type,\n    async setup() {\n      connectedChainId = config.chains[0].id;\n    },\n    async connect({\n      chainId\n    } = {}) {\n      if (features.connectError) {\n        if (typeof features.connectError === 'boolean') throw new UserRejectedRequestError(new Error('Failed to connect.'));\n        throw features.connectError;\n      }\n      const provider = await this.getProvider();\n      const accounts = await provider.request({\n        method: 'eth_requestAccounts'\n      });\n      let currentChainId = await this.getChainId();\n      if (chainId && currentChainId !== chainId) {\n        const chain = await this.switchChain({\n          chainId\n        });\n        currentChainId = chain.id;\n      }\n      connected = true;\n      return {\n        accounts,\n        chainId: currentChainId\n      };\n    },\n    async disconnect() {\n      connected = false;\n    },\n    async getAccounts() {\n      if (!connected) throw new ConnectorNotConnectedError();\n      const provider = await this.getProvider();\n      const accounts = await provider.request({\n        method: 'eth_accounts'\n      });\n      return accounts.map(x => getAddress(x));\n    },\n    async getChainId() {\n      const provider = await this.getProvider();\n      const hexChainId = await provider.request({\n        method: 'eth_chainId'\n      });\n      return fromHex(hexChainId, 'number');\n    },\n    async isAuthorized() {\n      if (!features.reconnect) return false;\n      if (!connected) return false;\n      const accounts = await this.getAccounts();\n      return !!accounts.length;\n    },\n    async switchChain({\n      chainId\n    }) {\n      const provider = await this.getProvider();\n      const chain = config.chains.find(x => x.id === chainId);\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError());\n      await provider.request({\n        method: 'wallet_switchEthereumChain',\n        params: [{\n          chainId: numberToHex(chainId)\n        }]\n      });\n      return chain;\n    },\n    onAccountsChanged(accounts) {\n      if (accounts.length === 0) this.onDisconnect();else config.emitter.emit('change', {\n        accounts: accounts.map(x => getAddress(x))\n      });\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain);\n      config.emitter.emit('change', {\n        chainId\n      });\n    },\n    async onDisconnect(_error) {\n      config.emitter.emit('disconnect');\n      connected = false;\n    },\n    async getProvider({\n      chainId\n    } = {}) {\n      const chain = config.chains.find(x => x.id === chainId) ?? config.chains[0];\n      const url = chain.rpcUrls.default.http[0];\n      const request = async ({\n        method,\n        params\n      }) => {\n        // eth methods\n        if (method === 'eth_chainId') return numberToHex(connectedChainId);\n        if (method === 'eth_requestAccounts') return parameters.accounts;\n        if (method === 'eth_signTypedData_v4') if (features.signTypedDataError) {\n          if (typeof features.signTypedDataError === 'boolean') throw new UserRejectedRequestError(new Error('Failed to sign typed data.'));\n          throw features.signTypedDataError;\n        }\n        // wallet methods\n        if (method === 'wallet_switchEthereumChain') {\n          if (features.switchChainError) {\n            if (typeof features.switchChainError === 'boolean') throw new UserRejectedRequestError(new Error('Failed to switch chain.'));\n            throw features.switchChainError;\n          }\n          connectedChainId = fromHex(params[0].chainId, 'number');\n          this.onChainChanged(connectedChainId.toString());\n          return;\n        }\n        // other methods\n        if (method === 'personal_sign') {\n          if (features.signMessageError) {\n            if (typeof features.signMessageError === 'boolean') throw new UserRejectedRequestError(new Error('Failed to sign message.'));\n            throw features.signMessageError;\n          }\n          // Change `personal_sign` to `eth_sign` and swap params\n          method = 'eth_sign';\n          params = [params[1], params[0]];\n        }\n        const body = {\n          method,\n          params\n        };\n        const {\n          error,\n          result\n        } = await rpc.http(url, {\n          body\n        });\n        if (error) throw new RpcRequestError({\n          body,\n          error,\n          url\n        });\n        return result;\n      };\n      return custom({\n        request\n      })({\n        retryCount: 0\n      });\n    }\n  }));\n}","map":{"version":3,"names":["RpcRequestError","SwitchChainError","UserRejectedRequestError","custom","fromHex","getAddress","numberToHex","rpc","ChainNotConfiguredError","ConnectorNotConnectedError","createConnector","mock","type","parameters","features","connected","connectedChainId","config","id","name","setup","chains","connect","chainId","connectError","Error","provider","getProvider","accounts","request","method","currentChainId","getChainId","chain","switchChain","disconnect","getAccounts","map","x","hexChainId","isAuthorized","reconnect","length","find","params","onAccountsChanged","onDisconnect","emitter","emit","onChainChanged","Number","_error","url","rpcUrls","default","http","signTypedDataError","switchChainError","toString","signMessageError","body","error","result","retryCount"],"sources":["/Users/nikhilbhatia/NIkhil/ZT-Prejects/wagmi-react-app/node_modules/wagmi/node_modules/@wagmi/core/src/connectors/mock.ts"],"sourcesContent":["import {\n  type Address,\n  type EIP1193RequestFn,\n  type Hex,\n  RpcRequestError,\n  SwitchChainError,\n  type Transport,\n  UserRejectedRequestError,\n  type WalletRpcSchema,\n  custom,\n  fromHex,\n  getAddress,\n  numberToHex,\n} from 'viem'\nimport { rpc } from 'viem/utils'\n\nimport {\n  ChainNotConfiguredError,\n  ConnectorNotConnectedError,\n} from '../errors/config.js'\nimport { createConnector } from './createConnector.js'\n\nexport type MockParameters = {\n  accounts: readonly [Address, ...Address[]]\n  features?:\n    | {\n        connectError?: boolean | Error | undefined\n        switchChainError?: boolean | Error | undefined\n        signMessageError?: boolean | Error | undefined\n        signTypedDataError?: boolean | Error | undefined\n        reconnect?: boolean | undefined\n      }\n    | undefined\n}\n\nmock.type = 'mock' as const\nexport function mock(parameters: MockParameters) {\n  const features = parameters.features ?? {}\n\n  type Provider = ReturnType<\n    Transport<'custom', {}, EIP1193RequestFn<WalletRpcSchema>>\n  >\n  let connected = false\n  let connectedChainId: number\n\n  return createConnector<Provider>((config) => ({\n    id: 'mock',\n    name: 'Mock Connector',\n    type: mock.type,\n    async setup() {\n      connectedChainId = config.chains[0].id\n    },\n    async connect({ chainId } = {}) {\n      if (features.connectError) {\n        if (typeof features.connectError === 'boolean')\n          throw new UserRejectedRequestError(new Error('Failed to connect.'))\n        throw features.connectError\n      }\n\n      const provider = await this.getProvider()\n      const accounts = await provider.request({\n        method: 'eth_requestAccounts',\n      })\n\n      let currentChainId = await this.getChainId()\n      if (chainId && currentChainId !== chainId) {\n        const chain = await this.switchChain!({ chainId })\n        currentChainId = chain.id\n      }\n\n      connected = true\n\n      return { accounts, chainId: currentChainId }\n    },\n    async disconnect() {\n      connected = false\n    },\n    async getAccounts() {\n      if (!connected) throw new ConnectorNotConnectedError()\n      const provider = await this.getProvider()\n      const accounts = await provider.request({ method: 'eth_accounts' })\n      return accounts.map((x) => getAddress(x))\n    },\n    async getChainId() {\n      const provider = await this.getProvider()\n      const hexChainId = await provider.request({ method: 'eth_chainId' })\n      return fromHex(hexChainId, 'number')\n    },\n    async isAuthorized() {\n      if (!features.reconnect) return false\n      if (!connected) return false\n      const accounts = await this.getAccounts()\n      return !!accounts.length\n    },\n    async switchChain({ chainId }) {\n      const provider = await this.getProvider()\n      const chain = config.chains.find((x) => x.id === chainId)\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())\n\n      await provider.request({\n        method: 'wallet_switchEthereumChain',\n        params: [{ chainId: numberToHex(chainId) }],\n      })\n      return chain\n    },\n    onAccountsChanged(accounts) {\n      if (accounts.length === 0) this.onDisconnect()\n      else\n        config.emitter.emit('change', {\n          accounts: accounts.map((x) => getAddress(x)),\n        })\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain)\n      config.emitter.emit('change', { chainId })\n    },\n    async onDisconnect(_error) {\n      config.emitter.emit('disconnect')\n      connected = false\n    },\n    async getProvider({ chainId } = {}) {\n      const chain =\n        config.chains.find((x) => x.id === chainId) ?? config.chains[0]\n      const url = chain.rpcUrls.default.http[0]!\n\n      const request: EIP1193RequestFn = async ({ method, params }) => {\n        // eth methods\n        if (method === 'eth_chainId') return numberToHex(connectedChainId)\n        if (method === 'eth_requestAccounts') return parameters.accounts\n        if (method === 'eth_signTypedData_v4')\n          if (features.signTypedDataError) {\n            if (typeof features.signTypedDataError === 'boolean')\n              throw new UserRejectedRequestError(\n                new Error('Failed to sign typed data.'),\n              )\n            throw features.signTypedDataError\n          }\n\n        // wallet methods\n        if (method === 'wallet_switchEthereumChain') {\n          if (features.switchChainError) {\n            if (typeof features.switchChainError === 'boolean')\n              throw new UserRejectedRequestError(\n                new Error('Failed to switch chain.'),\n              )\n            throw features.switchChainError\n          }\n          type Params = [{ chainId: Hex }]\n          connectedChainId = fromHex((params as Params)[0].chainId, 'number')\n          this.onChainChanged(connectedChainId.toString())\n          return\n        }\n\n        // other methods\n        if (method === 'personal_sign') {\n          if (features.signMessageError) {\n            if (typeof features.signMessageError === 'boolean')\n              throw new UserRejectedRequestError(\n                new Error('Failed to sign message.'),\n              )\n            throw features.signMessageError\n          }\n          // Change `personal_sign` to `eth_sign` and swap params\n          method = 'eth_sign'\n          type Params = [data: Hex, address: Address]\n          params = [(params as Params)[1], (params as Params)[0]]\n        }\n\n        const body = { method, params }\n        const { error, result } = await rpc.http(url, { body })\n        if (error) throw new RpcRequestError({ body, error, url })\n\n        return result\n      }\n      return custom({ request })({ retryCount: 0 })\n    },\n  }))\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}