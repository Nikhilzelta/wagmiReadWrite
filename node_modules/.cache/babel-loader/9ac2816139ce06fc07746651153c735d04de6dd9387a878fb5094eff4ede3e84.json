{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.domainSeparator = exports.getTypesForEIP712Domain = exports.validateTypedData = void 0;\nconst abi_js_1 = require(\"../errors/abi.js\");\nconst address_js_1 = require(\"../errors/address.js\");\nconst isAddress_js_1 = require(\"./address/isAddress.js\");\nconst size_js_1 = require(\"./data/size.js\");\nconst toHex_js_1 = require(\"./encoding/toHex.js\");\nconst regex_js_1 = require(\"./regex.js\");\nconst hashTypedData_js_1 = require(\"./signature/hashTypedData.js\");\nfunction validateTypedData({\n  domain,\n  message,\n  primaryType,\n  types: types_\n}) {\n  const types = types_;\n  const validateData = (struct, value_) => {\n    for (const param of struct) {\n      const {\n        name,\n        type: type_\n      } = param;\n      const type = type_;\n      const value = value_[name];\n      const integerMatch = type.match(regex_js_1.integerRegex);\n      if (integerMatch && (typeof value === 'number' || typeof value === 'bigint')) {\n        const [_type, base, size_] = integerMatch;\n        (0, toHex_js_1.numberToHex)(value, {\n          signed: base === 'int',\n          size: parseInt(size_) / 8\n        });\n      }\n      if (type === 'address' && typeof value === 'string' && !(0, isAddress_js_1.isAddress)(value)) throw new address_js_1.InvalidAddressError({\n        address: value\n      });\n      const bytesMatch = type.match(regex_js_1.bytesRegex);\n      if (bytesMatch) {\n        const [_type, size_] = bytesMatch;\n        if (size_ && (0, size_js_1.size)(value) !== parseInt(size_)) throw new abi_js_1.BytesSizeMismatchError({\n          expectedSize: parseInt(size_),\n          givenSize: (0, size_js_1.size)(value)\n        });\n      }\n      const struct = types[type];\n      if (struct) validateData(struct, value);\n    }\n  };\n  if (types.EIP712Domain && domain) validateData(types.EIP712Domain, domain);\n  if (primaryType !== 'EIP712Domain') {\n    const type = types[primaryType];\n    validateData(type, message);\n  }\n}\nexports.validateTypedData = validateTypedData;\nfunction getTypesForEIP712Domain({\n  domain\n}) {\n  return [typeof domain?.name === 'string' && {\n    name: 'name',\n    type: 'string'\n  }, domain?.version && {\n    name: 'version',\n    type: 'string'\n  }, typeof domain?.chainId === 'number' && {\n    name: 'chainId',\n    type: 'uint256'\n  }, domain?.verifyingContract && {\n    name: 'verifyingContract',\n    type: 'address'\n  }, domain?.salt && {\n    name: 'salt',\n    type: 'bytes32'\n  }].filter(Boolean);\n}\nexports.getTypesForEIP712Domain = getTypesForEIP712Domain;\nfunction domainSeparator({\n  domain\n}) {\n  return (0, hashTypedData_js_1.hashDomain)({\n    domain,\n    types: {\n      EIP712Domain: getTypesForEIP712Domain({\n        domain\n      })\n    }\n  });\n}\nexports.domainSeparator = domainSeparator;","map":{"version":3,"names":["abi_js_1","require","address_js_1","isAddress_js_1","size_js_1","toHex_js_1","regex_js_1","hashTypedData_js_1","validateTypedData","domain","message","primaryType","types","types_","validateData","struct","value_","param","name","type","type_","value","integerMatch","match","integerRegex","_type","base","size_","numberToHex","signed","size","parseInt","isAddress","InvalidAddressError","address","bytesMatch","bytesRegex","BytesSizeMismatchError","expectedSize","givenSize","EIP712Domain","exports","getTypesForEIP712Domain","version","chainId","verifyingContract","salt","filter","Boolean","domainSeparator","hashDomain"],"sources":["/Users/nikhilbhatia/NIkhil/ZT-Prejects/wagmi-react-app/node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/typedData.ts"],"sourcesContent":["import type {\n  TypedData,\n  TypedDataDomain,\n  TypedDataParameter,\n  TypedDataType,\n} from 'abitype'\n\nimport { BytesSizeMismatchError } from '../errors/abi.js'\nimport { InvalidAddressError } from '../errors/address.js'\nimport type { Hex } from '../types/misc.js'\nimport type { TypedDataDefinition } from '../types/typedData.js'\n\nimport type { ErrorType } from '../errors/utils.js'\nimport { type IsAddressErrorType, isAddress } from './address/isAddress.js'\nimport { type SizeErrorType, size } from './data/size.js'\nimport { type NumberToHexErrorType, numberToHex } from './encoding/toHex.js'\nimport { bytesRegex, integerRegex } from './regex.js'\nimport {\n  type HashDomainErrorType,\n  hashDomain,\n} from './signature/hashTypedData.js'\n\nexport type ValidateTypedDataErrorType =\n  | HashDomainErrorType\n  | IsAddressErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function validateTypedData<\n  const TTypedData extends TypedData | { [key: string]: unknown },\n  TPrimaryType extends string = string,\n>({\n  domain,\n  message,\n  primaryType,\n  types: types_,\n}: TypedDataDefinition<TTypedData, TPrimaryType>) {\n  const types = types_ as TypedData\n\n  const validateData = (\n    struct: readonly TypedDataParameter[],\n    value_: Record<string, unknown>,\n  ) => {\n    for (const param of struct) {\n      const { name, type: type_ } = param\n      const type = type_ as TypedDataType\n      const value = value_[name]\n\n      const integerMatch = type.match(integerRegex)\n      if (\n        integerMatch &&\n        (typeof value === 'number' || typeof value === 'bigint')\n      ) {\n        const [_type, base, size_] = integerMatch\n        // If number cannot be cast to a sized hex value, it is out of range\n        // and will throw.\n        numberToHex(value, {\n          signed: base === 'int',\n          size: parseInt(size_) / 8,\n        })\n      }\n\n      if (type === 'address' && typeof value === 'string' && !isAddress(value))\n        throw new InvalidAddressError({ address: value })\n\n      const bytesMatch = type.match(bytesRegex)\n      if (bytesMatch) {\n        const [_type, size_] = bytesMatch\n        if (size_ && size(value as Hex) !== parseInt(size_))\n          throw new BytesSizeMismatchError({\n            expectedSize: parseInt(size_),\n            givenSize: size(value as Hex),\n          })\n      }\n\n      const struct = types[type]\n      if (struct) validateData(struct, value as Record<string, unknown>)\n    }\n  }\n\n  // Validate domain types.\n  if (types.EIP712Domain && domain) validateData(types.EIP712Domain, domain)\n\n  if (primaryType !== 'EIP712Domain') {\n    // Validate message types.\n    const type = types[primaryType]\n    validateData(type, message as Record<string, unknown>)\n  }\n}\n\nexport type GetTypesForEIP712DomainErrorType = ErrorType\n\nexport function getTypesForEIP712Domain({\n  domain,\n}: { domain?: TypedDataDomain }): TypedDataParameter[] {\n  return [\n    typeof domain?.name === 'string' && { name: 'name', type: 'string' },\n    domain?.version && { name: 'version', type: 'string' },\n    typeof domain?.chainId === 'number' && {\n      name: 'chainId',\n      type: 'uint256',\n    },\n    domain?.verifyingContract && {\n      name: 'verifyingContract',\n      type: 'address',\n    },\n    domain?.salt && { name: 'salt', type: 'bytes32' },\n  ].filter(Boolean) as TypedDataParameter[]\n}\n\nexport type DomainSeparatorErrorType =\n  | GetTypesForEIP712DomainErrorType\n  | HashDomainErrorType\n  | ErrorType\n\nexport function domainSeparator({ domain }: { domain: TypedDataDomain }): Hex {\n  return hashDomain({\n    domain,\n    types: {\n      EIP712Domain: getTypesForEIP712Domain({ domain }),\n    },\n  })\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}