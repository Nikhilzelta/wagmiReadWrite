{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeErrorResult = void 0;\nconst solidity_js_1 = require(\"../../constants/solidity.js\");\nconst abi_js_1 = require(\"../../errors/abi.js\");\nconst slice_js_1 = require(\"../data/slice.js\");\nconst getFunctionSelector_js_1 = require(\"../hash/getFunctionSelector.js\");\nconst decodeAbiParameters_js_1 = require(\"./decodeAbiParameters.js\");\nconst formatAbiItem_js_1 = require(\"./formatAbiItem.js\");\nfunction decodeErrorResult({\n  abi,\n  data\n}) {\n  const signature = (0, slice_js_1.slice)(data, 0, 4);\n  if (signature === '0x') throw new abi_js_1.AbiDecodingZeroDataError();\n  const abi_ = [...(abi || []), solidity_js_1.solidityError, solidity_js_1.solidityPanic];\n  const abiItem = abi_.find(x => x.type === 'error' && signature === (0, getFunctionSelector_js_1.getFunctionSelector)((0, formatAbiItem_js_1.formatAbiItem)(x)));\n  if (!abiItem) throw new abi_js_1.AbiErrorSignatureNotFoundError(signature, {\n    docsPath: '/docs/contract/decodeErrorResult'\n  });\n  return {\n    abiItem,\n    args: 'inputs' in abiItem && abiItem.inputs && abiItem.inputs.length > 0 ? (0, decodeAbiParameters_js_1.decodeAbiParameters)(abiItem.inputs, (0, slice_js_1.slice)(data, 4)) : undefined,\n    errorName: abiItem.name\n  };\n}\nexports.decodeErrorResult = decodeErrorResult;","map":{"version":3,"names":["solidity_js_1","require","abi_js_1","slice_js_1","getFunctionSelector_js_1","decodeAbiParameters_js_1","formatAbiItem_js_1","decodeErrorResult","abi","data","signature","slice","AbiDecodingZeroDataError","abi_","solidityError","solidityPanic","abiItem","find","x","type","getFunctionSelector","formatAbiItem","AbiErrorSignatureNotFoundError","docsPath","args","inputs","length","decodeAbiParameters","undefined","errorName","name","exports"],"sources":["/Users/nikhilbhatia/NIkhil/ZT-Prejects/wagmi-react-app/node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/abi/decodeErrorResult.ts"],"sourcesContent":["import type { Abi, ExtractAbiError, ExtractAbiErrorNames } from 'abitype'\n\nimport { solidityError, solidityPanic } from '../../constants/solidity.js'\nimport {\n  AbiDecodingZeroDataError,\n  type AbiDecodingZeroDataErrorType,\n  AbiErrorSignatureNotFoundError,\n  type AbiErrorSignatureNotFoundErrorType,\n} from '../../errors/abi.js'\nimport type { AbiItem, GetErrorArgs } from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport { slice } from '../data/slice.js'\nimport {\n  type GetFunctionSelectorErrorType,\n  getFunctionSelector,\n} from '../hash/getFunctionSelector.js'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport {\n  type DecodeAbiParametersErrorType,\n  decodeAbiParameters,\n} from './decodeAbiParameters.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\n\nexport type DecodeErrorResultParameters<\n  TAbi extends Abi | readonly unknown[] = Abi,\n> = { abi?: TAbi; data: Hex }\n\nexport type DecodeErrorResultReturnType<\n  TAbi extends Abi | readonly unknown[] = Abi,\n  _ErrorNames extends string = TAbi extends Abi\n    ? Abi extends TAbi\n      ? string\n      : ExtractAbiErrorNames<TAbi>\n    : string,\n> = {\n  [TName in _ErrorNames]: {\n    abiItem: TAbi extends Abi ? ExtractAbiError<TAbi, TName> : AbiItem\n    args: GetErrorArgs<TAbi, TName>['args']\n    errorName: TName\n  }\n}[_ErrorNames]\n\nexport type DecodeErrorResultErrorType =\n  | AbiDecodingZeroDataErrorType\n  | AbiErrorSignatureNotFoundErrorType\n  | DecodeAbiParametersErrorType\n  | FormatAbiItemErrorType\n  | GetFunctionSelectorErrorType\n  | ErrorType\n\nexport function decodeErrorResult<const TAbi extends Abi | readonly unknown[]>({\n  abi,\n  data,\n}: DecodeErrorResultParameters<TAbi>): DecodeErrorResultReturnType<TAbi> {\n  const signature = slice(data, 0, 4)\n  if (signature === '0x') throw new AbiDecodingZeroDataError()\n\n  const abi_ = [...((abi as Abi) || []), solidityError, solidityPanic]\n  const abiItem = abi_.find(\n    (x) =>\n      x.type === 'error' && signature === getFunctionSelector(formatAbiItem(x)),\n  )\n  if (!abiItem)\n    throw new AbiErrorSignatureNotFoundError(signature, {\n      docsPath: '/docs/contract/decodeErrorResult',\n    })\n  return {\n    abiItem,\n    args: ('inputs' in abiItem && abiItem.inputs && abiItem.inputs.length > 0\n      ? decodeAbiParameters(abiItem.inputs, slice(data, 4))\n      : undefined) as readonly unknown[] | undefined,\n    errorName: (abiItem as { name: string }).name,\n  } as DecodeErrorResultReturnType<TAbi>\n}\n"],"mappings":";;;;;;AAEA,MAAAA,aAAA,GAAAC,OAAA;AACA,MAAAC,QAAA,GAAAD,OAAA;AAQA,MAAAE,UAAA,GAAAF,OAAA;AACA,MAAAG,wBAAA,GAAAH,OAAA;AAMA,MAAAI,wBAAA,GAAAJ,OAAA;AAIA,MAAAK,kBAAA,GAAAL,OAAA;AA6BA,SAAgBM,iBAAiBA,CAA8C;EAC7EC,GAAG;EACHC;AAAI,CAC8B;EAClC,MAAMC,SAAS,GAAG,IAAAP,UAAA,CAAAQ,KAAK,EAACF,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC;EACnC,IAAIC,SAAS,KAAK,IAAI,EAAE,MAAM,IAAIR,QAAA,CAAAU,wBAAwB,EAAE;EAE5D,MAAMC,IAAI,GAAG,CAAC,IAAKL,GAAW,IAAI,EAAE,CAAC,EAAER,aAAA,CAAAc,aAAa,EAAEd,aAAA,CAAAe,aAAa,CAAC;EACpE,MAAMC,OAAO,GAAGH,IAAI,CAACI,IAAI,CACtBC,CAAC,IACAA,CAAC,CAACC,IAAI,KAAK,OAAO,IAAIT,SAAS,KAAK,IAAAN,wBAAA,CAAAgB,mBAAmB,EAAC,IAAAd,kBAAA,CAAAe,aAAa,EAACH,CAAC,CAAC,CAAC,CAC5E;EACD,IAAI,CAACF,OAAO,EACV,MAAM,IAAId,QAAA,CAAAoB,8BAA8B,CAACZ,SAAS,EAAE;IAClDa,QAAQ,EAAE;GACX,CAAC;EACJ,OAAO;IACLP,OAAO;IACPQ,IAAI,EAAG,QAAQ,IAAIR,OAAO,IAAIA,OAAO,CAACS,MAAM,IAAIT,OAAO,CAACS,MAAM,CAACC,MAAM,GAAG,CAAC,GACrE,IAAArB,wBAAA,CAAAsB,mBAAmB,EAACX,OAAO,CAACS,MAAM,EAAE,IAAAtB,UAAA,CAAAQ,KAAK,EAACF,IAAI,EAAE,CAAC,CAAC,CAAC,GACnDmB,SAA4C;IAChDC,SAAS,EAAGb,OAA4B,CAACc;GACL;AACxC;AAvBAC,OAAA,CAAAxB,iBAAA,GAAAA,iBAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}