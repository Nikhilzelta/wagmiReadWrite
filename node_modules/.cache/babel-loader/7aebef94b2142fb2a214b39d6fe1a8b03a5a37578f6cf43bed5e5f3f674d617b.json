{"ast":null,"code":"import 'abitype';","map":{"version":3,"names":[],"sources":["/Users/nikhilbhatia/NIkhil/ZT-Prejects/wagmi-react-app/node_modules/viem/types/contract.ts"],"sourcesContent":["import {\n  type Abi,\n  type AbiEvent,\n  type AbiFunction,\n  type AbiParameter,\n  type AbiParameterToPrimitiveType,\n  type AbiParametersToPrimitiveTypes,\n  type AbiStateMutability,\n  type Address,\n  type ExtractAbiError,\n  type ExtractAbiErrorNames,\n  type ExtractAbiEvent,\n  type ExtractAbiEventNames,\n  type ExtractAbiFunction,\n  type ExtractAbiFunctionNames,\n  type ResolvedRegister,\n} from 'abitype'\n\nimport type { Hex, LogTopic } from './misc.js'\nimport type { TransactionRequest } from './transaction.js'\nimport type {\n  Filter,\n  IsNarrowable,\n  IsUnion,\n  MaybeRequired,\n  NoUndefined,\n  Prettify,\n  UnionToTuple,\n} from './utils.js'\n\nexport type ContractFunctionName<\n  abi extends Abi | readonly unknown[] = Abi,\n  mutability extends AbiStateMutability = AbiStateMutability,\n> = ExtractAbiFunctionNames<\n  abi extends Abi ? abi : Abi,\n  mutability\n> extends infer functionName extends string\n  ? [functionName] extends [never]\n    ? string\n    : functionName\n  : string\n\nexport type ContractErrorName<abi extends Abi | readonly unknown[] = Abi> =\n  ExtractAbiErrorNames<\n    abi extends Abi ? abi : Abi\n  > extends infer errorName extends string\n    ? [errorName] extends [never]\n      ? string\n      : errorName\n    : string\n\nexport type ContractEventName<abi extends Abi | readonly unknown[] = Abi> =\n  ExtractAbiEventNames<\n    abi extends Abi ? abi : Abi\n  > extends infer eventName extends string\n    ? [eventName] extends [never]\n      ? string\n      : eventName\n    : string\n\nexport type ContractFunctionArgs<\n  abi extends Abi | readonly unknown[] = Abi,\n  mutability extends AbiStateMutability = AbiStateMutability,\n  functionName extends ContractFunctionName<\n    abi,\n    mutability\n  > = ContractFunctionName<abi, mutability>,\n> = AbiParametersToPrimitiveTypes<\n  ExtractAbiFunction<\n    abi extends Abi ? abi : Abi,\n    functionName,\n    mutability\n  >['inputs'],\n  'inputs'\n> extends infer args\n  ? [args] extends [never]\n    ? readonly unknown[]\n    : args\n  : readonly unknown[]\n\nexport type ContractConstructorArgs<\n  abi extends Abi | readonly unknown[] = Abi,\n> = AbiParametersToPrimitiveTypes<\n  Extract<\n    (abi extends Abi ? abi : Abi)[number],\n    { type: 'constructor' }\n  >['inputs'],\n  'inputs'\n> extends infer args\n  ? [args] extends [never]\n    ? readonly unknown[]\n    : args\n  : readonly unknown[]\n\nexport type ContractErrorArgs<\n  abi extends Abi | readonly unknown[] = Abi,\n  errorName extends ContractErrorName<abi> = ContractErrorName<abi>,\n> = AbiParametersToPrimitiveTypes<\n  ExtractAbiError<abi extends Abi ? abi : Abi, errorName>['inputs'],\n  'inputs'\n> extends infer args\n  ? [args] extends [never]\n    ? readonly unknown[]\n    : args\n  : readonly unknown[]\n\nexport type ContractEventArgs<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> = ContractEventName<abi>,\n> = AbiEventParametersToPrimitiveTypes<\n  ExtractAbiEvent<abi extends Abi ? abi : Abi, eventName>['inputs']\n> extends infer args\n  ? [args] extends [never]\n    ? readonly unknown[] | Record<string, unknown>\n    : args\n  : readonly unknown[] | Record<string, unknown>\n\nexport type ContractEventArgsFromTopics<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> = ContractEventName<abi>,\n  strict extends boolean = true,\n> = AbiEventParametersToPrimitiveTypes<\n  ExtractAbiEvent<abi extends Abi ? abi : Abi, eventName>['inputs'],\n  { EnableUnion: false; IndexedOnly: false; Required: strict }\n> extends infer args\n  ? [args] extends [never]\n    ? readonly unknown[] | Record<string, unknown>\n    : args\n  : readonly unknown[] | Record<string, unknown>\n\nexport type Widen<type> =\n  | ([unknown] extends [type] ? unknown : never)\n  | (type extends Function ? type : never)\n  | (type extends ResolvedRegister['BigIntType'] ? bigint : never)\n  | (type extends boolean ? boolean : never)\n  | (type extends ResolvedRegister['IntType'] ? number : never)\n  | (type extends string\n      ? type extends ResolvedRegister['AddressType']\n        ? ResolvedRegister['AddressType']\n        : type extends ResolvedRegister['BytesType']['inputs']\n          ? ResolvedRegister['BytesType']\n          : string\n      : never)\n  | (type extends readonly [] ? readonly [] : never)\n  | (type extends Record<string, unknown>\n      ? { [K in keyof type]: Widen<type[K]> }\n      : never)\n  | (type extends { length: number }\n      ? {\n          [K in keyof type]: Widen<type[K]>\n        } extends infer Val extends readonly unknown[]\n        ? readonly [...Val]\n        : never\n      : never)\n\nexport type UnionWiden<type> = type extends any ? Widen<type> : never\n\nexport type ExtractAbiFunctionForArgs<\n  abi extends Abi,\n  mutability extends AbiStateMutability,\n  functionName extends ContractFunctionName<abi, mutability>,\n  args extends ContractFunctionArgs<abi, mutability, functionName>,\n> = ExtractAbiFunction<\n  abi,\n  functionName,\n  mutability\n> extends infer abiFunction extends AbiFunction\n  ? IsUnion<abiFunction> extends true // narrow overloads using `args` by converting to tuple and filtering out overloads that don't match\n    ? UnionToTuple<abiFunction> extends infer abiFunctions extends\n        readonly AbiFunction[]\n      ? // convert back to union (removes `never` tuple entries)\n        { [k in keyof abiFunctions]: CheckArgs<abiFunctions[k], args> }[number]\n      : never\n    : abiFunction\n  : never\ntype CheckArgs<\n  abiFunction extends AbiFunction,\n  args,\n  ///\n  targetArgs extends AbiParametersToPrimitiveTypes<\n    abiFunction['inputs'],\n    'inputs'\n  > = AbiParametersToPrimitiveTypes<abiFunction['inputs'], 'inputs'>,\n> = (readonly [] extends args ? readonly [] : args) extends targetArgs // fallback to `readonly []` if `args` has no value (e.g. `args` property not provided)\n  ? abiFunction\n  : never\n\nexport type ContractFunctionParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  mutability extends AbiStateMutability = AbiStateMutability,\n  functionName extends ContractFunctionName<\n    abi,\n    mutability\n  > = ContractFunctionName<abi, mutability>,\n  args extends ContractFunctionArgs<\n    abi,\n    mutability,\n    functionName\n  > = ContractFunctionArgs<abi, mutability, functionName>,\n  ///\n  allFunctionNames = ContractFunctionName<abi, mutability>,\n  allArgs = ContractFunctionArgs<abi, mutability, functionName>,\n  // when `args` is inferred to `readonly []` (\"inputs\": []) or `never` (`abi` declared as `Abi` or not inferrable), allow `args` to be optional.\n  // important that both branches return same structural type\n> = {\n  address: Address\n  abi: abi\n  functionName:\n    | allFunctionNames // show all options\n    | (functionName extends allFunctionNames ? functionName : never) // infer value\n  args?: (abi extends Abi ? UnionWiden<args> : never) | allArgs | undefined\n} & (readonly [] extends allArgs ? {} : { args: Widen<args> }) &\n  GetValue<abi, functionName>\n\nexport type ContractFunctionReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  mutability extends AbiStateMutability = AbiStateMutability,\n  functionName extends ContractFunctionName<\n    abi,\n    mutability\n  > = ContractFunctionName<abi, mutability>,\n  args extends ContractFunctionArgs<\n    abi,\n    mutability,\n    functionName\n  > = ContractFunctionArgs<abi, mutability, functionName>,\n> = abi extends Abi\n  ? Abi extends abi\n    ? unknown\n    : AbiParametersToPrimitiveTypes<\n          ExtractAbiFunctionForArgs<\n            abi,\n            mutability,\n            functionName,\n            args\n          >['outputs']\n        > extends infer types\n      ? types extends readonly []\n        ? void\n        : types extends readonly [infer type]\n          ? type\n          : types\n      : never\n  : unknown\n\nexport type AbiItem = Abi[number]\n\nexport type ExtractAbiItemNames<abi extends Abi> = Extract<\n  abi[number],\n  { name: string }\n>['name']\n\nexport type ExtractAbiItem<\n  abi extends Abi,\n  name extends ExtractAbiItemNames<abi>,\n> = Extract<abi[number], { name: name }>\n\nexport type AbiItemName<abi extends Abi | readonly unknown[] = Abi> =\n  abi extends Abi ? ExtractAbiItemNames<abi> : string\n\nexport type AbiItemArgs<\n  abi extends Abi | readonly unknown[] = Abi,\n  name extends AbiItemName<abi> = AbiItemName<abi>,\n> = AbiParametersToPrimitiveTypes<\n  ExtractAbiItem<abi extends Abi ? abi : Abi, name>['inputs'],\n  'inputs'\n> extends infer args\n  ? [args] extends [never]\n    ? readonly unknown[]\n    : args\n  : readonly unknown[]\n\nexport type ExtractAbiItemForArgs<\n  abi extends Abi,\n  name extends AbiItemName<abi>,\n  args extends AbiItemArgs<abi, name>,\n> = ExtractAbiItem<abi, name> extends infer abiItem extends AbiItem & {\n  inputs: readonly AbiParameter[]\n}\n  ? IsUnion<abiItem> extends true // narrow overloads using `args` by converting to tuple and filtering out overloads that don't match\n    ? UnionToTuple<abiItem> extends infer abiItems extends readonly (AbiItem & {\n        inputs: readonly AbiParameter[]\n      })[]\n      ? {\n          [k in keyof abiItems]: (\n            readonly [] extends args\n              ? readonly [] // fallback to `readonly []` if `args` has no value (e.g. `args` property not provided)\n              : args\n          ) extends AbiParametersToPrimitiveTypes<\n            abiItems[k]['inputs'],\n            'inputs'\n          >\n            ? abiItems[k]\n            : never\n        }[number] // convert back to union (removes `never` tuple entries: `['foo', never, 'bar'][number]` => `'foo' | 'bar'`)\n      : never\n    : abiItem\n  : never\n\nexport type EventDefinition = `${string}(${string})`\n\nexport type GetValue<\n  TAbi extends Abi | readonly unknown[],\n  TFunctionName extends string,\n  TValueType = TransactionRequest['value'],\n  TAbiFunction extends AbiFunction = TAbi extends Abi\n    ? ExtractAbiFunction<TAbi, TFunctionName>\n    : AbiFunction,\n  _Narrowable extends boolean = IsNarrowable<TAbi, Abi>,\n> = _Narrowable extends true\n  ? TAbiFunction['stateMutability'] extends 'payable'\n    ? { value?: NoUndefined<TValueType> | undefined }\n    : TAbiFunction['payable'] extends true\n      ? { value?: NoUndefined<TValueType> | undefined }\n      : { value?: never | undefined }\n  : { value?: TValueType | undefined }\n\n//////////////////////////////////////////////////////////////////////////////////////////////////\n\nexport type MaybeAbiEventName<TAbiEvent extends AbiEvent | undefined> =\n  TAbiEvent extends AbiEvent ? TAbiEvent['name'] : undefined\n\nexport type MaybeExtractEventArgsFromAbi<\n  TAbi extends Abi | readonly unknown[] | undefined,\n  TEventName extends string | undefined,\n> = TAbi extends Abi | readonly unknown[]\n  ? TEventName extends string\n    ? GetEventArgs<TAbi, TEventName>\n    : undefined\n  : undefined\n\n//////////////////////////////////////////////////////////////////////\n// ABI item args\n\nexport type GetEventArgs<\n  TAbi extends Abi | readonly unknown[],\n  TEventName extends string,\n  TConfig extends EventParameterOptions = DefaultEventParameterOptions,\n  TAbiEvent extends AbiEvent & { type: 'event' } = TAbi extends Abi\n    ? ExtractAbiEvent<TAbi, TEventName>\n    : AbiEvent & { type: 'event' },\n  TArgs = AbiEventParametersToPrimitiveTypes<TAbiEvent['inputs'], TConfig>,\n  FailedToParseArgs =\n    | ([TArgs] extends [never] ? true : false)\n    | (readonly unknown[] extends TArgs ? true : false),\n> = true extends FailedToParseArgs\n  ? readonly unknown[] | Record<string, unknown>\n  : TArgs\n\n//////////////////////////////////////////////////////////////////////\n// ABI event types\n\ntype EventParameterOptions = {\n  EnableUnion?: boolean\n  IndexedOnly?: boolean\n  Required?: boolean\n}\ntype DefaultEventParameterOptions = {\n  EnableUnion: true\n  IndexedOnly: true\n  Required: false\n}\n\nexport type AbiEventParametersToPrimitiveTypes<\n  TAbiParameters extends readonly AbiParameter[],\n  Options extends EventParameterOptions = DefaultEventParameterOptions,\n  // Remove non-indexed parameters based on `Options['IndexedOnly']`\n> = TAbiParameters extends readonly []\n  ? readonly []\n  : Filter<\n        TAbiParameters,\n        Options['IndexedOnly'] extends true ? { indexed: true } : object\n      > extends infer Filtered extends readonly AbiParameter[]\n    ? _HasUnnamedAbiParameter<Filtered> extends true\n      ? // Has unnamed tuple parameters so return as array\n          | readonly [\n              ...{\n                [K in keyof Filtered]: AbiEventParameterToPrimitiveType<\n                  Filtered[K],\n                  Options\n                >\n              },\n            ]\n          // Distribute over tuple to represent optional parameters\n          | (Options['Required'] extends true\n              ? never\n              : // Distribute over tuple to represent optional parameters\n                Filtered extends readonly [\n                    ...infer Head extends readonly AbiParameter[],\n                    infer _,\n                  ]\n                ? AbiEventParametersToPrimitiveTypes<\n                    readonly [...{ [K in keyof Head]: Omit<Head[K], 'name'> }],\n                    Options\n                  >\n                : never)\n      : // All tuple parameters are named so return as object\n        {\n            [Parameter in Filtered[number] as Parameter extends {\n              name: infer Name extends string\n            }\n              ? Name\n              : never]?:\n              | AbiEventParameterToPrimitiveType<Parameter, Options>\n              | undefined\n          } extends infer Mapped\n        ? Prettify<\n            MaybeRequired<\n              Mapped,\n              Options['Required'] extends boolean ? Options['Required'] : false\n            >\n          >\n        : never\n    : never\n\n// TODO: Speed up by returning immediately as soon as named parameter is found.\ntype _HasUnnamedAbiParameter<TAbiParameters extends readonly AbiParameter[]> =\n  TAbiParameters extends readonly [\n    infer Head extends AbiParameter,\n    ...infer Tail extends readonly AbiParameter[],\n  ]\n    ? Head extends { name: string }\n      ? Head['name'] extends ''\n        ? true\n        : _HasUnnamedAbiParameter<Tail>\n      : true\n    : false\n\n/**\n * @internal\n */\nexport type LogTopicType<\n  TPrimitiveType = Hex,\n  TTopic extends LogTopic = LogTopic,\n> = TTopic extends Hex\n  ? TPrimitiveType\n  : TTopic extends Hex[]\n    ? TPrimitiveType[]\n    : TTopic extends null\n      ? null\n      : never\n\n/**\n * @internal\n */\nexport type AbiEventParameterToPrimitiveType<\n  TAbiParameter extends AbiParameter,\n  Options extends EventParameterOptions = DefaultEventParameterOptions,\n  _Type = AbiParameterToPrimitiveType<TAbiParameter>,\n> = Options['EnableUnion'] extends true ? LogTopicType<_Type> : _Type\n\ntype HashedEventTypes = 'bytes' | 'string' | 'tuple' | `${string}[${string}]`\n\n/**\n * @internal\n */\nexport type AbiEventTopicToPrimitiveType<\n  TAbiParameter extends AbiParameter,\n  TTopic extends LogTopic,\n  TPrimitiveType = TAbiParameter['type'] extends HashedEventTypes\n    ? TTopic\n    : AbiParameterToPrimitiveType<TAbiParameter>,\n> = LogTopicType<TPrimitiveType, TTopic>\n"],"mappings":"AAAA,OAgBO,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}