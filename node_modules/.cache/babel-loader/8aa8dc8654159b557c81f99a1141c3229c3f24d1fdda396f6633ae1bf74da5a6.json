{"ast":null,"code":"import { TimeoutError } from '../../errors/request.js';\nimport { createBatchScheduler } from '../promise/createBatchScheduler.js';\nimport { withTimeout } from '../promise/withTimeout.js';\nimport { idCache } from './id.js';\nexport const socketClientCache = /*#__PURE__*/new Map();\nexport async function getSocketRpcClient(params) {\n  const {\n    getSocket,\n    reconnect = true,\n    url\n  } = params;\n  const {\n    attempts = 5,\n    delay = 2_000\n  } = typeof reconnect === 'object' ? reconnect : {};\n  let socketClient = socketClientCache.get(url);\n  // If the socket already exists, return it.\n  if (socketClient) return socketClient;\n  let reconnectCount = 0;\n  const {\n    schedule\n  } = createBatchScheduler({\n    id: url,\n    fn: async () => {\n      // Set up a cache for incoming \"synchronous\" requests.\n      const requests = new Map();\n      // Set up a cache for subscriptions (eth_subscribe).\n      const subscriptions = new Map();\n      let error;\n      let socket;\n      // Set up socket implementation.\n      async function setup() {\n        return getSocket({\n          onError(error_) {\n            error = error_;\n            // Notify all requests and subscriptions of the error.\n            for (const request of requests.values()) request.onError?.(error);\n            for (const subscription of subscriptions.values()) subscription.onError?.(error);\n            // Clear all requests and subscriptions.\n            requests.clear();\n            subscriptions.clear();\n            // Attempt to reconnect.\n            if (reconnect && reconnectCount < attempts) setTimeout(async () => {\n              reconnectCount++;\n              socket = await setup().catch(console.error);\n            }, delay);\n          },\n          onOpen() {\n            error = undefined;\n            reconnectCount = 0;\n          },\n          onResponse(data) {\n            const isSubscription = data.method === 'eth_subscription';\n            const id = isSubscription ? data.params.subscription : data.id;\n            const cache = isSubscription ? subscriptions : requests;\n            const callback = cache.get(id);\n            if (callback) callback.onResponse(data);\n            if (!isSubscription) cache.delete(id);\n          }\n        });\n      }\n      socket = await setup();\n      error = undefined;\n      // Create a new socket instance.\n      socketClient = {\n        close() {\n          socket.close();\n          socketClientCache.delete(url);\n        },\n        socket,\n        request({\n          body,\n          onError,\n          onResponse\n        }) {\n          if (error && onError) onError(error);\n          const id = body.id ?? idCache.take();\n          const callback = response => {\n            if (typeof response.id === 'number' && id !== response.id) return;\n            // If we are subscribing to a topic, we want to set up a listener for incoming\n            // messages.\n            if (body.method === 'eth_subscribe' && typeof response.result === 'string') subscriptions.set(response.result, {\n              onResponse: callback,\n              onError\n            });\n            // If we are unsubscribing from a topic, we want to remove the listener.\n            if (body.method === 'eth_unsubscribe') subscriptions.delete(body.params?.[0]);\n            onResponse(response);\n          };\n          requests.set(id, {\n            onResponse: callback,\n            onError\n          });\n          try {\n            socket.request({\n              body: {\n                jsonrpc: '2.0',\n                id,\n                ...body\n              }\n            });\n          } catch (error) {\n            onError?.(error);\n          }\n        },\n        requestAsync({\n          body,\n          timeout = 10_000\n        }) {\n          return withTimeout(() => new Promise((onResponse, onError) => this.request({\n            body,\n            onError,\n            onResponse\n          })), {\n            errorInstance: new TimeoutError({\n              body,\n              url\n            }),\n            timeout\n          });\n        },\n        requests,\n        subscriptions,\n        url\n      };\n      socketClientCache.set(url, socketClient);\n      return [socketClient];\n    }\n  });\n  const [_, [socketClient_]] = await schedule();\n  return socketClient_;\n}","map":{"version":3,"names":["TimeoutError","createBatchScheduler","withTimeout","idCache","socketClientCache","Map","getSocketRpcClient","params","getSocket","reconnect","url","attempts","delay","socketClient","get","reconnectCount","schedule","id","fn","requests","subscriptions","error","socket","setup","onError","error_","request","values","subscription","clear","setTimeout","catch","console","onOpen","undefined","onResponse","data","isSubscription","method","cache","callback","delete","close","body","take","response","result","set","jsonrpc","requestAsync","timeout","Promise","errorInstance","_","socketClient_"],"sources":["/Users/nikhilbhatia/NIkhil/ZT-Prejects/wagmi-react-app/node_modules/viem/utils/rpc/socket.ts"],"sourcesContent":["import { TimeoutError } from '../../errors/request.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { RpcRequest, RpcResponse } from '../../types/rpc.js'\nimport {\n  type CreateBatchSchedulerErrorType,\n  createBatchScheduler,\n} from '../promise/createBatchScheduler.js'\nimport { withTimeout } from '../promise/withTimeout.js'\nimport { idCache } from './id.js'\n\ntype Id = string | number\ntype CallbackFn = {\n  onResponse: (message: any) => void\n  onError?: ((error?: Error | Event | undefined) => void) | undefined\n}\ntype CallbackMap = Map<Id, CallbackFn>\n\nexport type GetSocketParameters = {\n  onError: (error?: Error | Event | undefined) => void\n  onOpen: () => void\n  onResponse: (data: RpcResponse) => void\n}\n\nexport type Socket<socket extends {}> = socket & {\n  close(): void\n  request(params: {\n    body: RpcRequest\n  }): void\n}\n\nexport type SocketRpcClient<socket extends {}> = {\n  close(): void\n  socket: Socket<socket>\n  request(params: {\n    body: RpcRequest\n    onError?: ((error?: Error | Event | undefined) => void) | undefined\n    onResponse: (message: RpcResponse) => void\n  }): void\n  requestAsync(params: {\n    body: RpcRequest\n    timeout?: number | undefined\n  }): Promise<RpcResponse>\n  requests: CallbackMap\n  subscriptions: CallbackMap\n  url: string\n}\n\nexport type GetSocketRpcClientParameters<socket extends {} = {}> = {\n  getSocket(params: GetSocketParameters): Promise<Socket<socket>>\n  /**\n   * Whether or not to attempt to reconnect on socket failure.\n   * @default true\n   */\n  reconnect?:\n    | boolean\n    | {\n        /**\n         * The maximum number of reconnection attempts.\n         * @default 5\n         */\n        attempts?: number | undefined\n        /**\n         * The delay (in ms) between reconnection attempts.\n         * @default 2_000\n         */\n        delay?: number | undefined\n      }\n    | undefined\n  url: string\n}\n\nexport type GetSocketRpcClientErrorType =\n  | CreateBatchSchedulerErrorType\n  | ErrorType\n\nexport const socketClientCache = /*#__PURE__*/ new Map<\n  string,\n  SocketRpcClient<Socket<{}>>\n>()\n\nexport async function getSocketRpcClient<socket extends {}>(\n  params: GetSocketRpcClientParameters<socket>,\n): Promise<SocketRpcClient<socket>> {\n  const { getSocket, reconnect = true, url } = params\n  const { attempts = 5, delay = 2_000 } =\n    typeof reconnect === 'object' ? reconnect : {}\n\n  let socketClient = socketClientCache.get(url)\n\n  // If the socket already exists, return it.\n  if (socketClient) return socketClient as {} as SocketRpcClient<socket>\n\n  let reconnectCount = 0\n  const { schedule } = createBatchScheduler<\n    undefined,\n    [SocketRpcClient<socket>]\n  >({\n    id: url,\n    fn: async () => {\n      // Set up a cache for incoming \"synchronous\" requests.\n      const requests = new Map<Id, CallbackFn>()\n\n      // Set up a cache for subscriptions (eth_subscribe).\n      const subscriptions = new Map<Id, CallbackFn>()\n\n      let error: Error | Event | undefined\n      let socket: Socket<any>\n      // Set up socket implementation.\n      async function setup() {\n        return getSocket({\n          onError(error_) {\n            error = error_\n\n            // Notify all requests and subscriptions of the error.\n            for (const request of requests.values()) request.onError?.(error)\n            for (const subscription of subscriptions.values())\n              subscription.onError?.(error)\n\n            // Clear all requests and subscriptions.\n            requests.clear()\n            subscriptions.clear()\n\n            // Attempt to reconnect.\n            if (reconnect && reconnectCount < attempts)\n              setTimeout(async () => {\n                reconnectCount++\n                socket = await setup().catch(console.error)\n              }, delay)\n          },\n          onOpen() {\n            error = undefined\n            reconnectCount = 0\n          },\n          onResponse(data) {\n            const isSubscription = data.method === 'eth_subscription'\n            const id = isSubscription ? data.params.subscription : data.id\n            const cache = isSubscription ? subscriptions : requests\n            const callback = cache.get(id)\n            if (callback) callback.onResponse(data)\n            if (!isSubscription) cache.delete(id)\n          },\n        })\n      }\n      socket = await setup()\n      error = undefined\n\n      // Create a new socket instance.\n      socketClient = {\n        close() {\n          socket.close()\n          socketClientCache.delete(url)\n        },\n        socket,\n        request({ body, onError, onResponse }) {\n          if (error && onError) onError(error)\n\n          const id = body.id ?? idCache.take()\n\n          const callback = (response: RpcResponse) => {\n            if (typeof response.id === 'number' && id !== response.id) return\n\n            // If we are subscribing to a topic, we want to set up a listener for incoming\n            // messages.\n            if (\n              body.method === 'eth_subscribe' &&\n              typeof response.result === 'string'\n            )\n              subscriptions.set(response.result, {\n                onResponse: callback,\n                onError,\n              })\n\n            // If we are unsubscribing from a topic, we want to remove the listener.\n            if (body.method === 'eth_unsubscribe')\n              subscriptions.delete(body.params?.[0])\n\n            onResponse(response)\n          }\n\n          requests.set(id, { onResponse: callback, onError })\n          try {\n            socket.request({\n              body: {\n                jsonrpc: '2.0',\n                id,\n                ...body,\n              },\n            })\n          } catch (error) {\n            onError?.(error as Error)\n          }\n        },\n        requestAsync({ body, timeout = 10_000 }) {\n          return withTimeout(\n            () =>\n              new Promise<RpcResponse>((onResponse, onError) =>\n                this.request({\n                  body,\n                  onError,\n                  onResponse,\n                }),\n              ),\n            {\n              errorInstance: new TimeoutError({ body, url }),\n              timeout,\n            },\n          )\n        },\n        requests,\n        subscriptions,\n        url,\n      }\n      socketClientCache.set(url, socketClient)\n\n      return [socketClient as {} as SocketRpcClient<socket>]\n    },\n  })\n\n  const [_, [socketClient_]] = await schedule()\n  return socketClient_\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}