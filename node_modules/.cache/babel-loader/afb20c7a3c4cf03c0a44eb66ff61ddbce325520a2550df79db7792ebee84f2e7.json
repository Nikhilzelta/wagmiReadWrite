{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hexToString = exports.hexToNumber = exports.hexToBool = exports.hexToBigInt = exports.fromHex = exports.assertSize = void 0;\nconst encoding_js_1 = require(\"../../errors/encoding.js\");\nconst size_js_1 = require(\"../data/size.js\");\nconst trim_js_1 = require(\"../data/trim.js\");\nconst toBytes_js_1 = require(\"./toBytes.js\");\nfunction assertSize(hexOrBytes, {\n  size\n}) {\n  if ((0, size_js_1.size)(hexOrBytes) > size) throw new encoding_js_1.SizeOverflowError({\n    givenSize: (0, size_js_1.size)(hexOrBytes),\n    maxSize: size\n  });\n}\nexports.assertSize = assertSize;\nfunction fromHex(hex, toOrOpts) {\n  const opts = typeof toOrOpts === 'string' ? {\n    to: toOrOpts\n  } : toOrOpts;\n  const to = opts.to;\n  if (to === 'number') return hexToNumber(hex, opts);\n  if (to === 'bigint') return hexToBigInt(hex, opts);\n  if (to === 'string') return hexToString(hex, opts);\n  if (to === 'boolean') return hexToBool(hex, opts);\n  return (0, toBytes_js_1.hexToBytes)(hex, opts);\n}\nexports.fromHex = fromHex;\nfunction hexToBigInt(hex, opts = {}) {\n  const {\n    signed\n  } = opts;\n  if (opts.size) assertSize(hex, {\n    size: opts.size\n  });\n  const value = BigInt(hex);\n  if (!signed) return value;\n  const size = (hex.length - 2) / 2;\n  const max = (1n << BigInt(size) * 8n - 1n) - 1n;\n  if (value <= max) return value;\n  return value - BigInt(`0x${'f'.padStart(size * 2, 'f')}`) - 1n;\n}\nexports.hexToBigInt = hexToBigInt;\nfunction hexToBool(hex_, opts = {}) {\n  let hex = hex_;\n  if (opts.size) {\n    assertSize(hex, {\n      size: opts.size\n    });\n    hex = (0, trim_js_1.trim)(hex);\n  }\n  if ((0, trim_js_1.trim)(hex) === '0x00') return false;\n  if ((0, trim_js_1.trim)(hex) === '0x01') return true;\n  throw new encoding_js_1.InvalidHexBooleanError(hex);\n}\nexports.hexToBool = hexToBool;\nfunction hexToNumber(hex, opts = {}) {\n  return Number(hexToBigInt(hex, opts));\n}\nexports.hexToNumber = hexToNumber;\nfunction hexToString(hex, opts = {}) {\n  let bytes = (0, toBytes_js_1.hexToBytes)(hex);\n  if (opts.size) {\n    assertSize(bytes, {\n      size: opts.size\n    });\n    bytes = (0, trim_js_1.trim)(bytes, {\n      dir: 'right'\n    });\n  }\n  return new TextDecoder().decode(bytes);\n}\nexports.hexToString = hexToString;","map":{"version":3,"names":["encoding_js_1","require","size_js_1","trim_js_1","toBytes_js_1","assertSize","hexOrBytes","size","SizeOverflowError","givenSize","maxSize","exports","fromHex","hex","toOrOpts","opts","to","hexToNumber","hexToBigInt","hexToString","hexToBool","hexToBytes","signed","value","BigInt","length","max","padStart","hex_","trim","InvalidHexBooleanError","Number","bytes","dir","TextDecoder","decode"],"sources":["/Users/nikhilbhatia/NIkhil/ZT-Prejects/wagmi-react-app/node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/encoding/fromHex.ts"],"sourcesContent":["import {\n  InvalidHexBooleanError,\n  type InvalidHexBooleanErrorType,\n  SizeOverflowError,\n  type SizeOverflowErrorType,\n} from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type SizeErrorType, size as size_ } from '../data/size.js'\nimport { type TrimErrorType, trim } from '../data/trim.js'\n\nimport { type HexToBytesErrorType, hexToBytes } from './toBytes.js'\n\nexport type AssertSizeErrorType =\n  | SizeOverflowErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function assertSize(\n  hexOrBytes: Hex | ByteArray,\n  { size }: { size: number },\n): void {\n  if (size_(hexOrBytes) > size)\n    throw new SizeOverflowError({\n      givenSize: size_(hexOrBytes),\n      maxSize: size,\n    })\n}\n\nexport type FromHexParameters<\n  TTo extends 'string' | 'bigint' | 'number' | 'bytes' | 'boolean',\n> =\n  | TTo\n  | {\n      /** Size (in bytes) of the hex value. */\n      size?: number\n      /** Type to convert to. */\n      to: TTo\n    }\n\nexport type FromHexReturnType<TTo> = TTo extends 'string'\n  ? string\n  : TTo extends 'bigint'\n    ? bigint\n    : TTo extends 'number'\n      ? number\n      : TTo extends 'bytes'\n        ? ByteArray\n        : TTo extends 'boolean'\n          ? boolean\n          : never\n\nexport type FromHexErrorType =\n  | HexToNumberErrorType\n  | HexToBigIntErrorType\n  | HexToBoolErrorType\n  | HexToStringErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\n/**\n * Decodes a hex string into a string, number, bigint, boolean, or byte array.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex.html\n * - Example: https://viem.sh/docs/utilities/fromHex.html#usage\n *\n * @param hex Hex string to decode.\n * @param toOrOpts Type to convert to or options.\n * @returns Decoded value.\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x1a4', 'number')\n * // 420\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c6421', 'string')\n * // 'Hello world'\n *\n * @example\n * import { fromHex } from 'viem'\n * const data = fromHex('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *   size: 32,\n *   to: 'string'\n * })\n * // 'Hello world'\n */\nexport function fromHex<\n  TTo extends 'string' | 'bigint' | 'number' | 'bytes' | 'boolean',\n>(hex: Hex, toOrOpts: FromHexParameters<TTo>): FromHexReturnType<TTo> {\n  const opts = typeof toOrOpts === 'string' ? { to: toOrOpts } : toOrOpts\n  const to = opts.to\n\n  if (to === 'number') return hexToNumber(hex, opts) as FromHexReturnType<TTo>\n  if (to === 'bigint') return hexToBigInt(hex, opts) as FromHexReturnType<TTo>\n  if (to === 'string') return hexToString(hex, opts) as FromHexReturnType<TTo>\n  if (to === 'boolean') return hexToBool(hex, opts) as FromHexReturnType<TTo>\n  return hexToBytes(hex, opts) as FromHexReturnType<TTo>\n}\n\nexport type HexToBigIntOpts = {\n  /** Whether or not the number of a signed representation. */\n  signed?: boolean\n  /** Size (in bytes) of the hex value. */\n  size?: number\n}\n\nexport type HexToBigIntErrorType = AssertSizeErrorType | ErrorType\n\n/**\n * Decodes a hex value into a bigint.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex.html#hextobigint\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns BigInt value.\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x1a4', { signed: true })\n * // 420n\n *\n * @example\n * import { hexToBigInt } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420n\n */\nexport function hexToBigInt(hex: Hex, opts: HexToBigIntOpts = {}): bigint {\n  const { signed } = opts\n\n  if (opts.size) assertSize(hex, { size: opts.size })\n\n  const value = BigInt(hex)\n  if (!signed) return value\n\n  const size = (hex.length - 2) / 2\n  const max = (1n << (BigInt(size) * 8n - 1n)) - 1n\n  if (value <= max) return value\n\n  return value - BigInt(`0x${'f'.padStart(size * 2, 'f')}`) - 1n\n}\n\nexport type HexToBoolOpts = {\n  /** Size (in bytes) of the hex value. */\n  size?: number\n}\n\nexport type HexToBoolErrorType =\n  | AssertSizeErrorType\n  | InvalidHexBooleanErrorType\n  | TrimErrorType\n  | ErrorType\n\n/**\n * Decodes a hex value into a boolean.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex.html#hextobool\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Boolean value.\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x01')\n * // true\n *\n * @example\n * import { hexToBool } from 'viem'\n * const data = hexToBool('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // true\n */\nexport function hexToBool(hex_: Hex, opts: HexToBoolOpts = {}): boolean {\n  let hex = hex_\n  if (opts.size) {\n    assertSize(hex, { size: opts.size })\n    hex = trim(hex)\n  }\n  if (trim(hex) === '0x00') return false\n  if (trim(hex) === '0x01') return true\n  throw new InvalidHexBooleanError(hex)\n}\n\nexport type HexToNumberOpts = HexToBigIntOpts\n\nexport type HexToNumberErrorType = HexToBigIntErrorType | ErrorType\n\n/**\n * Decodes a hex string into a number.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex.html#hextonumber\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns Number value.\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToNumber('0x1a4')\n * // 420\n *\n * @example\n * import { hexToNumber } from 'viem'\n * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // 420\n */\nexport function hexToNumber(hex: Hex, opts: HexToNumberOpts = {}): number {\n  return Number(hexToBigInt(hex, opts))\n}\n\nexport type HexToStringOpts = {\n  /** Size (in bytes) of the hex value. */\n  size?: number\n}\n\nexport type HexToStringErrorType =\n  | AssertSizeErrorType\n  | HexToBytesErrorType\n  | TrimErrorType\n  | ErrorType\n\n/**\n * Decodes a hex value into a UTF-8 string.\n *\n * - Docs: https://viem.sh/docs/utilities/fromHex.html#hextostring\n *\n * @param hex Hex value to decode.\n * @param opts Options.\n * @returns String value.\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c6421')\n * // 'Hello world!'\n *\n * @example\n * import { hexToString } from 'viem'\n * const data = hexToString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // 'Hello world'\n */\nexport function hexToString(hex: Hex, opts: HexToStringOpts = {}): string {\n  let bytes = hexToBytes(hex)\n  if (opts.size) {\n    assertSize(bytes, { size: opts.size })\n    bytes = trim(bytes, { dir: 'right' })\n  }\n  return new TextDecoder().decode(bytes)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}