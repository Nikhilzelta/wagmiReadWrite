{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.rlpToHex = exports.rlpToBytes = exports.fromRlp = void 0;\nconst base_js_1 = require(\"../../errors/base.js\");\nconst encoding_js_1 = require(\"../../errors/encoding.js\");\nconst cursor_js_1 = require(\"../cursor.js\");\nconst toBytes_js_1 = require(\"./toBytes.js\");\nconst toHex_js_1 = require(\"./toHex.js\");\nfunction fromRlp(value, to = 'hex') {\n  const bytes = (() => {\n    if (typeof value === 'string') {\n      if (value.length > 3 && value.length % 2 !== 0) throw new encoding_js_1.InvalidHexValueError(value);\n      return (0, toBytes_js_1.hexToBytes)(value);\n    }\n    return value;\n  })();\n  const cursor = (0, cursor_js_1.createCursor)(bytes);\n  const result = fromRlpCursor(cursor, to);\n  return result;\n}\nexports.fromRlp = fromRlp;\nfunction rlpToBytes(bytes, to = 'bytes') {\n  return fromRlp(bytes, to);\n}\nexports.rlpToBytes = rlpToBytes;\nfunction rlpToHex(hex, to = 'hex') {\n  return fromRlp(hex, to);\n}\nexports.rlpToHex = rlpToHex;\nfunction fromRlpCursor(cursor, to = 'hex') {\n  if (cursor.bytes.length === 0) return to === 'hex' ? (0, toHex_js_1.bytesToHex)(cursor.bytes) : cursor.bytes;\n  const prefix = cursor.readByte();\n  if (prefix < 0x80) cursor.decrementPosition(1);\n  if (prefix < 0xc0) {\n    const length = readLength(cursor, prefix, 0x80);\n    const bytes = cursor.readBytes(length);\n    return to === 'hex' ? (0, toHex_js_1.bytesToHex)(bytes) : bytes;\n  }\n  const length = readLength(cursor, prefix, 0xc0);\n  return readList(cursor, length, to);\n}\nfunction readLength(cursor, prefix, offset) {\n  if (offset === 0x80 && prefix < 0x80) return 1;\n  if (prefix <= offset + 55) return prefix - offset;\n  if (prefix === offset + 55 + 1) return cursor.readUint8();\n  if (prefix === offset + 55 + 2) return cursor.readUint16();\n  if (prefix === offset + 55 + 3) return cursor.readUint24();\n  if (prefix === offset + 55 + 4) return cursor.readUint32();\n  throw new base_js_1.BaseError('Invalid RLP prefix');\n}\nfunction readList(cursor, length, to) {\n  const position = cursor.position;\n  const value = [];\n  while (cursor.position - position < length) value.push(fromRlpCursor(cursor, to));\n  return value;\n}","map":{"version":3,"names":["base_js_1","require","encoding_js_1","cursor_js_1","toBytes_js_1","toHex_js_1","fromRlp","value","to","bytes","length","InvalidHexValueError","hexToBytes","cursor","createCursor","result","fromRlpCursor","exports","rlpToBytes","rlpToHex","hex","bytesToHex","prefix","readByte","decrementPosition","readLength","readBytes","readList","offset","readUint8","readUint16","readUint24","readUint32","BaseError","position","push"],"sources":["/Users/nikhilbhatia/NIkhil/ZT-Prejects/wagmi-react-app/node_modules/@safe-global/safe-apps-sdk/node_modules/viem/utils/encoding/fromRlp.ts"],"sourcesContent":["import { BaseError, type BaseErrorType } from '../../errors/base.js'\nimport {\n  InvalidHexValueError,\n  type InvalidHexValueErrorType,\n} from '../../errors/encoding.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport {\n  type CreateCursorErrorType,\n  type Cursor,\n  createCursor,\n} from '../cursor.js'\nimport { type HexToBytesErrorType, hexToBytes } from './toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from './toHex.js'\n\nimport type { RecursiveArray } from './toRlp.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type FromRlpReturnType<to extends To> =\n  | (to extends 'bytes' ? RecursiveArray<ByteArray> : never)\n  | (to extends 'hex' ? RecursiveArray<Hex> : never)\n\nexport type FromRlpErrorType =\n  | CreateCursorErrorType\n  | FromRlpCursorErrorType\n  | HexToBytesErrorType\n  | InvalidHexValueErrorType\n  | ErrorType\n\nexport function fromRlp<to extends To = 'hex'>(\n  value: ByteArray | Hex,\n  to: to | To | undefined = 'hex',\n): FromRlpReturnType<to> {\n  const bytes = (() => {\n    if (typeof value === 'string') {\n      if (value.length > 3 && value.length % 2 !== 0)\n        throw new InvalidHexValueError(value)\n      return hexToBytes(value)\n    }\n    return value\n  })()\n\n  const cursor = createCursor(bytes)\n  const result = fromRlpCursor(cursor, to)\n\n  return result as FromRlpReturnType<to>\n}\n\nexport type RlpToBytesErrorType = FromRlpErrorType | ErrorType\n\nexport function rlpToBytes<to extends To = 'bytes'>(\n  bytes: ByteArray,\n  to: to | To | undefined = 'bytes',\n): FromRlpReturnType<to> {\n  return fromRlp(bytes, to)\n}\n\nexport type RlpToHexErrorType = FromRlpErrorType | ErrorType\n\nexport function rlpToHex<to extends To = 'hex'>(\n  hex: Hex,\n  to: to | To | undefined = 'hex',\n): FromRlpReturnType<to> {\n  return fromRlp(hex, to)\n}\n\nexport type FromRlpCursorErrorType =\n  | BytesToHexErrorType\n  | ReadLengthErrorType\n  | ReadListErrorType\n  | ErrorType\n\nfunction fromRlpCursor<to extends To = 'hex'>(\n  cursor: Cursor,\n  to: to | To | undefined = 'hex',\n): FromRlpReturnType<to> {\n  if (cursor.bytes.length === 0)\n    return (\n      to === 'hex' ? bytesToHex(cursor.bytes) : cursor.bytes\n    ) as FromRlpReturnType<to>\n\n  const prefix = cursor.readByte()\n  if (prefix < 0x80) cursor.decrementPosition(1)\n\n  // bytes\n  if (prefix < 0xc0) {\n    const length = readLength(cursor, prefix, 0x80)\n    const bytes = cursor.readBytes(length)\n    return (to === 'hex' ? bytesToHex(bytes) : bytes) as FromRlpReturnType<to>\n  }\n\n  // list\n  const length = readLength(cursor, prefix, 0xc0)\n  return readList(cursor, length, to) as {} as FromRlpReturnType<to>\n}\n\nexport type ReadLengthErrorType = BaseErrorType | ErrorType\n\nfunction readLength(cursor: Cursor, prefix: number, offset: number) {\n  if (offset === 0x80 && prefix < 0x80) return 1\n  if (prefix <= offset + 55) return prefix - offset\n  if (prefix === offset + 55 + 1) return cursor.readUint8()\n  if (prefix === offset + 55 + 2) return cursor.readUint16()\n  if (prefix === offset + 55 + 3) return cursor.readUint24()\n  if (prefix === offset + 55 + 4) return cursor.readUint32()\n  throw new BaseError('Invalid RLP prefix')\n}\n\nexport type ReadListErrorType = ErrorType\n\nfunction readList<to extends To>(cursor: Cursor, length: number, to: to | To) {\n  const position = cursor.position\n  const value: FromRlpReturnType<to>[] = []\n  while (cursor.position - position < length)\n    value.push(fromRlpCursor(cursor, to))\n  return value\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}