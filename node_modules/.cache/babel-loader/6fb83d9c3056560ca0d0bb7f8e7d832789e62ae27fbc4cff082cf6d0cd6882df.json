{"ast":null,"code":"import { parseAccount } from '../../accounts/utils/parseAccount.js';\nimport { multicall3Abi } from '../../constants/abis.js';\nimport { aggregate3Signature } from '../../constants/contract.js';\nimport { InvalidAddressError } from '../../errors/address.js';\nimport { BaseError } from '../../errors/base.js';\nimport { ChainDoesNotSupportContract, ClientChainNotConfiguredError } from '../../errors/chain.js';\nimport { RawContractError } from '../../errors/contract.js';\nimport { InvalidBytesLengthError } from '../../errors/data.js';\nimport { AccountStateConflictError, StateAssignmentConflictError } from '../../errors/stateOverride.js';\nimport { decodeFunctionResult } from '../../utils/abi/decodeFunctionResult.js';\nimport { encodeFunctionData } from '../../utils/abi/encodeFunctionData.js';\nimport { isAddress } from '../../utils/address/isAddress.js';\nimport { getChainContractAddress } from '../../utils/chain/getChainContractAddress.js';\nimport { numberToHex } from '../../utils/encoding/toHex.js';\nimport { getCallError } from '../../utils/errors/getCallError.js';\nimport { extract } from '../../utils/formatters/extract.js';\nimport { formatTransactionRequest } from '../../utils/formatters/transactionRequest.js';\nimport { createBatchScheduler } from '../../utils/promise/createBatchScheduler.js';\nimport { assertRequest } from '../../utils/transaction/assertRequest.js';\n/**\n * Executes a new message call immediately without submitting a transaction to the network.\n *\n * - Docs: https://viem.sh/docs/actions/public/call\n * - JSON-RPC Methods: [`eth_call`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call)\n *\n * @param client - Client to use\n * @param parameters - {@link CallParameters}\n * @returns The call data. {@link CallReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { call } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const data = await call(client, {\n *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n *   data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * })\n */\nexport async function call(client, args) {\n  const {\n    account: account_ = client.account,\n    batch = Boolean(client.batch?.multicall),\n    blockNumber,\n    blockTag = 'latest',\n    accessList,\n    blobs,\n    data,\n    gas,\n    gasPrice,\n    maxFeePerBlobGas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    to,\n    value,\n    stateOverride,\n    ...rest\n  } = args;\n  const account = account_ ? parseAccount(account_) : undefined;\n  try {\n    assertRequest(args);\n    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;\n    const block = blockNumberHex || blockTag;\n    const rpcStateOverride = parseStateOverride(stateOverride);\n    const chainFormat = client.chain?.formatters?.transactionRequest?.format;\n    const format = chainFormat || formatTransactionRequest;\n    const request = format({\n      // Pick out extra data that might exist on the chain's transaction request type.\n      ...extract(rest, {\n        format: chainFormat\n      }),\n      from: account?.address,\n      accessList,\n      blobs,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerBlobGas,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value\n    });\n    if (batch && shouldPerformMulticall({\n      request\n    }) && !rpcStateOverride) {\n      try {\n        return await scheduleMulticall(client, {\n          ...request,\n          blockNumber,\n          blockTag\n        });\n      } catch (err) {\n        if (!(err instanceof ClientChainNotConfiguredError) && !(err instanceof ChainDoesNotSupportContract)) throw err;\n      }\n    }\n    const response = await client.request({\n      method: 'eth_call',\n      params: rpcStateOverride ? [request, block, rpcStateOverride] : [request, block]\n    });\n    if (response === '0x') return {\n      data: undefined\n    };\n    return {\n      data: response\n    };\n  } catch (err) {\n    const data = getRevertErrorData(err);\n    const {\n      offchainLookup,\n      offchainLookupSignature\n    } = await import('../../utils/ccip.js');\n    if (client.ccipRead !== false && data?.slice(0, 10) === offchainLookupSignature && to) return {\n      data: await offchainLookup(client, {\n        data,\n        to\n      })\n    };\n    throw getCallError(err, {\n      ...args,\n      account,\n      chain: client.chain\n    });\n  }\n}\n// We only want to perform a scheduled multicall if:\n// - The request has calldata,\n// - The request has a target address,\n// - The target address is not already the aggregate3 signature,\n// - The request has no other properties (`nonce`, `gas`, etc cannot be sent with a multicall).\nfunction shouldPerformMulticall({\n  request\n}) {\n  const {\n    data,\n    to,\n    ...request_\n  } = request;\n  if (!data) return false;\n  if (data.startsWith(aggregate3Signature)) return false;\n  if (!to) return false;\n  if (Object.values(request_).filter(x => typeof x !== 'undefined').length > 0) return false;\n  return true;\n}\nasync function scheduleMulticall(client, args) {\n  const {\n    batchSize = 1024,\n    wait = 0\n  } = typeof client.batch?.multicall === 'object' ? client.batch.multicall : {};\n  const {\n    blockNumber,\n    blockTag = 'latest',\n    data,\n    multicallAddress: multicallAddress_,\n    to\n  } = args;\n  let multicallAddress = multicallAddress_;\n  if (!multicallAddress) {\n    if (!client.chain) throw new ClientChainNotConfiguredError();\n    multicallAddress = getChainContractAddress({\n      blockNumber,\n      chain: client.chain,\n      contract: 'multicall3'\n    });\n  }\n  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined;\n  const block = blockNumberHex || blockTag;\n  const {\n    schedule\n  } = createBatchScheduler({\n    id: `${client.uid}.${block}`,\n    wait,\n    shouldSplitBatch(args) {\n      const size = args.reduce((size, {\n        data\n      }) => size + (data.length - 2), 0);\n      return size > batchSize * 2;\n    },\n    fn: async requests => {\n      const calls = requests.map(request => ({\n        allowFailure: true,\n        callData: request.data,\n        target: request.to\n      }));\n      const calldata = encodeFunctionData({\n        abi: multicall3Abi,\n        args: [calls],\n        functionName: 'aggregate3'\n      });\n      const data = await client.request({\n        method: 'eth_call',\n        params: [{\n          data: calldata,\n          to: multicallAddress\n        }, block]\n      });\n      return decodeFunctionResult({\n        abi: multicall3Abi,\n        args: [calls],\n        functionName: 'aggregate3',\n        data: data || '0x'\n      });\n    }\n  });\n  const [{\n    returnData,\n    success\n  }] = await schedule({\n    data,\n    to\n  });\n  if (!success) throw new RawContractError({\n    data: returnData\n  });\n  if (returnData === '0x') return {\n    data: undefined\n  };\n  return {\n    data: returnData\n  };\n}\nexport function getRevertErrorData(err) {\n  if (!(err instanceof BaseError)) return undefined;\n  const error = err.walk();\n  return typeof error?.data === 'object' ? error.data?.data : error.data;\n}\nexport function parseStateMapping(stateMapping) {\n  if (!stateMapping || stateMapping.length === 0) return undefined;\n  return stateMapping.reduce((acc, {\n    slot,\n    value\n  }) => {\n    if (slot.length !== 66) throw new InvalidBytesLengthError({\n      size: slot.length,\n      targetSize: 66,\n      type: 'hex'\n    });\n    if (value.length !== 66) throw new InvalidBytesLengthError({\n      size: value.length,\n      targetSize: 66,\n      type: 'hex'\n    });\n    acc[slot] = value;\n    return acc;\n  }, {});\n}\nexport function parseAccountStateOverride(args) {\n  const {\n    balance,\n    nonce,\n    state,\n    stateDiff,\n    code\n  } = args;\n  const rpcAccountStateOverride = {};\n  if (code !== undefined) rpcAccountStateOverride.code = code;\n  if (balance !== undefined) rpcAccountStateOverride.balance = numberToHex(balance);\n  if (nonce !== undefined) rpcAccountStateOverride.nonce = numberToHex(nonce);\n  if (state !== undefined) rpcAccountStateOverride.state = parseStateMapping(state);\n  if (stateDiff !== undefined) {\n    if (rpcAccountStateOverride.state) throw new StateAssignmentConflictError();\n    rpcAccountStateOverride.stateDiff = parseStateMapping(stateDiff);\n  }\n  return rpcAccountStateOverride;\n}\nexport function parseStateOverride(args) {\n  if (!args) return undefined;\n  const rpcStateOverride = {};\n  for (const {\n    address,\n    ...accountState\n  } of args) {\n    if (!isAddress(address, {\n      strict: false\n    })) throw new InvalidAddressError({\n      address\n    });\n    if (rpcStateOverride[address]) throw new AccountStateConflictError({\n      address: address\n    });\n    rpcStateOverride[address] = parseAccountStateOverride(accountState);\n  }\n  return rpcStateOverride;\n}","map":{"version":3,"names":["parseAccount","multicall3Abi","aggregate3Signature","InvalidAddressError","BaseError","ChainDoesNotSupportContract","ClientChainNotConfiguredError","RawContractError","InvalidBytesLengthError","AccountStateConflictError","StateAssignmentConflictError","decodeFunctionResult","encodeFunctionData","isAddress","getChainContractAddress","numberToHex","getCallError","extract","formatTransactionRequest","createBatchScheduler","assertRequest","call","client","args","account","account_","batch","Boolean","multicall","blockNumber","blockTag","accessList","blobs","data","gas","gasPrice","maxFeePerBlobGas","maxFeePerGas","maxPriorityFeePerGas","nonce","to","value","stateOverride","rest","undefined","blockNumberHex","block","rpcStateOverride","parseStateOverride","chainFormat","chain","formatters","transactionRequest","format","request","from","address","shouldPerformMulticall","scheduleMulticall","err","response","method","params","getRevertErrorData","offchainLookup","offchainLookupSignature","ccipRead","slice","request_","startsWith","Object","values","filter","x","length","batchSize","wait","multicallAddress","multicallAddress_","contract","schedule","id","uid","shouldSplitBatch","size","reduce","fn","requests","calls","map","allowFailure","callData","target","calldata","abi","functionName","returnData","success","error","walk","parseStateMapping","stateMapping","acc","slot","targetSize","type","parseAccountStateOverride","balance","state","stateDiff","code","rpcAccountStateOverride","accountState","strict"],"sources":["/Users/nikhilbhatia/NIkhil/ZT-Prejects/wagmi-react-app/node_modules/viem/actions/public/call.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { multicall3Abi } from '../../constants/abis.js'\nimport { aggregate3Signature } from '../../constants/contract.js'\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport { BaseError } from '../../errors/base.js'\nimport {\n  ChainDoesNotSupportContract,\n  ClientChainNotConfiguredError,\n} from '../../errors/chain.js'\nimport {\n  RawContractError,\n  type RawContractErrorType,\n} from '../../errors/contract.js'\nimport {\n  InvalidBytesLengthError,\n  type InvalidBytesLengthErrorType,\n} from '../../errors/data.js'\nimport {\n  AccountStateConflictError,\n  type AccountStateConflictErrorType,\n  StateAssignmentConflictError,\n  type StateAssignmentConflictErrorType,\n} from '../../errors/stateOverride.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hex } from '../../types/misc.js'\nimport type {\n  RpcAccountStateOverride,\n  RpcStateMapping,\n  RpcStateOverride,\n  RpcTransactionRequest,\n} from '../../types/rpc.js'\nimport type { StateMapping, StateOverride } from '../../types/stateOverride.js'\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport type { ExactPartial, UnionOmit } from '../../types/utils.js'\nimport {\n  type DecodeFunctionResultErrorType,\n  decodeFunctionResult,\n} from '../../utils/abi/decodeFunctionResult.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport { isAddress } from '../../utils/address/isAddress.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type GetChainContractAddressErrorType,\n  getChainContractAddress,\n} from '../../utils/chain/getChainContractAddress.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport {\n  type GetCallErrorReturnType,\n  getCallError,\n} from '../../utils/errors/getCallError.js'\nimport { extract } from '../../utils/formatters/extract.js'\nimport {\n  type FormatTransactionRequestErrorType,\n  type FormattedTransactionRequest,\n  formatTransactionRequest,\n} from '../../utils/formatters/transactionRequest.js'\nimport {\n  type CreateBatchSchedulerErrorType,\n  createBatchScheduler,\n} from '../../utils/promise/createBatchScheduler.js'\nimport { assertRequest } from '../../utils/transaction/assertRequest.js'\nimport type {\n  AssertRequestErrorType,\n  AssertRequestParameters,\n} from '../../utils/transaction/assertRequest.js'\n\nexport type FormattedCall<\n  TChain extends Chain | undefined = Chain | undefined,\n> = FormattedTransactionRequest<TChain>\n\nexport type CallParameters<\n  TChain extends Chain | undefined = Chain | undefined,\n> = UnionOmit<FormattedCall<TChain>, 'from'> & {\n  account?: Account | Address | undefined\n  batch?: boolean | undefined\n  stateOverride?: StateOverride | undefined\n} & (\n    | {\n        /** The balance of the account at a block number. */\n        blockNumber?: bigint | undefined\n        blockTag?: never | undefined\n      }\n    | {\n        blockNumber?: never | undefined\n        /**\n         * The balance of the account at a block tag.\n         * @default 'latest'\n         */\n        blockTag?: BlockTag | undefined\n      }\n  )\n\nexport type CallReturnType = { data: Hex | undefined }\n\nexport type CallErrorType = GetCallErrorReturnType<\n  | ParseAccountErrorType\n  | ParseStateOverrideErrorType\n  | AssertRequestErrorType\n  | NumberToHexErrorType\n  | FormatTransactionRequestErrorType\n  | ScheduleMulticallErrorType\n  | RequestErrorType\n>\n\n/**\n * Executes a new message call immediately without submitting a transaction to the network.\n *\n * - Docs: https://viem.sh/docs/actions/public/call\n * - JSON-RPC Methods: [`eth_call`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call)\n *\n * @param client - Client to use\n * @param parameters - {@link CallParameters}\n * @returns The call data. {@link CallReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { call } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const data = await call(client, {\n *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n *   data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * })\n */\nexport async function call<TChain extends Chain | undefined>(\n  client: Client<Transport, TChain>,\n  args: CallParameters<TChain>,\n): Promise<CallReturnType> {\n  const {\n    account: account_ = client.account,\n    batch = Boolean(client.batch?.multicall),\n    blockNumber,\n    blockTag = 'latest',\n    accessList,\n    blobs,\n    data,\n    gas,\n    gasPrice,\n    maxFeePerBlobGas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    to,\n    value,\n    stateOverride,\n    ...rest\n  } = args\n  const account = account_ ? parseAccount(account_) : undefined\n\n  try {\n    assertRequest(args as AssertRequestParameters)\n\n    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined\n    const block = blockNumberHex || blockTag\n\n    const rpcStateOverride = parseStateOverride(stateOverride)\n\n    const chainFormat = client.chain?.formatters?.transactionRequest?.format\n    const format = chainFormat || formatTransactionRequest\n\n    const request = format({\n      // Pick out extra data that might exist on the chain's transaction request type.\n      ...extract(rest, { format: chainFormat }),\n      from: account?.address,\n      accessList,\n      blobs,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerBlobGas,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value,\n    } as TransactionRequest) as TransactionRequest\n\n    if (batch && shouldPerformMulticall({ request }) && !rpcStateOverride) {\n      try {\n        return await scheduleMulticall(client, {\n          ...request,\n          blockNumber,\n          blockTag,\n        } as unknown as ScheduleMulticallParameters<TChain>)\n      } catch (err) {\n        if (\n          !(err instanceof ClientChainNotConfiguredError) &&\n          !(err instanceof ChainDoesNotSupportContract)\n        )\n          throw err\n      }\n    }\n\n    const response = await client.request({\n      method: 'eth_call',\n      params: rpcStateOverride\n        ? [\n            request as ExactPartial<RpcTransactionRequest>,\n            block,\n            rpcStateOverride,\n          ]\n        : [request as ExactPartial<RpcTransactionRequest>, block],\n    })\n    if (response === '0x') return { data: undefined }\n    return { data: response }\n  } catch (err) {\n    const data = getRevertErrorData(err)\n    const { offchainLookup, offchainLookupSignature } = await import(\n      '../../utils/ccip.js'\n    )\n    if (\n      client.ccipRead !== false &&\n      data?.slice(0, 10) === offchainLookupSignature &&\n      to\n    )\n      return { data: await offchainLookup(client, { data, to }) }\n    throw getCallError(err as ErrorType, {\n      ...args,\n      account,\n      chain: client.chain,\n    })\n  }\n}\n\n// We only want to perform a scheduled multicall if:\n// - The request has calldata,\n// - The request has a target address,\n// - The target address is not already the aggregate3 signature,\n// - The request has no other properties (`nonce`, `gas`, etc cannot be sent with a multicall).\nfunction shouldPerformMulticall({ request }: { request: TransactionRequest }) {\n  const { data, to, ...request_ } = request\n  if (!data) return false\n  if (data.startsWith(aggregate3Signature)) return false\n  if (!to) return false\n  if (\n    Object.values(request_).filter((x) => typeof x !== 'undefined').length > 0\n  )\n    return false\n  return true\n}\n\ntype ScheduleMulticallParameters<TChain extends Chain | undefined> = Pick<\n  CallParameters<TChain>,\n  'blockNumber' | 'blockTag'\n> & {\n  data: Hex\n  multicallAddress?: Address | undefined\n  to: Address\n}\n\nexport type ScheduleMulticallErrorType =\n  | GetChainContractAddressErrorType\n  | NumberToHexErrorType\n  | CreateBatchSchedulerErrorType\n  | EncodeFunctionDataErrorType\n  | DecodeFunctionResultErrorType\n  | RawContractErrorType\n  | ErrorType\n\nasync function scheduleMulticall<TChain extends Chain | undefined>(\n  client: Client<Transport>,\n  args: ScheduleMulticallParameters<TChain>,\n) {\n  const { batchSize = 1024, wait = 0 } =\n    typeof client.batch?.multicall === 'object' ? client.batch.multicall : {}\n  const {\n    blockNumber,\n    blockTag = 'latest',\n    data,\n    multicallAddress: multicallAddress_,\n    to,\n  } = args\n\n  let multicallAddress = multicallAddress_\n  if (!multicallAddress) {\n    if (!client.chain) throw new ClientChainNotConfiguredError()\n\n    multicallAddress = getChainContractAddress({\n      blockNumber,\n      chain: client.chain,\n      contract: 'multicall3',\n    })\n  }\n\n  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined\n  const block = blockNumberHex || blockTag\n\n  const { schedule } = createBatchScheduler({\n    id: `${client.uid}.${block}`,\n    wait,\n    shouldSplitBatch(args) {\n      const size = args.reduce((size, { data }) => size + (data.length - 2), 0)\n      return size > batchSize * 2\n    },\n    fn: async (\n      requests: {\n        data: Hex\n        to: Address\n      }[],\n    ) => {\n      const calls = requests.map((request) => ({\n        allowFailure: true,\n        callData: request.data,\n        target: request.to,\n      }))\n\n      const calldata = encodeFunctionData({\n        abi: multicall3Abi,\n        args: [calls],\n        functionName: 'aggregate3',\n      })\n\n      const data = await client.request({\n        method: 'eth_call',\n        params: [\n          {\n            data: calldata,\n            to: multicallAddress,\n          },\n          block,\n        ],\n      })\n\n      return decodeFunctionResult({\n        abi: multicall3Abi,\n        args: [calls],\n        functionName: 'aggregate3',\n        data: data || '0x',\n      })\n    },\n  })\n\n  const [{ returnData, success }] = await schedule({ data, to })\n\n  if (!success) throw new RawContractError({ data: returnData })\n  if (returnData === '0x') return { data: undefined }\n  return { data: returnData }\n}\n\nexport type GetRevertErrorDataErrorType = ErrorType\n\nexport function getRevertErrorData(err: unknown) {\n  if (!(err instanceof BaseError)) return undefined\n  const error = err.walk() as RawContractError\n  return typeof error?.data === 'object' ? error.data?.data : error.data\n}\n\nexport type ParseStateMappingErrorType = InvalidBytesLengthErrorType\n\nexport function parseStateMapping(\n  stateMapping: StateMapping | undefined,\n): RpcStateMapping | undefined {\n  if (!stateMapping || stateMapping.length === 0) return undefined\n  return stateMapping.reduce((acc, { slot, value }) => {\n    if (slot.length !== 66)\n      throw new InvalidBytesLengthError({\n        size: slot.length,\n        targetSize: 66,\n        type: 'hex',\n      })\n    if (value.length !== 66)\n      throw new InvalidBytesLengthError({\n        size: value.length,\n        targetSize: 66,\n        type: 'hex',\n      })\n    acc[slot] = value\n    return acc\n  }, {} as RpcStateMapping)\n}\n\nexport type ParseAccountStateOverrideErrorType =\n  | NumberToHexErrorType\n  | StateAssignmentConflictErrorType\n  | ParseStateMappingErrorType\n\nexport function parseAccountStateOverride(\n  args: Omit<StateOverride[number], 'address'>,\n): RpcAccountStateOverride {\n  const { balance, nonce, state, stateDiff, code } = args\n  const rpcAccountStateOverride: RpcAccountStateOverride = {}\n  if (code !== undefined) rpcAccountStateOverride.code = code\n  if (balance !== undefined)\n    rpcAccountStateOverride.balance = numberToHex(balance)\n  if (nonce !== undefined) rpcAccountStateOverride.nonce = numberToHex(nonce)\n  if (state !== undefined)\n    rpcAccountStateOverride.state = parseStateMapping(state)\n  if (stateDiff !== undefined) {\n    if (rpcAccountStateOverride.state) throw new StateAssignmentConflictError()\n    rpcAccountStateOverride.stateDiff = parseStateMapping(stateDiff)\n  }\n  return rpcAccountStateOverride\n}\n\nexport type ParseStateOverrideErrorType =\n  | InvalidAddressErrorType\n  | AccountStateConflictErrorType\n  | ParseAccountStateOverrideErrorType\n\nexport function parseStateOverride(\n  args?: StateOverride | undefined,\n): RpcStateOverride | undefined {\n  if (!args) return undefined\n  const rpcStateOverride: RpcStateOverride = {}\n  for (const { address, ...accountState } of args) {\n    if (!isAddress(address, { strict: false }))\n      throw new InvalidAddressError({ address })\n    if (rpcStateOverride[address])\n      throw new AccountStateConflictError({ address: address })\n    rpcStateOverride[address] = parseAccountStateOverride(accountState)\n  }\n  return rpcStateOverride\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}